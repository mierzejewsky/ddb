/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 320:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "d": () => (/* binding */ characterExtras)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(259);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(555);
/* harmony import */ var _muncher_monster_monster_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(519);
/* harmony import */ var _muncher_import_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(193);
/* harmony import */ var _muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(633);
/* harmony import */ var _ddbConfig_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(31);
/* harmony import */ var _muncher_monster_abilities_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(184);
/* harmony import */ var _muncher_monster_skills_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(415);









const MUNCH_DEFAULTS = [
  { name: "munching-policy-update-existing", needed: true },
  { name: "munching-policy-use-srd", needed: false },
  { name: "munching-policy-use-inbuilt-icons", needed: true },
  { name: "munching-policy-use-srd-icons", needed: false },
  { name: "munching-policy-download-images", needed: true },
  { name: "munching-policy-remote-images", needed: false },
  { name: "munching-policy-use-dae-effects", needed: false },
  { name: "munching-policy-hide-description", needed: false },
  { name: "munching-policy-monster-items", needed: false },
  { name: "munching-policy-update-images", needed: false },
  { name: "munching-policy-dae-copy", needed: false },
];

function getCustomValue(ddbCharacter, typeId, valueId, valueTypeId) {
  const characterValues = ddbCharacter.characterValues;
  const customValue = characterValues.find(
    (value) => value.valueId == valueId && value.valueTypeId == valueTypeId && value.typeId == typeId
  );

  if (customValue) {
    return customValue.value;
  }
  return null;
}

async function updateExtras(extras, existingExtras) {
  return Promise.all(
    extras
      .filter((extra) =>
        existingExtras.some(
          (exist) =>
            exist.flags?.ddbimporter?.id === extra.flags.ddbimporter.id &&
            extra.flags?.ddbimporter?.entityTypeId === extra.flags.ddbimporter.entityTypeId
        )
      )
      .map(async (extra) => {
        const existingExtra = await existingExtras.find(
          (exist) =>
            exist.flags?.ddbimporter?.id === extra.flags.ddbimporter.id &&
            extra.flags?.ddbimporter?.entityTypeId === extra.flags.ddbimporter.entityTypeId
        );
        extra._id = existingExtra._id;
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.info */ .Z.info(`Updating extra ${extra.name}`);
        await (0,_muncher_import_js__WEBPACK_IMPORTED_MODULE_3__/* .copySupportedItemFlags */ .uf)(existingExtra, extra);
        // await Actor.update(extra);
        await (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_4__/* .buildNPC */ .ln)(extra, false, true, true);
        return extra;
      })
  );
}

async function createExtras(extras, existingExtras, folderId) {
  return Promise.all(
    extras
      .filter(
        (extra) =>
          !existingExtras.some(
            (exist) =>
              exist.flags?.ddbimporter?.id === extra.flags.ddbimporter.id &&
              extra.flags?.ddbimporter?.entityTypeId === extra.flags.ddbimporter.entityTypeId
          )
      )
      .map(async (extra) => {
        if (!game.user.can("ITEM_CREATE")) {
          ui.notifications.warn(`Cannot create Extra ${extra.name}`);
        } else {
          _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.info */ .Z.info(`Creating Extra ${extra.name}`);
          extra.folder = folderId;
          const importedExtra = await (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_4__/* .buildNPC */ .ln)(extra, false, false, true);
          return importedExtra;
        }
        return extra;
      })
  );
}

function generateBeastCompanionEffects(extra, characterProficiencyBonus) {
  // beast master get to add proficiency bonus to current attacks, damage, ac
  // and saving throws and skills it is proficient in.
  // extra.data.details.cr = actor.data.flags.ddbimporter.dndbeyond.totalLevels;

  let effect = {
    changes: [
      {
        key: "data.bonuses.rwak.attack",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
      {
        key: "data.bonuses.rwak.damage",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
      {
        key: "data.bonuses.mwak.attack",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
      {
        key: "data.bonuses.mwak.damage",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
    ],
    duration: {
      seconds: null,
      startTime: null,
      rounds: null,
      turns: null,
      startRound: null,
      startTurn: null,
    },
    label: "Beast Companion Effects",
    tint: "",
    disabled: false,
    selectedKey: [],
  };
  _muncher_monster_abilities_js__WEBPACK_IMPORTED_MODULE_5__/* .ABILITIES.filter */ .RS.filter((ability) => extra.data.abilities[ability.value].proficient >= 1).forEach((ability) => {
    const boost = {
      key: `data.abilities.${ability.value}.save`,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: characterProficiencyBonus,
      priority: 20,
    };
    effect.selectedKey.push(`data.abilities.${ability.value}.save`);
    effect.changes.push(boost);
  });
  _muncher_monster_skills_js__WEBPACK_IMPORTED_MODULE_6__/* .SKILLS.filter */ .HG.filter((skill) => extra.data.skills[skill.name].prof >= 1).forEach((skill) => {
    const boost = {
      key: `data.skills.${skill.name}.mod`,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: characterProficiencyBonus,
      priority: 20,
    };
    effect.selectedKey.push(`data.skills.${skill.name}.mod`);
    effect.changes.push(boost);
  });
  extra.effects = [effect];
  return extra;
}

function generateArtificerEffects(actor, extra, characterProficiencyBonus) {
  // artificer uses the actors spell attack bonus, so is a bit trickier
  // we remove damage bonus later, and will also have to calculate additional attack bonus for each attack
  extra.data.details.cr = actor.data.flags.ddbimporter.dndbeyond.totalLevels;

  let effect = {
    changes: [
      {
        key: "data.bonuses.rwak.damage",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
      {
        key: "data.bonuses.mwak.damage",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
    ],
    duration: {
      seconds: null,
      startTime: null,
      rounds: null,
      turns: null,
      startRound: null,
      startTurn: null,
    },
    label: "Artificer Extra Effects",
    tint: "",
    disabled: false,
    selectedKey: [],
  };
  extra.effects = [effect];
  return extra;
}

const creatureGroupMatrix = [
  {
    id: 1,
    name: "Wildshape",
    animation: "fourelements",
  },
  {
    id: 2,
    name: "Familiar",
    animation: "magic1",
  },
  {
    id: 3,
    name: "Beast Companion",
    animation: "fourelements",
  },
  {
    id: 4,
    name: "Mount",
    animation: "heart",
  },
  {
    id: 5,
    name: "Pet",
    animation: "heart",
  },
  {
    id: 6,
    name: "Summoned",
    animation: "magic1",
  },
  {
    id: 7,
    name: "Misc",
    animation: "magic1",
  },
  {
    id: 10,
    name: "Battle Smith Defender",
    animation: "energy1",
  },
  {
    id: 11,
    name: "Sidekick",
    animation: "energy1",
  },
  {
    id: 12,
    name: "Infusion",
    animation: "energy1",
  },
];

function getCreatureAnimationType(name, creatureGroup) {
  // "fire":
  // "air":
  // "lightning":
  // "water":
  // "energy1":
  // "magic1":
  // "heart":
  // "music":
  // "fourelements":
  const checkName = name.toLowerCase();
  let animation = "magic1";
  switch (name) {
    case checkName.includes("flame"):
    case checkName.includes("fire"):
      animation = "fire";
      break;
    case checkName.includes("air"):
    case checkName.includes("wind"):
      animation = "air";
      break;
    case checkName.includes("lightning"):
    case checkName.includes("thunder"):
      animation = "lightning";
      break;
    case checkName.includes("water"):
    case checkName.includes("aqua"):
      animation = "water";
      break;
    case checkName.includes("energy"):
    case checkName.includes("construct"):
      animation = "energy1";
      break;
    case checkName.includes("magic"):
    case checkName.includes("arcane"):
      animation = "magic1";
      break;
    default: {
      const match = creatureGroupMatrix.find((group) => group.id === creatureGroup.id);
      if (match) {
        animation = match.animation;
      }
    }
  }

  return animation;
}

async function characterExtras(html, characterData, actor) {
  let munchSettings = [];
  let ddbCharacter = characterData.ddb.character;

  MUNCH_DEFAULTS.forEach((setting) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.debug */ .Z.debug(`Loading extras munch settings ${setting.name}`);
    setting["chosen"] = game.settings.get("ddb-importer", setting.name);
    munchSettings.push(setting);
  });

  munchSettings.forEach((setting) => {
    game.settings.set("ddb-importer", setting.name, setting.needed);
  });

  try {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.debug */ .Z.debug(characterData);
    if (ddbCharacter.creatures.length === 0) return;

    const folder = await _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.getOrCreateFolder */ .Z.getOrCreateFolder(actor.folder, "Actor", `[Extras] ${actor.name}`);

    // eslint-disable-next-line complexity
    let creatures = ddbCharacter.creatures.map((creature) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.debug */ .Z.debug("Extra data", creature);
      let mock = JSON.parse(JSON.stringify(creature.definition));
      const proficiencyBonus = _ddbConfig_js__WEBPACK_IMPORTED_MODULE_7__/* .DDB_CONFIG.challengeRatings.find */ .U.challengeRatings.find(
        (cr) => cr.id == mock.challengeRatingId
      ).proficiencyBonus;
      const creatureGroup = _ddbConfig_js__WEBPACK_IMPORTED_MODULE_7__/* .DDB_CONFIG.creatureGroups.find */ .U.creatureGroups.find((group) => group.id == creature.groupId);
      let creatureFlags = creatureGroup.flags;

      mock.id = creature.id;
      mock.entityTypeId = creature.entityTypeId;

      if (creature.definition.name === "Homunculus Servant") {
        creatureFlags = creatureFlags.concat(["MHPAMCM", "MHPAIM", "MHPBAL", "ARPB", "PSPB"]);
      }
      mock.creatureFlags = creatureFlags;
      mock.removedHitPoints = creature.removedHitPoints;
      mock.temporaryHitPoints = creature.temporaryHitPoints;
      mock.creatureGroup = creature.groupId;

      if (creature.name) mock.name = creature.name;

      // creature group
      mock.automatedEvcoationAnimation = getCreatureAnimationType(mock.name, creatureGroup);

      // size
      const sizeChange = getCustomValue(ddbCharacter, 46, creature.id, creature.entityTypeId);
      if (sizeChange) mock.sizeId = sizeChange;

      // hp
      const hpMaxChange = getCustomValue(ddbCharacter, 43, creature.id, creature.entityTypeId);
      if (hpMaxChange) mock.averageHitPoints = hpMaxChange;

      // creature type
      const typeChange = getCustomValue(ddbCharacter, 44, creature.id, creature.entityTypeId);
      if (typeChange) mock.typeId = typeChange;

      // ac
      const acChange = getCustomValue(ddbCharacter, 42, creature.id, creature.entityTypeId);
      if (acChange) mock.armorClass = acChange;

      // alignment
      const alignmentChange = getCustomValue(ddbCharacter, 45, creature.id, creature.entityTypeId);
      if (alignmentChange) mock.alignmentId = alignmentChange;

      // notes
      const extraNotes = getCustomValue(ddbCharacter, 47, creature.id, creature.entityTypeId);
      if (extraNotes) mock.characteristicsDescription += `\n\n${extraNotes}`;

      const creatureStats = mock.stats.filter((stat) => !creatureGroup.ownerStats.includes(stat.statId));
      const characterStats = mock.stats
        .filter((stat) => creatureGroup.ownerStats.includes(stat.statId))
        .map((stat) => {
          const value = actor.data.data.abilities[_muncher_monster_abilities_js__WEBPACK_IMPORTED_MODULE_5__/* .ABILITIES.find */ .RS.find((a) => a.id === stat.statId).value].value;
          return { name: null, statId: stat.statId, value: value };
        });

      mock.stats = creatureStats.concat(characterStats);

      // permissions the same as
      mock.permission = actor.data.permission;
      mock.folder = folder.id;

      if (creatureGroup.description !== "") {
        mock.characteristicsDescription = `${creatureGroup.description}\n\n${mock.characteristicsDescription}`;
      }

      if (creatureGroup.specialQualityTitle) {
        mock.specialTraitsDescription = `${mock.specialTraitsDescription} <p><em><strong>${creatureGroup.specialQualityTitle}.</strong></em> ${creatureGroup.specialQualityText}</p>`;
      }

      if (creatureFlags.includes("ACPB")) {
        mock.armorClass += actor.data.data.attributes.prof;
      }

      // assume this is beast master
      if (creatureFlags.includes("HPLM")) {
        const ranger = ddbCharacter.classes.find((klass) => klass.definition.id === 5);
        const level = ranger ? ranger.level : 0;
        mock.averageHitPoints = Math.max(mock.averageHitPoints, 4 * level);
      }

      // homunculus servant
      if (creatureFlags.includes("MHPBAL")) {
        const artificer = ddbCharacter.classes.find((klass) => klass.definition.name === "Artificer");
        mock.averageHitPoints = parseInt(artificer.level);
      }

      if (creatureFlags.includes("AHM")) {
        const artificer = ddbCharacter.classes.find((klass) => klass.definition.name === "Artificer");
        mock.averageHitPoints = parseInt(5 * artificer.level);
      }

      if (creatureFlags.includes("MHPAIM")) {
        mock.averageHitPoints += parseInt(actor.data.data.abilities.int.mod);
      }

      if (creatureFlags.includes("MHPAMCM")) {
        const monsterConModifier = (0,_muncher_monster_abilities_js__WEBPACK_IMPORTED_MODULE_5__/* .getAbilityMods */ .Tx)(mock, _ddbConfig_js__WEBPACK_IMPORTED_MODULE_7__/* .DDB_CONFIG */ .U);
        mock.averageHitPoints += parseInt(monsterConModifier.con);
      }

      // add owner skill profs
      if (creatureFlags.includes("EOSKP")) {
        let newSkills = [];

        _muncher_monster_skills_js__WEBPACK_IMPORTED_MODULE_6__/* .SKILLS.forEach */ .HG.forEach((skill) => {
          const existingSkill = mock.skills.find((mockSkill) => skill.valueId === mockSkill.skillId);
          const characterProficient = characterData.character.character.data.skills[skill.name].value;

          const ability = _muncher_monster_abilities_js__WEBPACK_IMPORTED_MODULE_5__/* .ABILITIES.find */ .RS.find((ab) => ab.value === skill.ability);
          const stat = mock.stats.find((stat) => stat.statId === ability.id).value || 10;
          const mod = _ddbConfig_js__WEBPACK_IMPORTED_MODULE_7__/* .DDB_CONFIG.statModifiers.find */ .U.statModifiers.find((s) => s.value == stat).modifier;

          if (existingSkill && characterProficient === 2) {
            const doubleProf = proficiencyBonus * 2;
            newSkills.push({
              skillId: skill.valueId,
              value: mod + doubleProf,
              additionalBonus: null,
            });
          } else if (existingSkill) {
            newSkills.push(existingSkill);
          } else if (characterProficient === 1) {
            newSkills.push({
              skillId: skill.valueId,
              value: mod + proficiencyBonus,
              additionalBonus: null,
            });
          }
        });
        mock.skills = newSkills;
      }

      // add owner save profs
      if (creatureFlags.includes("EOSVP")) {
        let newSaves = [];
        _muncher_monster_abilities_js__WEBPACK_IMPORTED_MODULE_5__/* .ABILITIES.forEach */ .RS.forEach((ability) => {
          const existingProficient = mock.savingThrows.find((stat) => stat.statId === ability.id) ? 1 : 0;
          const characterProficient = characterData.character.character.data.abilities[ability.value].proficient;

          if (existingProficient || characterProficient) {
            const bonus = {
              bonusModifier: null,
              statId: ability.id,
            };
            newSaves.push(bonus);
          }
        });
        mock.savingThrows = newSaves;
      }

      if (creatureFlags.includes("CULGA")) {
        mock.isLegendary = false;
        mock.legendaryActionsDescription = "";
      }

      if (creatureFlags.includes("CULRA")) {
        mock.hasLair = false;
        mock.lairDescription = "";
      }

      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.debug */ .Z.debug(mock);
      return mock;
    });
    let parsedExtras = await (0,_muncher_monster_monster_js__WEBPACK_IMPORTED_MODULE_2__/* .parseMonsters */ .U)(creatures, true);
    parsedExtras = parsedExtras.actors;
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.debug */ .Z.debug(parsedExtras);

    const damageDiceExpression = /(\d*d\d+\s*\+*\s*)+/;
    const characterProficiencyBonus = actor.data.data.attributes.prof;
    const artificerBonusGroup = [10, 12];

    parsedExtras = parsedExtras.map((extra) => {
      if (
        extra.flags?.ddbimporter?.creatureFlags?.includes("ARPB") &&
        extra.flags?.ddbimporter?.creatureFlags?.includes("PSPB")
      ) {
        if (extra.flags?.ddbimporter?.creatureGroup === 3) {
          extra = generateBeastCompanionEffects(extra, characterProficiencyBonus);
        } else if (artificerBonusGroup.includes(extra.flags?.ddbimporter?.creatureGroup)) {
          // artificer uses the actors spell attack bonus, so is a bit trickier
          // we remove damage bonus later, and will also have to calculate additional attack bonus for each attack
          extra = generateArtificerEffects(actor, extra, characterProficiencyBonus);
        } else {
          // who knows!
          extra.data.details.cr = actor.data.flags.ddbimporter.dndbeyond.totalLevels;
        }
      }

      if (
        (extra.flags?.ddbimporter?.creatureFlags?.includes("DRPB") && extra.flags?.ddbimporter?.creatureGroup !== 3) ||
        // is this a artificer infusion? the infusion call actually adds this creature group, but we don't fetch that yet.
        extra.flags?.ddbimporter?.creatureGroup === 12
      ) {
        extra.items = extra.items.map((item) => {
          if (item.type === "weapon") {
            let characterAbility;

            item.data.damage.parts = item.data.damage.parts.map((part) => {
              const match = part[0].match(damageDiceExpression);
              if (match) {
                let dice = match[0];
                // the artificer creatures have the initial prof built in, lets replace it
                if (artificerBonusGroup.includes(extra.flags?.ddbimporter?.creatureGroup)) {
                  characterAbility = "int";
                  dice = match[1].trim().endsWith("+") ? match[1].trim().slice(0, -1) : match[1];
                }
                part[0] = `${dice.trim()}`;
              }

              return part;
            });

            if (characterAbility) {
              const ability = item.data.ability;
              const mod = parseInt(extra.data.abilities[ability].mod);
              const characterMod = parseInt(actor.data.data.abilities[characterAbility].mod);
              // eslint-disable-next-line no-eval
              const globalMod = parseInt(eval(actor.data.data.bonuses.rsak.attack || 0));
              item.data.attackBonus = characterMod + globalMod - mod;
            }
          }
          return item;
        });
      }

      return extra;
    });

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.debug */ .Z.debug("Parsed Extras:", parsedExtras);

    const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");
    const updateImages = game.settings.get("ddb-importer", "munching-policy-update-images");
    // const uploadDirectory = game.settings.get("ddb-importer", "image-upload-directory").replace(/^\/|\/$/g, "");

    const existingExtras = await game.actors.contents
      .filter((extra) => extra.data.folder === folder.id)
      .map((extra) => extra.data);

    if (!updateBool || !updateImages) {
      if (!updateImages) {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.debug */ .Z.debug("Copying monster images across...");
        parsedExtras = (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_4__/* .copyExistingMonsterImages */ .ph)(parsedExtras, existingExtras);
      }
    }

    let finalExtras = await (0,_muncher_import_js__WEBPACK_IMPORTED_MODULE_3__/* .srdFiddling */ .cC)(parsedExtras, "monsters");
    await (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_4__/* .generateIconMap */ .NM)(finalExtras);

    if (updateBool) await updateExtras(finalExtras, existingExtras);
    const importedExtras = await createExtras(finalExtras, existingExtras, folder.id);

    const currentAutomatedEvocationSettings = {
      isLocal: actor.getFlag("automated-evocations", "isLocal"),
      companions: actor.getFlag("automated-evocations", "isLocal"),
    };

    const companions = existingExtras.concat(importedExtras).map((extra) => {
      return {
        id: extra.id ? extra.id : extra._id,
        number: 1,
        animation: extra.data.flags?.ddbimporter?.automatedEvcoationAnimation
          ? extra.data.flags?.ddbimporter?.automatedEvcoationAnimation
          : "magic1",
      };
    });
    const newAutomatedEvocationSettings = {
      isLocal: true,
      companions,
    };
    const mergedSettings = mergeObject(currentAutomatedEvocationSettings, newAutomatedEvocationSettings);

    actor.setFlag("automated-evocations", "isLocal", mergedSettings.isLocal);
    actor.setFlag("automated-evocations", "companions", mergedSettings.companions);
  } catch (err) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.error */ .Z.error("Failure parsing extra", err);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.error */ .Z.error(err.stack);
  } finally {
    munchSettings.forEach((setting) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.debug */ .Z.debug(`Returning ${setting.name} to ${setting.chosen}`);
      game.settings.set("ddb-importer", setting.name, setting.chosen);
    });
  }
}


/***/ }),

/***/ 31:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": () => (/* binding */ DDB_CONFIG),
/* harmony export */   "p": () => (/* binding */ loadDDBConfig)
/* harmony export */ });
var DDB_CONFIG;

async function getDDBConfig() {
  DDB_CONFIG = await $.getJSON("https://www.dndbeyond.com/api/config/json");
}

function loadDDBConfig() {
  if (!DDB_CONFIG) {
    getDDBConfig();
  }
}



/***/ }),

/***/ 37:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const DICTIONARY = {
  types: {
    equipment: ["equipment", "consumable", "tool", "loot", "backpack"],
    inventory: ["equipment", "consumable", "tool", "loot", "backpack", "weapon"],
    monster: ["equipment", "consumable", "tool", "loot", "backpack", "weapon", "feat"],
  },
  numbers: [
    { num: 1, natural: "a" },
    { num: 1, natural: "one" },
    { num: 2, natural: "two" },
    { num: 3, natural: "three" },
    { num: 4, natural: "four" },
    { num: 5, natural: "five" },
    { num: 6, natural: "six" },
    { num: 7, natural: "seven" },
    { num: 8, natural: "eight" },
    { num: 9, natural: "nine" },
    { num: 10, natural: "ten" },
    { num: 11, natural: "eleven" },
    { num: 12, natural: "twelve" },
    { num: 13, natural: "thirteen" },
    { num: 14, natural: "fourteen" },
    { num: 15, natural: "fifteen" },
    { num: 16, natural: "sixteen" },
    { num: 17, natural: "seventeen" },
    { num: 18, natural: "eighteen" },
    { num: 19, natural: "nineteen" },
    { num: 20, natural: "twenty" },
  ],
  magicitems: {
    rechargeUnits: [
      { id: 1, value: "r4" },
      { id: "ShortRest", value: "r4" },
      { id: 2, value: "r5" },
      { id: "LongRest", value: "r5" },
      { id: "Dawn", value: "r2" },
      { id: "Dusk", value: "r3" },
      { id: "Sunset", value: "r3" },
      { id: "Consumable", value: "" },
      { id: "Other", value: "" },
      { id: "Daily", value: "r1" },
      { id: "sr", value: "r4" },
      { id: "lr", value: "r5" },
    ],
    nums: [
      { id: "once", value: 1 },
      { id: "twice", value: 2 },
      { id: "thrice", value: 3 },
      { id: "one", value: 1 },
      { id: "two", value: 2 },
      { id: "three", value: 3 },
    ],
  },
  resets: [
    { id: 1, value: "sr" },
    { id: "ShortRest", value: "sr" },
    { id: "Short", value: "sr" },
    { id: "short", value: "sr" },
    { id: 2, value: "lr" },
    { id: "LongRest", value: "lr" },
    { id: "Long", value: "lr" },
    { id: "long", value: "lr" },
    { id: "Day", value: "day" },
    { id: "day", value: "day" },
    { id: "Dawn", value: "day" },
    { id: "dusk", value: "day" },
    { id: "Consumable", value: "charges" },
    { id: "Other", value: "charges" },
    { id: "", value: "" },
    { id: null, value: "" },
  ],
  character: {
    abilities: [
      { id: 1, value: "str", long: "strength" },
      { id: 2, value: "dex", long: "dexterity" },
      { id: 3, value: "con", long: "constitution" },
      { id: 4, value: "int", long: "intelligence" },
      { id: 5, value: "wis", long: "wisdom" },
      { id: 6, value: "cha", long: "charisma" },
    ],
    skills: [
      { name: "acr", label: "Acrobatics", ability: "dex", subType: "acrobatics", valueId: 3 },
      { name: "ani", label: "Animal Handling", ability: "wis", subType: "animal-handling", valueId: 11 },
      { name: "arc", label: "Arcana", ability: "int", subType: "arcana", valueId: 6 },
      { name: "ath", label: "Athletics", ability: "str", subType: "athletics", valueId: 2 },
      { name: "dec", label: "Deception", ability: "cha", subType: "deception", valueId: 16 },
      { name: "his", label: "History", ability: "int", subType: "history", valueId: 7 },
      { name: "ins", label: "Insight", ability: "wis", subType: "insight", valueId: 12 },
      { name: "itm", label: "Intimidation", ability: "cha", subType: "intimidation", valueId: 17 },
      { name: "inv", label: "Investigation", ability: "int", subType: "investigation", valueId: 8 },
      { name: "med", label: "Medicine", ability: "wis", subType: "medicine", valueId: 13 },
      { name: "nat", label: "Nature", ability: "int", subType: "nature", valueId: 9 },
      { name: "prc", label: "Perception", ability: "wis", subType: "perception", valueId: 14 },
      { name: "prf", label: "Performance", ability: "cha", subType: "performance", valueId: 18 },
      { name: "per", label: "Persuasion", ability: "cha", subType: "persuasion", valueId: 19 },
      { name: "rel", label: "Religion", ability: "int", subType: "religion", valueId: 10 },
      { name: "slt", label: "Sleight of Hand", ability: "dex", subType: "sleight-of-hand", valueId: 4 },
      { name: "ste", label: "Stealth", ability: "dex", subType: "stealth", valueId: 5 },
      { name: "sur", label: "Survival", ability: "wis", subType: "survival", valueId: 15 },
    ],
    customSkillProficiencies: [
      // typeId:26
      // value not: 1, half 2, prof: 3, expertise 4
      { value: 1, proficient: 0 },
      { value: 2, proficient: 0.5 },
      { value: 3, proficient: 1 },
      { value: 4, proficient: 2 },
    ],
    alignments: [
      { id: 1, name: "Lawful Good", value: "lg" },
      { id: 2, name: "Neutral Good", value: "ng" },
      { id: 3, name: "Chaotic Good", value: "cg" },
      { id: 4, name: "Lawful Neutral", value: "ln" },
      { id: 5, name: "True Neutral", value: "tn" },
      { id: 6, name: "Chaotic Neutral", value: "cn" },
      { id: 7, name: "Lawful Evil", value: "le" },
      { id: 8, name: "Neutral Evil", value: "ne" },
      { id: 9, name: "Chaotic Evil", value: "ce" },
    ],
    actorSizes: [
      { id: 2, name: "Tiny", value: "tiny" }, // wild guess
      { id: 3, name: "Small", value: "sm" }, // consistent
      { id: 4, name: "Medium", value: "med" }, // consistent
      { id: 5, name: "Large", value: "lg" }, // wild guess
      { id: 6, name: "Huge", value: "huge" }, // wild guess
      { id: 7, name: "Gargantuan", value: "grg" }, // wild guess
    ],
    senses: [
      { id: 1, name: "Blindsight" },
      { id: 2, name: "Darkvision" },
      { id: 3, name: "Tremorsense" },
      { id: 4, name: "Truesight" },
    ],
    speeds: [
      { id: 1, type: "walk", innate: "walking" },
      { id: 2, type: "burrow", innate: "burrowing" },
      { id: 3, type: "climb", innate: "climbing" },
      { id: 4, type: "fly", innate: "flying" },
      { id: 5, type: "swim", innate: "swimming" },
    ],
    languages: [
      { name: "Common", value: "common" },
      { name: "Aarakocra", value: "aarakocra" },
      { name: "Abyssal", value: "abyssal" },
      { name: "Aquan", value: "aquan" },
      { name: "Auran", value: "auran" },
      { name: "Celestial", value: "celestial" },
      { name: "Deep Speech", value: "deep" },
      { name: "Draconic", value: "draconic" },
      { name: "Druidic", value: "druidic" },
      { name: "Dwarvish", value: "dwarvish" },
      { name: "Elvish", value: "elvish" },
      { name: "Giant", value: "giant" },
      { name: "Gith", value: "gith" },
      { name: "Gnomish", value: "gnomish" },
      { name: "Goblin", value: "goblin" },
      { name: "Gnoll", value: "gnoll" },
      { name: "Halfling", value: "halfling" },
      { name: "Ignan", value: "ignan" },
      { name: "Infernal", value: "infernal" },
      { name: "Orc", value: "orc" },
      { name: "Primordial", value: "primordial" },
      { name: "Terran", value: "terran" },
      { name: "Sylvan", value: "sylvan" },
      { name: "Thieves' Cant", value: "cant" },
      { name: "Thievesâ€™ Cant", value: "cant" },
      { name: "Undercommon", value: "undercommon" },
    ],
    armorTypes: [
      { name: "Clothing", value: "clothing" },
      { name: "Light Armor", value: "light" },
      { name: "Medium Armor", value: "medium" },
      { name: "Heavy Armor", value: "heavy" },
      { name: "Magical Bonus", value: "bonus" },
      { name: "Natural Armor", value: "natural" },
      { name: "Shield", value: "shield" },
    ],
    damageTypes: [
      { id: 1, type: 2, kind: "resistance", name: "Bludgeoning", value: "bludgeoning" },
      { id: 2, type: 2, kind: "resistance", name: "Piercing", value: "piercing" },
      { id: 3, type: 2, kind: "resistance", name: "Slashing", value: "slashing" },
      { id: 4, type: 2, kind: "resistance", name: "Lightning", value: "lightning" },
      { id: 5, type: 2, kind: "resistance", name: "Thunder", value: "thunder" },
      { id: 6, type: 2, kind: "resistance", name: "Poison", value: "poison" },
      { id: 7, type: 2, kind: "resistance", name: "Cold", value: "cold" },
      { id: 8, type: 2, kind: "resistance", name: "Radiant", value: "radiant" },
      { id: 9, type: 2, kind: "resistance", name: "Fire", value: "fire" },
      { id: 10, type: 2, kind: "resistance", name: "Necrotic", value: "necrotic" },
      { id: 11, type: 2, kind: "resistance", name: "Acid", value: "acid" },
      { id: 12, type: 2, kind: "resistance", name: "Psychic", value: "psychic" },
      { id: 13, type: 2, kind: "resistance", name: "Physical", value: "bludgeoning-piercing-and-slashing-from-nonmagical-weapons", foundryValue: "physical" },
      { id: 14, type: 2, kind: "resistance", name: "Physical", value: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-silvered", foundryValue: "physical" },
      { id: 15, type: 2, kind: "resistance", name: "Physical", value: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine", foundryValue: "physical" },
      // { id: 16, type: 2, kind: "resistance", name: "Physical", value: "piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine", foundryValue: "physical" },
      { id: 17, type: 2, kind: "immunity", name: "Bludgeoning", value: "bludgeoning" },
      { id: 18, type: 2, kind: "immunity", name: "Piercing", value: "piercing" },
      { id: 19, type: 2, kind: "immunity", name: "Slashing", value: "slashing" },
      { id: 20, type: 2, kind: "immunity", name: "Lightning", value: "lightning" },
      { id: 21, type: 2, kind: "immunity", name: "Thunder", value: "thunder" },
      { id: 22, type: 2, kind: "immunity", name: "Poison", value: "poison" },
      { id: 23, type: 2, kind: "immunity", name: "Cold", value: "cold" },
      { id: 24, type: 2, kind: "immunity", name: "Radiant", value: "radiant" },
      { id: 25, type: 2, kind: "immunity", name: "Fire", value: "fire" },
      { id: 26, type: 2, kind: "immunity", name: "Necrotic", value: "necrotic" },
      { id: 27, type: 2, kind: "immunity", name: "Acid", value: "acid" },
      { id: 28, type: 2, kind: "immunity", name: "Psychic", value: "psychic" },
      { id: 29, type: 2, kind: "immunity", name: "Physical", value: "bludgeoning-piercing-and-slashing-from-nonmagical-weapons", foundryValue: "physical" },
      { id: 30, type: 2, kind: "immunity", name: "Physical", value: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-silvered", foundryValue: "physical" },
      { id: 31, type: 2, kind: "immunity", name: "Physical", value: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine", foundryValue: "physical" },
      // { id: 32, type: 2, kind: "immunity", name: "Physical", value: "piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine", foundryValue: "physical" },
      { id: 33, type: 2, kind: "vulnerability", name: "Bludgeoning", value: "bludgeoning" },
      { id: 34, type: 2, kind: "vulnerability", name: "Piercing", value: "piercing" },
      { id: 35, type: 2, kind: "vulnerability", name: "Slashing", value: "slashing" },
      { id: 36, type: 2, kind: "vulnerability", name: "Lightning", value: "lightning" },
      { id: 37, type: 2, kind: "vulnerability", name: "Thunder", value: "thunder" },
      { id: 38, type: 2, kind: "vulnerability", name: "Poison", value: "poison" },
      { id: 39, type: 2, kind: "vulnerability", name: "Cold", value: "cold" },
      { id: 40, type: 2, kind: "vulnerability", name: "Radiant", value: "radiant" },
      { id: 41, type: 2, kind: "vulnerability", name: "Fire", value: "fire" },
      { id: 42, type: 2, kind: "vulnerability", name: "Necrotic", value: "necrotic" },
      { id: 43, type: 2, kind: "vulnerability", name: "Acid", value: "acid" },
      { id: 44, type: 2, kind: "vulnerability", name: "Psychic", value: "psychic" },

      { id: 47, type: 2, kind: "resistance", name: "Force", value: "force" },
      { id: 48, type: 2, kind: "immunity", name: "Force", value: "force" },
      { id: 49, type: 2, kind: "vulnerability", name: "Force", value: "force" },
      { id: 51, type: 2, kind: "resistance", name: "Ranged attacks" },
      { id: 52, type: 2, kind: "resistance", name: "Damage dealt by traps" },
      { id: 54, type: 2, kind: "resistance", name: "Bludgeoning from non magical attacks" },

      { id: 1, type: 1, kind: "immunity", name: "Blinded", value: "blinded" },
      { id: 2, type: 1, kind: "immunity", name: "Charmed", value: "charmed" },
      { id: 3, type: 1, kind: "immunity", name: "Deafened", value: "deafened" },
      { id: 4, type: 1, kind: "immunity", name: "Exhaustion", value: "exhaustion" },
      { id: 5, type: 1, kind: "immunity", name: "Frightened", value: "frightened" },
      { id: 6, type: 1, kind: "immunity", name: "Grappled", value: "grappled" },
      { id: 7, type: 1, kind: "immunity", name: "Incapacitated", value: "incapacitated" },
      { id: 8, type: 1, kind: "immunity", name: "Invisible", value: "invisible" },
      { id: 9, type: 1, kind: "immunity", name: "Paralyzed", value: "paralyzed" },
      { id: 10, type: 1, kind: "immunity", name: "Petrified", value: "petrified" },
      { id: 11, type: 1, kind: "immunity", name: "Poisoned", value: "poisoned" },
      { id: 12, type: 1, kind: "immunity", name: "Prone", value: "prone" },
      { id: 13, type: 1, kind: "immunity", name: "Restrained", value: "restrained" },
      { id: 14, type: 1, kind: "immunity", name: "Stunned", value: "stunned" },
      { id: 15, type: 1, kind: "immunity", name: "Unconscious", value: "unconscious" },
      // In DDB it is disease, but in FVTT ut is diseased
      { id: 16, type: 1, kind: "immunity", name: "Diseased", value: "disease", foundryValue: "diseased" },
    ],
    proficiencies: [
      // Armor
      { name: "Studded Leather", type: "Armor", subType: "Light Armor" },
      { name: "Scale Mail", type: "Armor", subType: "Medium Armor" },
      { name: "Shield", type: "Armor", subType: "Shield" },
      { name: "Padded", type: "Armor", subType: "Light Armor" },
      { name: "Leather", type: "Armor", subType: "Light Armor" },
      { name: "Hide", type: "Armor", subType: "Medium Armor" },
      { name: "Chain Shirt", type: "Armor", subType: "Medium Armor" },
      { name: "Breastplate", type: "Armor", subType: "Medium Armor" },
      { name: "Half Plate", type: "Armor", subType: "Medium Armor" },
      { name: "Ring Mail", type: "Armor", subType: "Heavy Armor" },
      { name: "Chain Mail", type: "Armor", subType: "Heavy Armor" },
      { name: "Splint", type: "Armor", subType: "Heavy Armor" },
      { name: "Plate", type: "Armor", subType: "Heavy Armor" },
      { name: "Spiked Armor", type: "Armor", subType: "Medium Armor" },

      // Weapons
      { name: "Crossbow, Hand", type: "Weapon", subType: "Martial Weapon" },
      { name: "Glaive", type: "Weapon", subType: "Martial Weapon" },
      { name: "Dagger", type: "Weapon", subType: "Simple Weapon" },
      { name: "Longsword", type: "Weapon", subType: "Martial Weapon" },
      { name: "Club", type: "Weapon", subType: "Simple Weapon" },
      { name: "Greatclub", type: "Weapon", subType: "Simple Weapon" },
      { name: "Handaxe", type: "Weapon", subType: "Simple Weapon" },
      { name: "Javelin", type: "Weapon", subType: "Simple Weapon" },
      { name: "Light Hammer", type: "Weapon", subType: "Simple Weapon" },
      { name: "Mace", type: "Weapon", subType: "Simple Weapon" },
      { name: "Quarterstaff", type: "Weapon", subType: "Simple Weapon" },
      { name: "Sickle", type: "Weapon", subType: "Simple Weapon" },
      { name: "Spear", type: "Weapon", subType: "Simple Weapon" },
      { name: "Crossbow, Light", type: "Weapon", subType: "Simple Weapon" },
      { name: "Dart", type: "Weapon", subType: "Simple Weapon" },
      { name: "Shortbow", type: "Weapon", subType: "Simple Weapon" },
      { name: "Sling", type: "Weapon", subType: "Simple Weapon" },
      { name: "Battleaxe", type: "Weapon", subType: "Martial Weapon" },
      { name: "Flail", type: "Weapon", subType: "Martial Weapon" },
      { name: "Greataxe", type: "Weapon", subType: "Martial Weapon" },
      { name: "Greatsword", type: "Weapon", subType: "Martial Weapon" },
      { name: "Halberd", type: "Weapon", subType: "Martial Weapon" },
      { name: "Lance", type: "Weapon", subType: "Martial Weapon" },
      { name: "Maul", type: "Weapon", subType: "Martial Weapon" },
      { name: "Morningstar", type: "Weapon", subType: "Martial Weapon" },
      { name: "Pike", type: "Weapon", subType: "Martial Weapon" },
      { name: "Rapier", type: "Weapon", subType: "Martial Weapon" },
      { name: "Scimitar", type: "Weapon", subType: "Martial Weapon" },
      { name: "Shortsword", type: "Weapon", subType: "Martial Weapon" },
      { name: "Trident", type: "Weapon", subType: "Martial Weapon" },
      { name: "War Pick", type: "Weapon", subType: "Martial Weapon" },
      { name: "Warhammer", type: "Weapon", subType: "Martial Weapon" },
      { name: "Whip", type: "Weapon", subType: "Martial Weapon" },
      { name: "Blowgun", type: "Weapon", subType: "Martial Weapon" },
      { name: "Crossbow, Heavy", type: "Weapon", subType: "Martial Weapon" },
      { name: "Longbow", type: "Weapon", subType: "Martial Weapon" },
      { name: "Net", type: "Weapon", subType: "Martial Weapon" },
      { name: "Boomerang", type: "Weapon", subType: "Simple Weapon" },
      { name: "Yklwa", type: "Weapon", subType: "Simple Weapon" },
      { name: "Pistol", type: "Weapon", subType: "Martial Weapon" },
      { name: "Musket", type: "Weapon", subType: "Martial Weapon" },
      { name: "Pistol, Automatic", type: "Weapon", subType: "Martial Weapon" },
      { name: "Revolver", type: "Weapon", subType: "Martial Weapon" },
      { name: "Rifle, Hunting", type: "Weapon", subType: "Martial Weapon" },
      { name: "Rifle, Automatic", type: "Weapon", subType: "Martial Weapon" },
      { name: "Shotgun", type: "Weapon", subType: "Martial Weapon" },
      { name: "Laser Pistol", type: "Weapon", subType: "Martial Weapon" },
      { name: "Antimatter Rifle", type: "Weapon", subType: "Martial Weapon" },
      { name: "Laser Rifle", type: "Weapon", subType: "Martial Weapon" },
      { name: "Double-Bladed Scimitar", type: "Weapon", subType: "Martial Weapon" },
      { name: "Revenant Double-Bladed Scimitar", type: "Weapon", subType: "Martial Weapon" },
      { name: "Ammunition", type: "Weapon", subType: "Simple Weapon" },

      // Tools and Instruments and Stuff
      { name: "Carpenter's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex" },
      { name: "Cartographer's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex" },
      { name: "Cobbler's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex" },
      { name: "Cook's Utensils", type: "Tool", subType: "Artisan's Tools", ability: "wis" },
      { name: "Glassblower's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex" },
      { name: "Jeweler's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex" },
      { name: "Leatherworker's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex" },
      { name: "Mason's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex" },
      { name: "Navigator's Tools", type: "Tool", subType: "Artisan's Tools", ability: "int" },
      { name: "Potter's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex" },
      { name: "Smith's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex" },
      { name: "Thieves' Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex" },
      { name: "Tinker's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex" },
      { name: "Weaver's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex" },
      { name: "Woodcarver's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex" },
      { name: "Dice Set", type: "Tool", subType: "Gaming Set", ability: "int" },
      { name: "Dragonchess Set", type: "Tool", subType: "Gaming Set", ability: "int" },
      { name: "Playing Card Set", type: "Tool", subType: "Gaming Set", ability: "int" },
      { name: "Three-Dragon Ante Set", type: "Tool", subType: "Gaming Set", ability: "int" },
      { name: "Disguise Kit", type: "Tool", subType: "Kit", ability: "int" },
      { name: "Forgery Kit", type: "Tool", subType: "Kit", ability: "int" },
      { name: "Herbalism Kit", type: "Tool", subType: "Kit", ability: "int" },
      { name: "Poisoner's Kit", type: "Tool", subType: "Kit", ability: "int" },
      { name: "Bagpipes", type: "Tool", subType: "Musical Instrument", ability: "con" },
      { name: "Birdpipes", type: "Tool", subType: "Musical Instrument", ability: "con" },
      { name: "Drum", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Dulcimer", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Flute", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Glaur", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Hand Drum", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Horn", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Longhorn", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Lute", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Lyre", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Pan Flute", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Shawm", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Songhorn", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Tantan", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Thelarr", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Tocken", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Viol", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Wargong", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Yarting", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Zulkoon", type: "Tool", subType: "Musical Instrument", ability: "dex" },
      { name: "Alchemist's Supplies", type: "Tool", subType: "Supplies", ability: "int" },
      { name: "Brewer's Supplies", type: "Tool", subType: "Supplies", ability: "int" },
      { name: "Calligrapher's Supplies", type: "Tool", subType: "Supplies", ability: "dex" },
      { name: "Painter's Supplies", type: "Tool", subType: "Supplies", ability: "dex" },
    ],
    characterValuesLookup: [
      { name: "pactWeapon", typeId: 28 },
      { name: "hexWarrior", typeId: 29 },
    ],
    // Supported Warlock Pact Weapon options
    pactFeatures: ["Improved Pact Weapon", "Lifedrinker"],
  },
  item: {
    characterValues: [
      { typeId: 8, value: "name" },
      //   { typeId: 9, value: 'notes'},  // note: Not supported by Foundry right now, skipping
      { typeId: 19, value: "price" },
      { typeId: 22, value: "weight" },
    ],
  },
  items: [
    { filterType: "Armor", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/armor.jpg" },
    { filterType: "Potion", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/potion.jpg" },
    { filterType: "Ring", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/ring.jpg" },
    { filterType: "Rod", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/rod.jpg" },
    { filterType: "Scroll", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/scroll.jpg" },
    { filterType: "Staff", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/staff.jpg" },
    { filterType: "Wand", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/wand.jpg" },
    { filterType: "Weapon", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/weapon.jpg" },
    { filterType: "Wondrous item", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/wondrousitem.jpg" },
  ],
  genericItemIcons: [
    { name: "Adventuring Gear", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/adventuring-gear.jpg" },
    { name: "Tool", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/tool.jpg" },
    { name: "Gemstone", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/gemstone.jpg" },
    { name: "Holy Symbol", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/holy-symbol.jpg" },
    { name: "Weapon", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/weapon.jpg" },
    { name: "Arcane Focus", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/arcane-focus.jpg" },
    { name: "Druidic Focus", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/druidic-focus.jpg" },
    { name: "Ammunition", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/ammunition.jpg" },
    { name: "Poison", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/poison.jpg" },
    { name: "Mount", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/mount.jpg" },
    { name: "Potion", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/potion.jpg" },
    { name: "Equipment Pack", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/pack.jpg" },
    // Vehicle (Land)/(Water)
    { name: "Vehicle", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/vehicle.jpg" },
  ],
  equipment: {
    armorType: [
      { name: "Light Armor", id: 1, value: "light" },
      { name: "Medium Armor", id: 2, value: "medium" },
      { name: "Heavy Armor", id: 3, value: "heavy" },
      { name: "Shield", id: 4, value: "shield" },
      { name: "Unarmored", id: 0, value: null },
      { name: "Unarmored Defense", id: -1, value: null },
      { name: "Natural Armor", id: -2, value: "natural" },
      { name: "Magical Bonus", id: -3, value: "bonus" },
      { name: "Clothing", id: -4, value: "clothing" },
    ],
  },
  weapon: {
    weaponRange: [
      { attackType: 1, value: "M" },
      { attackType: 2, value: "R" },
      { attackType: null, value: "R" },
    ],
    weaponType: [
      { categoryId: 1, value: "simple" },
      { categoryId: 2, value: "martial" },
      { categoryId: 3, value: "martial" }, // this is not 100% correct. a martialF for "Martial Firearms" would be better
      { categoryId: 0, value: "simple" }, // this is totally incorrect, this is of type ammunition
    ],
    properties: [
      { name: "Ammunition", value: "amm" },
      { name: "Ammunition (Firearms)", value: "fir" },
      { name: "Finesse", value: "fin" },
      { name: "Heavy", value: "hvy" },
      { name: "Light", value: "lgt" },
      { name: "Loading", value: "lod" },
      { name: "Range", value: "fir" },
      { name: "Reach", value: "rch" },
      { name: "Reload", value: "rel" },
      { name: "Special", value: "spc" },
      { name: "Thrown", value: "thr" },
      { name: "Two-Handed", value: "two" },
      { name: "Versatile", value: "ver" },
      { name: "Returning", value: "ret" },
      { name: "Focus", value: "foc" },
      { name: "Adamantine", value: "ada" },
      { name: "Magical", value: "mgc" },
      { name: "Silvered", value: "sil" },
    ],
  },
  actions: {
    activationTypes: [
      { id: 0, value: "none" },
      { id: 1, value: "action" },
      { id: 2, value: "action" },
      { id: 3, value: "bonus" },
      { id: 4, value: "reaction" },
      { id: 5, value: "action" },
      { id: 6, value: "minute" },
      { id: 7, value: "hour" },
      { id: 8, value: "special" },
    ],
    attackTypes: [
      //  natural improv
      // { attackSubtype: 1, value: "" },
      { attackSubtype: 2, value: "natural" },
      { attackSubtype: 3, value: "simpleM" }, // unarmed
    ],
    damageType: [
      { name: "bludgeoning", id: 1 },
      { name: "piercing", id: 2 },
      { name: "slashing", id: 3 },
      { name: "necrotic", id: 4 },
      { name: "acid", id: 5 },
      { name: "cold", id: 6 },
      { name: "fire", id: 7 },
      { name: "lightning", id: 8 },
      { name: "thunder", id: 9 },
      { name: "poison", id: 10 },
      { name: "psychic", id: 11 },
      { name: "radiant", id: 12 },
      { name: "force", id: 13 },
      { name: null, id: null },
    ],
    aoeType: [
      { id: 1, value: "cone" },
      { id: 2, value: "" },
      { id: 3, value: "" },
      { id: 4, value: "line" },
      // presumably others here too! add when found
    ],
  },
  spell: {
    schools: [
      { id: "abj", name: "abjuration", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/abjuration.png" },
      { id: "con", name: "conjuration", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/conjuration.png" },
      { id: "div", name: "divination", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/divination.png" },
      { id: "enc", name: "enchantment", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/enchantment.png" },
      { id: "evo", name: "evocation", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/evocation.png" },
      { id: "ill", name: "illusion", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/illusion.png" },
      { id: "nec", name: "necromancy", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/necromancy.png" },
      { id: "trs", name: "transmutation", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/transmutation.png" },
    ],
    progression: [
      { name: "Artificer", value: "artificer" },
      { name: "Artificer (UA)", value: "artificer" },
      { name: "Bard", value: "full" },
      { name: "Barbarian", value: "none" },
      { name: "Blood Hunter", value: "pact" },
      { name: "Blood Hunter (archived)", value: "pact" },
      { name: "Cleric", value: "full" },
      { name: "Druid", value: "full" },
      { name: "Fighter", value: "third" },
      { name: "Hunter", value: "half" },
      { name: "Paladin", value: "half" },
      { name: "Ranger", value: "half" },
      { name: "Rogue", value: "third" },
      { name: "Sorcerer", value: "full" },
      { name: "Warlock", value: "pact" },
      { name: "Wizard", value: "full" },
      { name: "Monk", value: "none" },
    ],
    preparationModes: [
      { name: "Artificer", value: "prepared" },
      { name: "Artificer (UA)", value: "prepared" },
      { name: "Bard", value: "always" },
      { name: "Blood Hunter", value: "pact" },
      { name: "Blood Hunter (archived)", value: "pact" },
      { name: "Cleric", value: "prepared" },
      { name: "Druid", value: "prepared" },
      { name: "Fighter", value: "always" },
      { name: "Hunter", value: "always" },
      { name: "Paladin", value: "prepared" },
      { name: "Ranger", value: "always" },
      { name: "Rogue", value: "always" },
      { name: "Sorcerer", value: "always" },
      { name: "Warlock", value: "pact" },
      { name: "Wizard", value: "prepared" },
      { name: "Monk", value: "always" },
    ],
    activationTypes: [
      { activationType: 0, value: "none" },
      { activationType: 1, value: "action" },
      { activationType: 2, value: "action" },
      { activationType: 3, value: "bonus" },
      { activationType: 4, value: "reaction" },
      { activationType: 5, value: "action" },
      { activationType: 6, value: "minute" },
      { activationType: 7, value: "hour" },
      { activationType: 8, value: "special" },
    ],
  },
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DICTIONARY);


/***/ }),

/***/ 547:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": () => (/* binding */ copyInbuiltIcons)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(555);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(259);



var iconMap = {};

// const BASE_PATH = ROUTE_PREFIX ? `/${ROUTE_PREFIX}` : "";

const TYPE_MAP = {
  items: "items",
  weapons: "items",
  weapon: "items",
  item: "items",
  equipment: "items",
  consumable: "items",
  tool: "items",
  loot: "items",
  backpack: "items",
  inventory: "items",
  spells: "spells",
  spell: "spells",
  feats: "feats",
  feat: "feats",
  classes: "classes",
  class: "classes",
  monster: "monster",
};

const FILE_MAP = {
  items: ["items.json", "class-features.json"],
  spells: ["spells.json"],
  feats: ["feats.json", "class-features.json", "races.json", "general.json"],
  classes: ["classes.json"],
  monster: ["monster-features.json"],
};

async function loadDataFile(fileName) {
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Getting icon mapping for ${fileName}`);
  const fileExists = await _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.fileExists */ .Z.fileExists("[data] modules/ddb-importer/data", fileName);

  let data = [];
  if (fileExists) {
    const url = await _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.getFileUrl */ .Z.getFileUrl("[data] modules/ddb-importer/data", fileName);
    const response = await fetch(url, { method: "GET" });
    // eslint-disable-next-line require-atomic-updates
    data = await response.json();
  }
  return data;
}

async function loadIconMap(type) {
  // check to see if dictionary is loaded
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Loading Inbuilt Icon Map for ${type}`);
  if (iconMap[type]) return;

  let data = [];
  for (const fileName of FILE_MAP[type]) {
    // eslint-disable-next-line no-await-in-loop
    const dataLoad = await loadDataFile(fileName);
    data = data.concat(dataLoad);
  }

  iconMap[type] = data;
  // console.warn(iconMap);
}

function looseMatch(item, typeValue) {
  const originalName = item.flags?.ddbimporter?.originalName;
  if (originalName) {
    const originalMatch = iconMap[typeValue].find((entry) => entry.name === originalName);
    if (originalMatch) return originalMatch.path;
  }

  if (item.name.includes(":")) {
    const nameArray = item.name.split(":");
    const postMatch = iconMap[typeValue].find((entry) => entry.name === nameArray[1].trim());
    if (postMatch) return postMatch.path;
    const subMatch = iconMap[typeValue].find((entry) => entry.name === nameArray[0].trim());
    if (subMatch) return subMatch.path;
  }

  const startsMatchEntry = iconMap[typeValue].find((entry) => item.name.split(":")[0].trim().startsWith(entry.name.split(":")[0].trim()));
  if (startsMatchEntry) return startsMatchEntry.path;
  const startsMatchItem = iconMap[typeValue].find((entry) => entry.name.split(":")[0].trim().startsWith(item.name.split(":")[0].trim()));
  if (startsMatchItem) return startsMatchItem.path;

  return null;
}

function getIconPath(item, type, monsterName) {
  // check to see if we are able to load a dic for that type
  const typeValue = TYPE_MAP[type];
  if (!typeValue || !iconMap[typeValue]) return null;

  const iconMatch = iconMap[typeValue].find((entry) => {
    if (type === "monster") {
      return entry.name === item.name.split("(")[0].trim() && entry.monster == monsterName;
    }
    return entry.name === item.name;
  });
  if (iconMatch) {
    return iconMatch.path;
  } else {
    return looseMatch(item, typeValue);
  }
}


async function loadIconMaps(types) {
  let promises = [];

  const mapTypes = types
    .filter((type) => TYPE_MAP[type])
    .map((type) => TYPE_MAP[type]).filter((type, i, ar) => ar.indexOf(type) === i);

  mapTypes.forEach((type) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Loading ${type}`);
    promises.push(loadIconMap(type));
  });

  return Promise.all(promises);
}

async function copyInbuiltIcons(items, monster = false, monsterName = "") {
  // eslint-disable-next-line require-atomic-updates

  // get unique array of item types to be matching
  const itemTypes = items.map((item) => item.type).filter((item, i, ar) => ar.indexOf(item) === i);

  if (monster) itemTypes.push("monster");
  await loadIconMaps(itemTypes);

  return new Promise((resolve) => {
    const iconItems = items.map((item) => {
      // logger.debug(`Inbuilt icon match started for ${item.name} [${item.type}]`);
      // if we have a monster lets check the monster dict first
      if (monster) {
        const monsterPath = getIconPath(item, "monster", monsterName);
        if (monsterPath) {
          item.img = monsterPath;
          return item;
        }
      }
      const pathMatched = getIconPath(item, item.type);
      if (pathMatched) {
        item.img = pathMatched;
      }
      return item;
    });
    resolve(iconItems);
  });
}


/***/ }),

/***/ 222:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "B": () => (/* binding */ DirectoryPicker)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(259);
/**
 * Game Settings: Directory
 */



class DirectoryPicker extends FilePicker {
  constructor(options = {}) {
    super(options);
  }

  _onSubmit(event) {
    event.preventDefault();
    const path = event.target.target.value;
    const activeSource = this.activeSource;
    const bucket = event.target.bucket ? event.target.bucket.value : null;
    this.field.value = DirectoryPicker.format({
      activeSource,
      bucket,
      path,
    });
    this.close();
  }

  static async uploadToPath(path, file) {
    const options = DirectoryPicker.parse(path);
    return FilePicker.upload(options.activeSource, options.current, file, { bucket: options.bucket });
  }

  // returns the type "Directory" for rendering the SettingsConfig
  static Directory(val) {
    return val;
  }

  // formats the data into a string for saving it as a GameSetting
  static format(value) {
    return value.bucket !== null
      ? `[${value.activeSource}:${value.bucket}] ${value.path}`
      : `[${value.activeSource}] ${value.path}`;
  }

  // parses the string back to something the FilePicker can understand as an option
  static parse(str) {
    let matches = str.match(/\[(.+)\]\s*(.+)/);
    if (matches) {
      let source = matches[1];
      const current = matches[2].trim();
      const [s3, bucket] = source.split(":");
      if (bucket !== undefined) {
        return {
          activeSource: s3,
          bucket: bucket,
          current: current,
        };
      } else {
        return {
          activeSource: s3,
          bucket: null,
          current: current,
        };
      }
    }
    // failsave, try it at least
    return {
      activeSource: "data",
      bucket: null,
      current: str,
    };
  }

  // Adds a FilePicker-Simulator-Button next to the input fields
  static processHtml(html) {
    $(html)
      .find(`input[data-dtype="Directory"]`)
      .each((index, element) => {
        // disable the input field raw editing
        $(element).prop("readonly", true);

        // if there is no button next to this input element yet, we add it
        if (!$(element).next().length) {
          let picker = new DirectoryPicker({
            field: $(element)[0],
            ...DirectoryPicker.parse($(element).val()),
          });
          let pickerButton = $(
            '<button type="button" class="file-picker" data-type="imagevideo" data-target="img" title="Pick directory"><i class="fas fa-file-import fa-fw"></i></button>'
          );
          pickerButton.on("click", () => {
            picker.render(true);
          });
          $(element).parent().append(pickerButton);
        }
      });
  }

  /** @override */
  activateListeners(html) {
    super.activateListeners(html);

    // remove unnecessary elements
    $(html).find("ol.files-list").remove();
    $(html).find("footer div").remove();
    $(html).find("footer button").text("Select Directory");
  }

  static async forgeCreateDirectory(target) {
    if (!target) return;
    const response = await ForgeAPI.call('assets/new-folder', { path: target });
    if (!response || response.error) {
      throw new Error(response ? response.error : "Unknown error while creating directory.");
    }
  }

  /**
   * @param  {string} source
   * @param  {string} target
   * @param  {object} options={}
   */
  static async createDirectory(source, target, options = {}) {
    if (!target) {
      throw new Error("No directory name provided");
    }
    if (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge) {
      return DirectoryPicker.forgeCreateDirectory(target);
    }
    return FilePicker.createDirectory(source, target, options);
  }

  /**
   * Verifies server path exists, and if it doesn't creates it.
   *
   * @param  {object} parsedPath - output from DirectoryPicker,parse
   * @param  {string} targetPath - if set will check this path, else check parsedPath.current
   * @returns {boolean} - true if verfied, false if unable to create/verify
   */
  static async verifyPath(parsedPath, targetPath = null) {
    try {
      const paths = (targetPath) ? targetPath.split("/") : parsedPath.current.split("/");
      let currentSource = paths[0];

      for (let i = 0; i < paths.length; i += 1) {
        try {
          if (currentSource !== paths[i]) {
            currentSource = `${currentSource}/${paths[i]}`;
          }
          // eslint-disable-next-line no-await-in-loop
          await DirectoryPicker.createDirectory(parsedPath.activeSource, `${currentSource}`, { bucket: parsedPath.bucket });

        } catch (err) {
          if (!err.startsWith("EEXIST") && !err.startsWith("The S3 key")) _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.error */ .Z.error(`Error trying to verify path [${parsedPath.activeSource}], ${parsedPath.current}`, err);
        }
      }
    } catch (err) {
      return false;
    }

    return true;
  }
}

// this s hooked in, we don't use all the data, so lets stop eslint complaining
// eslint-disable-next-line no-unused-vars
Hooks.on("renderSettingsConfig", (app, html, user) => {
  DirectoryPicker.processHtml(html);
});


/***/ }),

/***/ 259:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const logger = {
    _showMessage: (logLevel, data) => {
        if (!logLevel || !data || typeof (logLevel) !== 'string') {
            return false;
        }

        const setting = game.settings.get("ddb-importer", "log-level");
        const logLevels = ["DEBUG", "INFO", "WARN", "ERR", "OFF"];
        const logLevelIndex = logLevels.indexOf(logLevel.toUpperCase());
        if (setting == "OFF" ||
            logLevelIndex === -1 ||
            logLevelIndex < logLevels.indexOf(setting)) {
            return false;
        }
        return true;
    },
    log: (logLevel, ...data) => {
        if (!logger._showMessage) {
            return;
        }

        logLevel = logLevel.toUpperCase();

        const LOG_PREFIX = "DDB Importer";
        let msg = "No logging message provided.  Please see the payload for more information.";
        let payload = data.slice();
        if (data[0] && typeof (data[0] == 'string')) {
            msg = data[0];
            if (data.length > 1) {
                payload = data.slice(1);
            } else {
                payload = null;
            }
        }
        msg = `${LOG_PREFIX} | ${logLevel} > ${msg}`;
        switch (logLevel) {
            case "DEBUG":
                if (payload) {
                    console.debug(msg, ...payload);// eslint-disable-line no-console
                } else {
                    console.debug(msg);// eslint-disable-line no-console
                }
                break;
            case "INFO":
                if (payload) {
                    console.info(msg, ...payload);// eslint-disable-line no-console
                } else {
                    console.info(msg);// eslint-disable-line no-console
                }
                break;
            case "WARN":
                if (payload) {
                    console.warn(msg, ...payload);// eslint-disable-line no-console
                } else {
                    console.warn(msg);// eslint-disable-line no-console
                }
                break;
            case "ERR":
                if (payload) {
                    console.error(msg, ...payload);// eslint-disable-line no-console
                } else {
                    console.error(msg);// eslint-disable-line no-console
                }
                break;
            default: break;
        }
    },

    debug: (...data) => {
        logger.log("DEBUG", ...data);
    },

    info: (...data) => {
        logger.log("INFO", ...data);
    },

    warn: (...data) => {
        logger.log("WARN", ...data);
    },

    error: (...data) => {
        logger.log("ERR", ...data);
    },

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (logger);


/***/ }),

/***/ 269:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FT": () => (/* binding */ createCompendiumFolderStructure),
/* harmony export */   "l0": () => (/* binding */ addToCompendiumFolder),
/* harmony export */   "W3": () => (/* binding */ migrateExistingCompendium)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(555);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(259);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _import_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(193);
/* harmony import */ var _ddbConfig_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31);






var compendiumFolderTypeMonster;
var compendiumFolderTypeSpell;
var compendiumFolderTypeItem;

var rootItemFolders = {};
var equipmentFolders = {};
var weaponFolders = {};
var trinketFolders = {};
var consumableFolders = {};
var lootFolders = {};
var backpackFolders = {};

const spellLevelFolderNames = [
  "0th Level (Cantrip)",
  "1st Level",
  "2nd Level",
  "3rd Level",
  "4th Level",
  "5th Level",
  "6th Level",
  "7th Level",
  "8th Level",
  "9th Level",
];

const itemRarityNames = [
  "Common",
  "Uncommon",
  "Rare",
  "Very Rare",
  "Legendary",
  "Artifact",
  "Varies",
  "Unknown",
];

const rootItemFolderNames = {
  equipment: "Equipment",
  tool: "Tools",
  loot: "Loot",
  weapon: "Weapon",
  backpack: "Backpack",
  consumable: "Consumable",
};

const equipmentFolderNames = {
  heavy: "Heavy Armor",
  medium: "Medium Armor",
  light: "Light Armor",
  trinket: "Trinket",
  shield: "Shield",
};
const weaponFolderNames = {
  simpleM: "Simple Melee",
  simpleR: "Simple Ranged",
  martialM: "Martial Melee",
  martialR: "Martial Ranged",
};
const trinketFolderNames = ["Wand", "Wondrous item", "Ring", "Rod"];
const consumableFolderNames = ["Ammunition", "Potion", "Scroll", "Poison", "Adventuring Gear"];
const lootFolderNames = [
  "Adventuring Gear",
  "Vehicle",
  "Gemstone",
  "Mount",
  "Arcane Focus",
  "Holy Symbol",
  "Druidic Focus",
];
const backpackFolderNames = ["Equipment Pack", "Adventuring Gear"];

async function createCompendiumFolder(packName, folderName, color = "#6f0006") {
  const existingFolder = game.customFolders.fic.folders.find((f) => f.packCode === packName && f.name == folderName);
  return new Promise((resolve) => {
    if (!existingFolder) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Creating compendium folder ${folderName}`);
      // createFolderAtRoot(packCode,name,color,fontColor)
      resolve(game.CF.FICFolderAPI.createFolderAtRoot(packName, folderName, color));
    } else {
      resolve(existingFolder);
    }
  });
}

async function createCompendiumFolderWithParent(packName, folderName, parentFolder, color = "#6f0006") {
  const existingFolder = game.customFolders.fic.folders.find(
    (f) => f.packCode === packName && f.name == folderName && f.parentId == parentFolder.id
  );
  return new Promise((resolve) => {
    if (!existingFolder) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Creating compendium folder ${folderName} in ${parentFolder.name}`);
      resolve(game.CF.FICFolderAPI.createFolderWithParent(parentFolder, folderName, color));
    } else {
      resolve(existingFolder);
    }
  });
}

// assume type is monster compendium
async function createCreatureTypeCompendiumFolders(packName) {
  return new Promise((resolve) => {
    let promises = [];
    _ddbConfig_js__WEBPACK_IMPORTED_MODULE_4__/* .DDB_CONFIG.monsterTypes.forEach */ .U.monsterTypes.forEach(async (monsterType) => {
      const folder = await createCompendiumFolder(packName, monsterType.name, "#6f0006");
      promises.push(folder);
    });
    resolve(promises);
  });
}

// challenge rating
async function createChallengeRatingCompendiumFolders(packName) {
  return new Promise((resolve) => {
    let promises = [];
    _ddbConfig_js__WEBPACK_IMPORTED_MODULE_4__/* .DDB_CONFIG.challengeRatings.forEach */ .U.challengeRatings.forEach(async (cr) => {
      const paddedCR = String(cr.value).padStart(2, "0");
      const folder = await createCompendiumFolder(packName, `CR ${paddedCR}`, "#6f0006");
      promises.push(folder);
    });
    resolve(promises);
  });
}

// alphabetical
async function createAlphabeticalCompendiumFolders(packName) {
  return new Promise((resolve) => {
    let promises = [];
    for (let i = 9; ++i < 36;) {
      const folderName = i.toString(36).toUpperCase();
      // eslint-disable-next-line no-await-in-loop
      createCompendiumFolder(packName, folderName, "#6f0006").then((folder) => {
        promises.push(folder);
      });
    }
    resolve(promises);
  });
}

// spell level
async function createSpellLevelCompendiumFolders(packName) {
  return new Promise((resolve) => {
    let promises = [];
    spellLevelFolderNames.forEach(async (levelName) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Creating folder '${levelName}'`);
      const newFolder = await createCompendiumFolder(packName, levelName);
      promises.push(newFolder);
    });
    resolve(promises);
  });
}

// spell school
async function createSpellSchoolCompendiumFolders(packName) {
  return new Promise((resolve) => {
    let promises = [];
    _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* .default.spell.schools.forEach */ .Z.spell.schools.forEach(async (school) => {
      const schoolName = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.capitalize */ .Z.capitalize(school.name);
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Creating folder '${schoolName}'`);
      const newFolder = await createCompendiumFolder(packName, schoolName);
      promises.push(newFolder);
    });
    resolve(promises);
  });
}

// item rarity folder
async function createItemRarityCompendiumFolders(packName) {
  return new Promise((resolve) => {
    let promises = [];
    itemRarityNames.forEach(async (rarityName) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Creating folder '${rarityName}'`);
      const newFolder = await createCompendiumFolder(packName, rarityName);
      promises.push(newFolder);
    });
    resolve(promises);
  });
}

// item type folder
async function createItemTypeCompendiumFolders(packName) {
  let promises = [];

  for (const [key, value] of Object.entries(rootItemFolderNames)) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Creating root folder '${value}' with key '${key}'`);
    // eslint-disable-next-line no-await-in-loop
    const folder = await createCompendiumFolder(packName, value);
    rootItemFolders[key] = folder;
    promises.push(folder);
  }

  for (const [key, value] of Object.entries(equipmentFolderNames)) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Creating Equipment folder '${value}' with key '${key}'`);
    // eslint-disable-next-line no-await-in-loop
    const folder = await createCompendiumFolderWithParent(packName, value, rootItemFolders["equipment"], "#222222");
    equipmentFolders[key] = folder;
    promises.push(folder);
  }

  for (const [key, value] of Object.entries(weaponFolderNames)) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Creating Weapon folder '${value}' with key '${key}'`);
    // eslint-disable-next-line no-await-in-loop
    const folder = await createCompendiumFolderWithParent(packName, value, rootItemFolders["weapon"], "#222222");
    weaponFolders[key] = folder;
    promises.push(folder);
  }

  trinketFolderNames.forEach((folderName) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Creating Equipment\\Trinket folder '${folderName}'`);
    createCompendiumFolderWithParent(packName, folderName, equipmentFolders["trinket"], "#444444").then((folder) => {
      trinketFolders[folderName] = folder;
      promises.push(folder);
    });
  });

  consumableFolderNames.forEach((folderName) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Creating Consumable folder '${folderName}'`);
    createCompendiumFolderWithParent(packName, folderName, rootItemFolders["consumable"], "#222222").then((folder) => {
      consumableFolders[folderName] = folder;
      promises.push(folder);
    });
  });

  lootFolderNames.forEach((folderName) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Creating Loot folder '${folderName}'`);
    createCompendiumFolderWithParent(packName, folderName, rootItemFolders["loot"], "#222222").then((folder) => {
      lootFolders[folderName] = folder;
      promises.push(folder);
    });
  });

  backpackFolderNames.forEach((folderName) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Creating Backpack folder '${folderName}'`);
    createCompendiumFolderWithParent(packName, folderName, rootItemFolders["backpack"], "#222222").then((folder) => {
      backpackFolders[folderName] = folder;
      promises.push(folder);
    });
  });

  return new Promise((resolve) => {
    resolve(promises);
  });
}

// create compendium folder structure
async function createCompendiumFolderStructure(type) {
  const compendiumFoldersInstalled = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.isModuleInstalledAndActive */ .Z.isModuleInstalledAndActive("compendium-folders");

  if (compendiumFoldersInstalled) {
    compendiumFolderTypeMonster = game.settings.get("ddb-importer", "munching-selection-compendium-folders-monster");
    compendiumFolderTypeSpell = game.settings.get("ddb-importer", "munching-selection-compendium-folders-spell");
    compendiumFolderTypeItem = game.settings.get("ddb-importer", "munching-selection-compendium-folders-item");
    // generate compendium folders for type
    const packName = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .getCompendiumLabel */ .Eb)(type);
    await game.CF.FICFolderAPI.loadFolders(packName);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Creating Compendium folder structure for ${type}`);

    switch (type) {
      case "monsters":
      case "npc":
      case "monster": {
        switch (compendiumFolderTypeMonster) {
          case "TYPE": {
            await createCreatureTypeCompendiumFolders(packName);
            break;
          }
          case "ALPHA": {
            await createAlphabeticalCompendiumFolders(packName);
            break;
          }
          case "CR": {
            await createChallengeRatingCompendiumFolders(packName);
            break;
          }
          // no default
        }
        break;
      }
      case "spell":
      case "spells": {
        switch (compendiumFolderTypeSpell) {
          case "SCHOOL":
            await createSpellSchoolCompendiumFolders(packName);
            break;
          case "LEVEL":
            await createSpellLevelCompendiumFolders(packName);
            break;
          // no default
        }
        break;
      }
      case "inventory":
      case "item":
      case "items": {
        rootItemFolders = {};
        equipmentFolders = {};
        weaponFolders = {};
        trinketFolders = {};
        consumableFolders = {};
        lootFolders = {};
        backpackFolders = {};
        switch (compendiumFolderTypeItem) {
          case "TYPE":
            await createItemTypeCompendiumFolders(packName);
            break;
          case "RARITY":
            await createItemRarityCompendiumFolders(packName);
            break;
          // no default
        }
        break;
      }
      // no default
    }
    // reload folders
    return game.CF.FICFolderAPI.loadFolders(packName);
  }

  return undefined;
}

function getItemCompendiumFolderName(document) {
  let name;
  switch (compendiumFolderTypeItem) {
    case "RARITY": {
      const rarity = document.data.data.rarity;
      if (rarity && rarity != "") {
        name = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.capitalize */ .Z.capitalize(rarity).replace("rare", "Rare").replace("Unknown rarity", "Unknown");
      } else {
        name = "Unknown";
      }
      break;
    }
    case "TYPE": {
      switch (document.data.type) {
        case "equipment": {
          switch (document.data.data?.armor?.type) {
            case "trinket": {
              const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;
              if (ddbType) {
                name = trinketFolders[ddbType].name;
              }
              break;
            }
            default: {
              name = equipmentFolders[document.data.data.armor.type].name;
              break;
            }
          }
          break;
        }
        case "weapon": {
          name = weaponFolders[document.data.data.weaponType].name;
          break;
        }
        case "consumable": {
          const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;
          if (ddbType) {
            name = consumableFolders[ddbType].name;
          }
          break;
        }
        case "loot": {
          const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;
          if (ddbType) {
            name = lootFolders[ddbType].name;
          }
          break;
        }
        case "backpack": {
          const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;
          if (ddbType) {
            name = backpackFolders[ddbType].name;
          }
          break;
        }
        default: {
          name = rootItemFolders[document.data.type].name;
          break;
        }
      }
      break;
    }
    // no default
  }
  return name;
}

function getCompendiumFolderName(type, document) {
  let name;
  switch (type) {
    case "monsters":
    case "npc":
    case "monster": {
      switch (compendiumFolderTypeMonster) {
        case "TYPE": {
          const creatureType = document.data.data?.details?.type?.value
            ? document.data.data?.details?.type?.value
            : "Unknown";
          const ddbType = _ddbConfig_js__WEBPACK_IMPORTED_MODULE_4__/* .DDB_CONFIG.monsterTypes.find */ .U.monsterTypes.find((c) => creatureType.toLowerCase() == c.name.toLowerCase());
          if (ddbType) name = ddbType.name;
          break;
        }
        case "ALPHA": {
          name = document.name
            .replace(/[^a-z]/gi, "")
            .charAt(0)
            .toUpperCase();
          break;
        }
        case "CR": {
          if (document.data.data.details.cr !== undefined || document.data.data.details.cr !== "") {
            const paddedCR = String(document.data.data.details.cr).padStart(2, "0");
            name = `CR ${paddedCR}`;
          }
        }
        // no default
      }
      break;
    }
    case "spell":
    case "spells": {
      switch (compendiumFolderTypeSpell) {
        case "SCHOOL": {
          const school = document.data.data?.school;
          if (school) {
            name = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.capitalize */ .Z.capitalize(_dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* .default.spell.schools.find */ .Z.spell.schools.find((sch) => school == sch.id).name);
          }
          break;
        }
        case "LEVEL": {
          const levelFolder = spellLevelFolderNames[document.data.data?.level];
          if (levelFolder) {
            name = levelFolder;
          }
          break;
        }
        // no default
      }
      break;
    }
    case "inventory":
    case "item":
    case "items": {
      name = getItemCompendiumFolderName(document);
    }
    // no default
  }
  return name;
}

// function addItemToCompendiumFolder(packName, document, folders) {
//   const folderName = getCompendiumFolderName("item", document);
//   if (folderName) {
//     switch (compendiumFolderTypeItems) {
//       case "TYPE": {
//         switch (document.data.type) {
//           case "equipment": {
//             switch (document.data.data?.armor?.type) {
//               case "trinket": {
//                 const folder = trinketFolders[document.data.flags?.ddbimporter?.dndbeyond?.type];
//                 const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;
//                 if (ddbType) {
//                   name = trinketFolders[ddbType].name;
//                   logger.info(`Moving ${type} ${document.name} to folder ${folder.name}`);
//                   await game.CF.FICFolderAPI.moveDocumentToFolder(packName, document, folder);
//                 }
//                 break;
//               }
//               default: {
//                 name = equipmentFolders[document.data.armor.type].name;
//                 break;
//               }
//             }
//             break;
//           }
//           case "weapon": {
//             name = weaponFolders[document.data.weaponType].name;
//             break;
//           }
//           case "consumable": {
//             const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;
//             if (ddbType) {
//               name = consumableFolders[ddbType].name;
//             }
//             break;
//           }
//           case "loot": {
//             const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;
//             if (ddbType) {
//               name = lootFolders[ddbType].name;
//             }
//             break;
//           }
//           case "backpack": {
//             const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;
//             if (ddbType) {
//               name = backpackFolders[ddbType].name;
//             }
//             break;
//           }
//           default: {
//             name = rootItemFolders[document.data.type].name;
//             break;
//           }
//         }
//         break;
//       }
//       // no default
//     }
//   } else {
//     logger.error(`Unable to find folder "${folderName}" in "${packName}" for Item`);
//   }
// }

async function addToCompendiumFolder(type, document, folders) {
  const compendiumFoldersInstalled = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.isModuleInstalledAndActive */ .Z.isModuleInstalledAndActive("compendium-folders");

  if (compendiumFoldersInstalled && (folders || game.customFolders?.fic?.folders)) {
    if (!folders) folders = game.customFolders.fic.folders;
    const packName = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .getCompendiumLabel */ .Eb)(type);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Checking ${document.name} in ${packName}`);

    switch (type) {
      case "inventory":
      case "items":
      case "item":
      case "spells":
      case "spell":
      case "monsters":
      case "npc":
      case "monster": {
        const folderName = getCompendiumFolderName(type, document);
        if (folderName) {
          const folder = folders.find((f) => f.packCode === packName && f.name == folderName);
          if (document?.data?.flags?.cf?.id) setProperty(document, "data.flags.cf.id", undefined);
          if (folder) {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Moving ${type} ${document.name} to folder ${folder.name}`);
            await game.CF.FICFolderAPI.moveDocumentToFolder(packName, document, folder);
          } else {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.error */ .Z.error(`Unable to find folder "${folderName}" in "${packName}" for ${type}`);
          }
        }
      }
      // no default
    }
  }
}

// create compendium folders for existing things
async function migrateExistingCompendium(type) {
  const compendiumFoldersInstalled = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.isModuleInstalledAndActive */ .Z.isModuleInstalledAndActive("compendium-folders");

  if (!compendiumFoldersInstalled) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.warn */ .Z.warn("Compendium Folders module is not installed");
    return new Promise((resolve) => {
      resolve(false);
    });
  }
  // loop through all existing monts/etc and generate a folder and move documents to it
  const packName = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .getCompendiumLabel */ .Eb)(type);

  if (game.CF.cleanupCompendium) {
    await game.CF.cleanupCompendium(packName);
  }

  const folders = await createCompendiumFolderStructure(type);

  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Compendium Folders", folders);

  const compendium = game.packs.get(packName);
  if (!compendium) return undefined;
  let indexFields = ["name"];
  switch (type) {
    case "spells":
    case "spell": {
      indexFields = ["name", "flags.cf", "data.level"];
      break;
    }
    case "inventory":
    case "items":
    case "item": {
      indexFields = [
        "name",
        "type",
        "flags.cf",
        "flags.ddbimporter.dndbeyond.type",
        "data.armor.type",
        "data.weaponType",
        "data.rarity"
      ];
      break;
    }
    // no default
  }

  const index = await compendium.getIndex({ fields: indexFields });

  switch (type) {
    case "inventory":
    case "items":
    case "item":
    case "spells":
    case "spell":
    case "monsters":
    case "npc":
    case "monster": {
      // loop through all existing monsters and move them to their type
      await index
        .filter((i) => i.name !== game.CF.TEMP_ENTITY_NAME)
        .forEach(async (i) => {
          const existing = await compendium.getDocument(i._id);
          await addToCompendiumFolder(type, existing, folders);
        });
      break;
    }
    // no default
  }

  const newFolders = await game.CF.FICFolderAPI.loadFolders(packName);

  return new Promise((resolve) => {
    resolve(newFolders);
  });
}


/***/ }),

/***/ 728:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TH": () => (/* binding */ migrateItemsDAESRD),
/* harmony export */   "$n": () => (/* binding */ addItemsDAESRD),
/* harmony export */   "KS": () => (/* binding */ migrateActorDAESRD)
/* harmony export */ });
/* unused harmony export loadPacks */
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(259);
/* harmony import */ var _import_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(193);
// Modified from https://gitlab.com/tposney/dae/-/blob/master/src/module/migration.ts

// MIT License

// Copyright (c) 2020 Tim Posney

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.




var packsLoaded = false;
var itemPack;
var spellPack;
var featsPack;
var midiPack;
var magicItemsPack;
var midiItemsPack;
var midiSpellsPack;
var midiFeatsPack;


async function loadPacks() {
  if (packsLoaded) return;
  const items = game.packs.get("Dynamic-Effects-SRD.DAE SRD Items");
  itemPack = items ? await items.getDocuments() : [];

  const spells = game.packs.get("Dynamic-Effects-SRD.DAE SRD Spells");
  spellPack = spells ? await spells.getDocuments() : [];

  const magicItems = game.packs.get("Dynamic-Effects-SRD.DAE SRD Magic Items");
  magicItemsPack = magicItems ? await magicItems.getDocuments() : [];

  const feats = game.packs.get("Dynamic-Effects-SRD.DAE SRD Feats");
  featsPack = feats ? await feats.getDocuments() : [];

  const srdMidi = game.packs.get("Dynamic-Effects-SRD.DAE SRD Midi-collection");
  midiPack = srdMidi ? await srdMidi.getDocuments() : [];

  const midiItems = game.packs.get("midi-srd.Midi SRD Items");
  midiItemsPack = midiItems ? await midiItems.getDocuments() : [];
  const midiSpells = game.packs.get("midi-srd.Midi SRD Spells");
  midiSpellsPack = midiSpells ? await midiSpells.getDocuments() : [];
  const midiFeats = game.packs.get("midi-srd.Midi SRD Feats");
  midiFeatsPack = midiFeats ? await midiFeats.getDocuments() : [];

  // eslint-disable-next-line require-atomic-updates
  packsLoaded = true;
}

function findDAEItem(itemData, packs) {
  for (let pack of packs) {
    let matchItem = pack.find((pd) =>
      pd.name === itemData.name &&
      pd.type === itemData.type
    );
    // console.warn(itemData.name);
    // console.warn(matchItem);
    if (matchItem) return matchItem;
  }
  return undefined;
}

function dataSwap(itemData, replaceData) {
  (0,_import_js__WEBPACK_IMPORTED_MODULE_1__/* .updateCharacterItemFlags */ .Oi)(itemData, replaceData);
  if (itemData._id) replaceData._id = itemData._id;
  if (itemData.flags) replaceData.flags = { ...itemData.flags, ...replaceData.flags };
  return replaceData;
}

function matchItem(itemData) {
  // we only add the midi packs if midi is actually installed
  let returnItem = null;
  switch (itemData.type) {
    case "feat": {
      const featPacks = [midiFeatsPack, midiPack, featsPack];
      returnItem = findDAEItem(itemData, featPacks);
      break;
    }
    case "spell": {
      const spellPacks = [midiSpellsPack, midiPack, spellPack];
      returnItem = findDAEItem(itemData, spellPacks);
      break;
    }
    case "equipment":
    case "weapon":
    case "loot":
    case "consumable":
    case "tool":
    case "backpack": {
      const equipmentPacks = [midiItemsPack, midiPack, itemPack, magicItemsPack];
      returnItem = findDAEItem(itemData, equipmentPacks);
      break;
    }
    default:
      break;
  }
  return returnItem;
}


/**
 * Migrates items wholesale
 * @param {*} items
 */
async function migrateItemsDAESRD(items) {
  if (!packsLoaded) await loadPacks();

  return new Promise((resolve) => {
    resolve(
      items.map((itemData) => {
        let replaceData = matchItem(itemData);
        if (replaceData) {
          _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.debug */ .Z.debug(`migrating ${replaceData.data.name}`);
          setProperty(replaceData.data.flags, "dae.migrated", true);
          return dataSwap(itemData, replaceData.data);
        }
        return itemData;
      })
    );
  });
}

/**
 * Adds dae effects to existing items
 * @param {*} items
 */
async function addItemsDAESRD(items) {
  // eslint-disable-next-line require-atomic-updates
  if (!packsLoaded) await loadPacks();

  return new Promise((resolve) => {
    resolve(
      items.map((itemData) => {
        let replaceData = matchItem(itemData);
        if (replaceData) {
          replaceData = replaceData.data.toObject();
          _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.debug */ .Z.debug(`Adding effects for ${replaceData.name}`);
          itemData.effects = replaceData.effects;
          if (replaceData.flags.dae) itemData.flags.dae = replaceData.flags.dae;
          if (replaceData.flags['midi-qol']) itemData.flags['midi-qol'] = replaceData.flags['midi-qol'];
          if (replaceData.flags.itemacro) itemData.flags.itemacro = replaceData.flags.itemacro;
          if (replaceData.flags.itemmacro) itemData.flags.itemmacro = replaceData.flags.itemmacro;
        }
        return itemData;
      })
    );
  });
}

/**
 * Replaces matching items in an actor
 * @param {*} actor
 */
async function migrateActorDAESRD(actor, includeSRD = false) {
  await DAE.migrateActorDAESRD(actor, includeSRD);
}


/***/ }),

/***/ 193:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Eb": () => (/* binding */ getCompendiumLabel),
/* harmony export */   "Er": () => (/* binding */ removeItems),
/* harmony export */   "uf": () => (/* binding */ copySupportedItemFlags),
/* harmony export */   "uc": () => (/* binding */ looseItemNameMatch),
/* harmony export */   "EX": () => (/* binding */ compendiumFolders),
/* harmony export */   "X": () => (/* binding */ updateCompendium),
/* harmony export */   "al": () => (/* binding */ getImagePath),
/* harmony export */   "CW": () => (/* binding */ getSRDIconLibrary),
/* harmony export */   "u4": () => (/* binding */ copySRDIcons),
/* harmony export */   "m$": () => (/* binding */ getDDBGenericItemIcons),
/* harmony export */   "pV": () => (/* binding */ getDDBSpellSchoolIcons),
/* harmony export */   "BO": () => (/* binding */ getDDBEquipmentIcons),
/* harmony export */   "Oi": () => (/* binding */ updateCharacterItemFlags),
/* harmony export */   "pI": () => (/* binding */ getCompendiumItems),
/* harmony export */   "wW": () => (/* binding */ getSRDCompendiumItems),
/* harmony export */   "oU": () => (/* binding */ addItemEffectIcons),
/* harmony export */   "wo": () => (/* binding */ updateIcons),
/* harmony export */   "cC": () => (/* binding */ srdFiddling),
/* harmony export */   "xh": () => (/* binding */ daeFiddling),
/* harmony export */   "ah": () => (/* binding */ addMagicItemSpells)
/* harmony export */ });
/* unused harmony exports filterItemsByUserSelection, updateMagicItemImages, addACEffectIcons */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(555);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(259);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(192);
/* harmony import */ var _dae_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(728);
/* harmony import */ var _icons_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(547);
/* harmony import */ var _compendiumFolders_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(269);








// a mapping of compendiums with content type
const compendiumLookup = [
  { type: "inventory", compendium: "entity-item-compendium" },
  { type: "item", compendium: "entity-item-compendium" },
  { type: "items", compendium: "entity-item-compendium" },
  { type: "spells", compendium: "entity-spell-compendium" },
  { type: "feats", compendium: "entity-feat-compendium" },
  { type: "spell", compendium: "entity-spell-compendium" },
  { type: "itemspells", compendium: "entity-item-spell-compendium" },
  { type: "features", compendium: "entity-feature-compendium" },
  { type: "classes", compendium: "entity-class-compendium" },
  { type: "class", compendium: "entity-class-compendium" },
  { type: "races", compendium: "entity-race-compendium" },
  { type: "traits", compendium: "entity-trait-compendium" },
  { type: "race", compendium: "entity-race-compendium" },
  { type: "npc", compendium: "entity-monster-compendium" },
  { type: "monsters", compendium: "entity-monster-compendium" },
  { type: "monster", compendium: "entity-monster-compendium" },
  { type: "custom", compendium: "entity-override-compendium" },
  { type: "feat", name: "entity-feature-compendium" },
  { type: "weapon", name: "entity-item-compendium" },
  { type: "consumable", name: "entity-item-compendium" },
  { type: "tool", name: "entity-item-compendium" },
  { type: "loot", name: "entity-item-compendium" },
  { type: "backpack", name: "entity-item-compendium" },
  { type: "spell", name: "entity-spell-compendium" },
  { type: "equipment", name: "entity-item-compendium" },
  { type: "monsterfeatures", name: "entity-feature-compendium" },
  { type: "table", compendium: "entity-table-compendium" },
  { type: "tables", compendium: "entity-table-compendium" },
];

const srdCompendiumLookup = [
  { type: "inventory", name: "dnd5e.items" },
  { type: "spells", name: "dnd5e.spells" },
  { type: "features", name: "dnd5e.classfeatures" },
  { type: "races", name: "dnd5e.races" },
  { type: "traits", name: "dnd5e.races" },
  { type: "features", name: "dnd5e.classfeatures" },
  { type: "feat", name: "dnd5e.classfeatures" },
  { type: "feats", name: "dnd5e.classfeatures" },
  { type: "classes", name: "dnd5e.classfeatures" },
  { type: "weapon", name: "dnd5e.items" },
  { type: "consumable", name: "dnd5e.items" },
  { type: "tool", name: "dnd5e.items" },
  { type: "loot", name: "dnd5e.items" },
  { type: "backpack", name: "dnd5e.items" },
  { type: "spell", name: "dnd5e.spells" },
  { type: "equipment", name: "dnd5e.items" },
  { type: "monsters", name: "dnd5e.monsters" },
  { type: "monsterfeatures", name: "dnd5e.monsterfeatures" },
];

const SUPPORTED_FLAG_GROUPS = [
  "dae",
  "maestro",
  "mess",
  "favtab",
  "midi-qol",
  "itemacro",
  "itemmacro",
  "autoanimations",
  "enhancedcombathud",
  "cf",
  "automated-evocations",
];

var srdIconMapLoaded = false;
var srdIconMap = {};
var srdPacksLoaded = {};
var srdPacks = {};

async function loadSRDPacks(compendiumName) {
  if (srdPacksLoaded[compendiumName]) return;
  const srdPack = await game.packs.get(compendiumName);
  if (!srdPack) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.error */ .Z.error(`Failed to load SRDPack ${compendiumName}`);
  } else {
    srdPacks[compendiumName] = await srdPack.getDocuments().then((data) => data.map((i) => i.data));
    // eslint-disable-next-line require-atomic-updates
    srdPacksLoaded[compendiumName] = true;
  }
}

const gameFolderLookup = [
  {
    type: "itemSpells",
    folder: "magic-item-spells",
    itemType: "spell",
  },
  {
    type: "magicItems",
    folder: "magic-items",
    itemType: "item",
  },
  {
    type: "spells",
    folder: "spell",
    itemType: "spell",
  },
  {
    type: "monsters",
    folder: "npc",
    itemType: "actor",
  },
];

function getCompendiumLabel(type) {
  const compendiumName = compendiumLookup.find((c) => c.type == type).compendium;
  const compendiumLabel = game.settings.get("ddb-importer", compendiumName);
  return compendiumLabel;
}

/**
 * Removes items
 * @param {*} items
 * @param {*} itemsToRemove
 */
async function removeItems(items, itemsToRemove) {
  return new Promise((resolve) => {
    resolve(
      items.filter(
        (item) =>
          !itemsToRemove.some((originalItem) => item.name === originalItem.name && item.type === originalItem.type)
      )
    );
  });
}

const getCharacterUpdatePolicyTypes = () => {
  let itemTypes = [];
  itemTypes.push("class");
  if (game.settings.get("ddb-importer", "character-update-policy-feat")) itemTypes.push("feat");
  if (game.settings.get("ddb-importer", "character-update-policy-weapon")) itemTypes.push("weapon");
  if (game.settings.get("ddb-importer", "character-update-policy-equipment"))
    itemTypes = itemTypes.concat(DICTIONARY.types.equipment);
  if (game.settings.get("ddb-importer", "character-update-policy-spell")) itemTypes.push("spell");
  return itemTypes;
};

/**
 * Returns a combined array of all items to process, filtered by the user's selection on what to skip and what to include
 * @param {object} result object containing all character items sectioned as individual properties
 * @param {array[string]} sections an array of object properties which should be filtered
 */
const filterItemsByUserSelection = (result, sections) => {
  let items = [];
  const validItemTypes = getCharacterUpdatePolicyTypes();

  for (const section of sections) {
    items = items.concat(result[section]).filter((item) => validItemTypes.includes(item.type));
  }
  return items;
};

async function copyFlagGroup(flagGroup, originalItem, targetItem) {
  if (targetItem.flags === undefined) targetItem.flags = {};
  if (originalItem.flags && !!originalItem.flags[flagGroup]) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Copying ${flagGroup} for ${originalItem.name}`);
    targetItem.flags[flagGroup] = originalItem.flags[flagGroup];
  }
}

/**
 * Copies across some flags for existing item
 * @param {*} items
 */
async function copySupportedItemFlags(originalItem, item) {
  SUPPORTED_FLAG_GROUPS.forEach((flagGroup) => {
    copyFlagGroup(flagGroup, originalItem, item);
  });
}

function getMonsterNames(name) {
  let magicNames = [name, name.toLowerCase()];

  // +2 sword
  let frontPlus = name.match(/^(\+\d*)\s*(.*)/);
  if (frontPlus) {
    magicNames.push(`${frontPlus[2].trim()}, ${frontPlus[1]}`.toLowerCase().trim());
  }

  // sword +2
  let backPlus = name.match(/(.*)\s*(\+\d*)$/);
  if (backPlus) {
    magicNames.push(`${backPlus[1].trim()}, ${backPlus[2]}`.toLowerCase().trim());
  }

  return magicNames;
}

function getLooseNames(name, extraNames = []) {
  let looseNames = extraNames;
  looseNames.push(name.toLowerCase());
  let refactNameArray = name.split("(")[0].trim().split(", ");
  refactNameArray.unshift(refactNameArray.pop());
  const refactName = refactNameArray.join(" ").trim();
  looseNames.push(refactName, refactName.toLowerCase());
  looseNames.push(refactName.replace(/\+\d*\s*/, "").trim().toLowerCase());
  looseNames.push(refactName.replace(/\+\d*\s*/, "").trim().toLowerCase().replace(/s$/, ""));

  let refactNamePlusArray = name.replace(/\+\d*\s*/, "").trim().split("(")[0].trim().split(", ");
  refactNamePlusArray.unshift(refactNamePlusArray.pop());
  const refactNamePlus = refactNamePlusArray.join(" ").trim();
  looseNames.push(refactNamePlus.toLowerCase());

  let deconNameArray = name.replace("(", "").replace(")", "").trim().split(",");
  deconNameArray.unshift(deconNameArray.pop());
  const deconName = deconNameArray.join(" ").trim();
  looseNames.push(deconName, deconName.toLowerCase());

  // word smart quotes are the worst
  looseNames.push(name.replace("'", "â€™").toLowerCase());
  looseNames.push(name.replace("â€™", "'").toLowerCase());
  looseNames.push(name.replace(/s$/, "").toLowerCase()); // trim s, e.g. crossbow bolt(s)
  looseNames.push(name.replace(",", "").toLowerCase()); // +1 weapons etc
  looseNames.push(`${name} attack`.toLowerCase()); // Claw Attack
  looseNames.push(name.split(",")[0].toLowerCase());

  return looseNames;
}

// The monster setting is less vigorous!
async function looseItemNameMatch(item, items, loose = false, monster = false, magicMatch = false) {
  // first pass is a strict match
  let matchingItem = items.find((matchItem) => {
    let activationMatch = false;
    const alternativeNames = (((matchItem.flags || {}).ddbimporter || {}).dndbeyond || {}).alternativeNames;
    const extraNames = (alternativeNames) ? matchItem.flags.ddbimporter.dndbeyond.alternativeNames : [];

    const itemActivationProperty = Object.prototype.hasOwnProperty.call(item.data, 'activation');
    const matchItemActivationProperty = Object.prototype.hasOwnProperty.call(item.data, 'activation');

    if (itemActivationProperty && item.data?.activation?.type == "") {
      activationMatch = true;
    } else if (matchItemActivationProperty && itemActivationProperty) {
      // I can't remember why I added this. Maybe I was concerned about identical named items with
      // different activation times?
      // maybe I just want to check it exists?
      // causing issues so changed.
      // activationMatch = matchItem.data.activation.type === item.data.activation.type;
      activationMatch = matchItemActivationProperty && itemActivationProperty;
    } else if (!itemActivationProperty) {
      activationMatch = true;
    }

    const nameMatch = item.name === matchItem.name || extraNames.includes(item.name);
    const isMatch = nameMatch && item.type === matchItem.type && activationMatch;
    return isMatch;
  });

  if (!matchingItem && monster) {
    matchingItem = items.find(
      (matchItem) => {
        const monsterNames = getMonsterNames(matchItem.name);
        const monsterMatch = (monsterNames.includes(item.name.toLowerCase())) &&
          _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* .default.types.monster.includes */ .Z.types.monster.includes(matchItem.type) &&
          _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* .default.types.inventory.includes */ .Z.types.inventory.includes(item.type);
        return monsterMatch;
      });
  }

  if (!matchingItem && magicMatch) {
    // is this an inverse match for updates?
    // if so strip out the non-magic names, we want to match on the magic names
    const magicName = item.name.replace(/(.*)\s+(\+\d*)\s*/, "$1, $2").trim().toLowerCase();
    matchingItem = items.find(
      (matchItem) => matchItem.name.trim().toLowerCase() == magicName
    );
  }

  if (!matchingItem && loose) {
    const looseNames = getLooseNames(item.name)
      .filter((name) => {
        if (!magicMatch) return true;
        const removeMagicName = name.replace(/\+\d*\s*/, "").trim();
        if (name === removeMagicName) return false;
        return true;
      });
    // lets go loosey goosey on matching equipment, we often get types wrong
    matchingItem = items.find(
      (matchItem) =>
        (looseNames.includes(matchItem.name.toLowerCase()) || looseNames.includes(matchItem.name.toLowerCase().replace(" armor", ""))) &&
        _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* .default.types.inventory.includes */ .Z.types.inventory.includes(item.type) &&
        _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* .default.types.inventory.includes */ .Z.types.inventory.includes(matchItem.type)
    );

    // super loose name match!
    if (!matchingItem) {
      // still no matching item, lets do a final pass
      matchingItem = items.find(
        (matchItem) => looseNames.includes(matchItem.name.split("(")[0].trim().toLowerCase())
      );
    }
  }
  return matchingItem;
}

function flagMatch(item1, item2, matchFlags) {
  if (matchFlags.length === 0) return true;
  let matched = false;
  matchFlags.forEach((flag) => {
    if (item1.flags.ddbimporter[flag] &&
      item2.flags.ddbimporter[flag] &&
      item1.flags.ddbimporter[flag] === item2.flags.ddbimporter[flag]
    ) {
      matched = true;
    }
  });

  return matched;
}

async function getFilteredItems(compendium, item, index, matchFlags) {
  const indexEntries = index.filter((idx) => idx.name === item.name);

  const mapped = await Promise.all(indexEntries.map((idx) => {
    const entry = compendium.getDocument(idx._id).then((doc) => doc);
    return entry;
  }));

  const flagFiltered = mapped.filter((idx) => {
    const nameMatch = idx.name === item.name;
    const flagMatched = flagMatch(idx.data, item, matchFlags);
    return nameMatch && flagMatched;
  });

  return flagFiltered;
}

// async function getFlaggedItems(compendium, items, index, matchFlags) {
//   let results = [];
//   items.forEach((item) => {
//     const flagged = getFilteredItems(compendium, item, index, matchFlags);
//     results.push(flagged);
//   });
//   return Promise.all(results);
// }

async function updateCompendiumItems(compendium, compendiumItems, index, matchFlags) {
  let promises = [];
  compendiumItems.forEach(async (item) => {
    const existingItems = await getFilteredItems(compendium, item, index, matchFlags);
    // we have a match, update first match
    if (existingItems.length >= 1) {
      const existing = existingItems[0];
      delete item._id;
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)(`Updating ${item.name}`);
      // purge existing active effects on this item
      if (existing.results) await existing.deleteEmbeddedDocuments("TableResult", [], { deleteAll: true });
      if (existing.effects) await existing.deleteEmbeddedDocuments("ActiveEffect", [], { deleteAll: true });
      if (existing.flags) await copySupportedItemFlags(existing, item.data);
      promises.push(existing.update(item));
    }
  });
  return Promise.all(promises);
}

async function createCompendiumItems(type, compendium, compendiumItems, index, matchFlags) {
  let promises = [];
  // compendiumItems.forEach(async (item) => {
  for (const item of compendiumItems) {
    // eslint-disable-next-line no-await-in-loop
    const existingItems = await getFilteredItems(compendium, item, index, matchFlags);
    // we have a single match
    if (existingItems.length === 0) {
      let newItem;
      switch (type) {
        case "table":
        case "tables": {
          newItem = new RollTable(item);
          break;
        }
        default: {
          // eslint-disable-next-line no-await-in-loop
          newItem = await Item.create(item, {
            temporary: true,
            displaySheet: false,
          });
        }
      }
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)(`Creating ${item.name}`);
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Pushing ${item.name} to compendium`);
      promises.push(compendium.importDocument(newItem));
    }
  };
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)(`Waiting for items in compendium...`, true);
  return Promise.all(promises);
}

async function compendiumFolders(document, type) {
  // using compendium folders?
  const compendiumFolderAdd = game.settings.get("ddb-importer", "munching-policy-use-compendium-folders");
  const compendiumFoldersInstalled = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.isModuleInstalledAndActive */ .Z.isModuleInstalledAndActive("compendium-folders");
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)(`Checking compendium folders..`, true);
  if (compendiumFolderAdd && compendiumFoldersInstalled) {
    // we create the compendium folder before import
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)(`Adding ${document.name} to compendium folder`);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Adding ${document.name} to compendium folder`);
    await (0,_compendiumFolders_js__WEBPACK_IMPORTED_MODULE_6__/* .addToCompendiumFolder */ .l0)(type, document);
  }
}

async function updateCompendium(type, input, updateExisting = false, matchFlags = []) {
  const compendiumLabel = getCompendiumLabel(type);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Getting compendium ${compendiumLabel} for update of ${type} documents (checking ${input[type].length} docs)`);
  const compendium = await game.packs.get(compendiumLabel);
  compendium.configure({ locked: false });

  if (game.user.isGM) {
    const initialIndex = await compendium.getIndex();
    // remove duplicate items based on name and type
    const compendiumItems = [...new Map(input[type].map((item) => [item["name"] + item["type"], item])).values()];

    let updateResults = [];
    // update existing items
    if (updateExisting) {
      updateResults = await updateCompendiumItems(compendium, compendiumItems, initialIndex, matchFlags);
    }

    // create new items
    const createResults = await createCompendiumItems(type, compendium, compendiumItems, initialIndex, matchFlags);

    // compendium folders
    createResults.forEach(async (document) => {
      await compendiumFolders(document, type);
    });

    const results = createResults.concat(updateResults);
    return new Promise((resolve) => resolve(results));
  }
  return [];
}


async function getImagePath(imageUrl, type = "ddb", name = "", download = false, remoteImages = false) {
  const frameDirectory = game.settings.get("ddb-importer", "frame-image-upload-directory").replace(/^\/|\/$/g, "");
  const otherDirectory = game.settings.get("ddb-importer", "other-image-upload-directory").replace(/^\/|\/$/g, "");
  const uploadDirectory = type === "frame" ? frameDirectory : otherDirectory;
  const downloadImage = (download) ? download : game.settings.get("ddb-importer", "munching-policy-download-images");
  const remoteImage = (remoteImages) ? remoteImages : game.settings.get("ddb-importer", "munching-policy-remote-images");

  if (imageUrl && downloadImage) {
    const ext = imageUrl.split(".").pop().split(/#|\?|&/)[0];
    if (!name) name = imageUrl.split("/").pop();

    // image upload
    const filename = type + "-" + name.replace(/[^a-zA-Z0-9]/g, "-").replace(/-+/g, "-").trim();
    const imageExists = await _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.fileExists */ .Z.fileExists(uploadDirectory, filename + "." + ext);

    if (imageExists) {
      // eslint-disable-next-line require-atomic-updates
      const image = await _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.getFileUrl */ .Z.getFileUrl(uploadDirectory, filename + "." + ext);
      return image.trim();
    } else {
      // eslint-disable-next-line require-atomic-updates
      const image = await _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.uploadImage */ .Z.uploadImage(imageUrl, uploadDirectory, filename);
      // did upload succeed? if not fall back to remote image path
      if (image) {
        return image.trim();
      } else {
        return null;
      }

    }
  } else if (imageUrl && remoteImage) {
    try {
      // logger.debug('Trying: ' + imageUrl.trim());
      // await utils.serverFileExists(imageUrl.trim());
      return imageUrl.trim();
    } catch (ignored) {
      return null;
    }
  }
  return null;
}

async function getSRDIconMatch(type) {
  const compendiumName = srdCompendiumLookup.find((c) => c.type == type).name;
  if (!srdPacksLoaded[compendiumName]) await loadSRDPacks(compendiumName);

  const items = srdPacks[compendiumName].map((item) => {
    let smallItem = {
      name: item.name,
      img: item.img,
      type: item.type,
      data: {},
    };
    if (item.data.activation) smallItem.data.activation = item.data.activation;
    return smallItem;
  });

  return items;
}

async function getSRDIconLibrary() {
  if (srdIconMapLoaded) return srdIconMap;
  const compendiumFeatureItems = await getSRDIconMatch("features");
  const compendiumInventoryItems = await getSRDIconMatch("inventory");
  const compendiumSpellItems = await getSRDIconMatch("spells");
  const compendiumMonsterFeatures = await getSRDIconMatch("monsterfeatures");

  srdIconMap = compendiumInventoryItems.concat(
    compendiumSpellItems,
    compendiumFeatureItems,
    compendiumMonsterFeatures,
  );
  return srdIconMap;
}

// eslint-disable-next-line require-atomic-updates
async function copySRDIcons(items, srdIconLibrary = null, nameMatchList = []) {
  // eslint-disable-next-line require-atomic-updates
  if (!srdIconLibrary) srdIconLibrary = await getSRDIconLibrary();

  return new Promise((resolve) => {
    const srdItems = items.map((item) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Matching ${item.name}`);
      const nameMatch = nameMatchList.find((m) => m.name === item.name);
      if (nameMatch) {
        item.img = nameMatch.img;
      } else {
        looseItemNameMatch(item, srdIconLibrary, true).then((match) => {
          if (match) {
            srdIconLibrary.push({ name: item.name, img: match.img });
            item.img = match.img;
          }
        });
      }
      return item;

    });
    resolve(srdItems);
  });
}

async function getDDBItemImages(items, download) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)(`Fetching DDB Item Images`);
  const downloadImages = (download) ? true : game.settings.get("ddb-importer", "munching-policy-download-images");
  const remoteImages = game.settings.get("ddb-importer", "munching-policy-remote-images");

  const itemMap = items.map(async (item) => {
    let itemImage = {
      name: item.name,
      type: item.type,
      img: null,
      large: null,
    };

    if (item.flags && item.flags.ddbimporter && item.flags.ddbimporter && item.flags.ddbimporter.dndbeyond) {
      if (item.flags.ddbimporter.dndbeyond.avatarUrl) {
        const avatarUrl = item.flags.ddbimporter.dndbeyond['avatarUrl'];
        if (avatarUrl && avatarUrl != "") {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)(`Downloading ${item.name} image`);
          const smallImage = await getImagePath(avatarUrl, 'item', item.name, downloadImages, remoteImages);
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Final image ${smallImage}`);
          itemImage.img = smallImage;
        }
      }
      if (item.flags.ddbimporter.dndbeyond.largeAvatarUrl) {
        const largeAvatarUrl = item.flags.ddbimporter.dndbeyond['largeAvatarUrl'];
        if (largeAvatarUrl && largeAvatarUrl != "") {
          const largeImage = await getImagePath(largeAvatarUrl, 'item-large', item.name, downloadImages, remoteImages);
          itemImage.large = largeImage;
          if (!itemImage.img) itemImage.img = largeImage;
        }
      }
    }

    (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)("");
    return itemImage;
  });

  return Promise.all(itemMap);
}

async function getDDBGenericItemImages(download) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)(`Fetching DDB Generic Item icons`);
  const itemMap = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* .default.items.map */ .Z.items.map(async (item) => {
    const img = await getImagePath(item.img, 'item', item.filterType, download);
    let itemIcons = {
      filterType: item.filterType,
      img: img,
    };
    return itemIcons;
  });

  (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)("");
  return Promise.all(itemMap);
}

async function getDDBGenericLootImages(download) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)(`Fetching DDB Generic Loot icons`);
  const itemMap = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* .default.genericItemIcons.map */ .Z.genericItemIcons.map(async (item) => {
    const img = await getImagePath(item.img, 'equipment', item.name, download);
    let itemIcons = {
      name: item.name,
      img: img,
    };
    return itemIcons;
  });

  (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)("");
  return Promise.all(itemMap);
}

async function getDDBGenericItemIcons(items, download) {
  const genericItems = await getDDBGenericItemImages(download);
  const genericLoots = await getDDBGenericLootImages(download);

  let updatedItems = items.map((item) => {
    // logger.debug(item.name);
    // logger.debug(item.flags.ddbimporter.dndbeyond.filterType);
    const excludedItems = ["spell", "feat", "class"];
    if (!excludedItems.includes(item.type) &&
        item.flags &&
        item.flags.ddbimporter &&
        item.flags.ddbimporter.dndbeyond) {
      let generic = null;
      if (item.flags.ddbimporter.dndbeyond.filterType) {
        generic = genericItems.find((i) => i.filterType === item.flags.ddbimporter.dndbeyond.filterType);
      } else if (item.flags.ddbimporter.dndbeyond.type) {
        generic = genericLoots.find((i) => i.name === item.flags.ddbimporter.dndbeyond.type);
      }
      if (generic && (!item.img || item.img == "" || item.img == "icons/svg/mystery-man.svg")) {
        item.img = generic.img;
      }
    }
    return item;
  });
  return Promise.all(updatedItems);
}

async function getDDBSchoolSpellImages(download) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)(`Fetching spell school icons`);
  const schoolMap = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* .default.spell.schools.map */ .Z.spell.schools.map(async (school) => {
    const img = await getImagePath(school.img, 'spell', school.name, download);
    let schoolIcons = {
      name: school.name,
      img: img,
      id: school.id,
    };
    return schoolIcons;
  });

  (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .munchNote */ .ep)("");
  return Promise.all(schoolMap);
}

async function getDDBSpellSchoolIcons(items, download) {
  const schools = await getDDBSchoolSpellImages(download);

  let updatedItems = items.map((item) => {
    // logger.debug(item.name);
    // logger.debug(item.flags.ddbimporter.dndbeyond);
    if (item.type == "spell") {
      const school = schools.find((school) => school.id === item.data.school);
      if (school && (!item.img || item.img == "" || item.img == "icons/svg/mystery-man.svg")) {
        item.img = school.img;
      }
    }
    return item;
  });
  return Promise.all(updatedItems);
}

async function getDDBEquipmentIcons(items, download) {
  const itemImages = await getDDBItemImages(items.filter((item) => _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* .default.types.inventory.includes */ .Z.types.inventory.includes(item.type)), download);

  let updatedItems = items.map((item) => {
    // logger.debug(item.name);
    // logger.debug(item.flags.ddbimporter.dndbeyond);
    if (_dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* .default.types.inventory.includes */ .Z.types.inventory.includes(item.type)) {
      if (!item.img || item.img == "" || item.img == "icons/svg/mystery-man.svg") {
        const imageMatch = itemImages.find((m) => m.name == item.name && m.type == item.type);
        if (imageMatch && imageMatch.img) {
          item.img = imageMatch.img;
        }
        if (imageMatch && imageMatch.large) {
          item.flags.ddbimporter.dndbeyond['pictureUrl'] = imageMatch.large;
        }
      }
    }
    return item;
  });
  return Promise.all(updatedItems);
}


async function updateMagicItemImages(items) {
  const useSRDCompendiumIcons = game.settings.get("ddb-importer", "character-update-policy-use-srd-icons");
  const ddbSpellIcons = game.settings.get("ddb-importer", "character-update-policy-use-ddb-spell-icons");
  const inbuiltIcons = game.settings.get("ddb-importer", "character-update-policy-use-inbuilt-icons");
  const ddbItemIcons = game.settings.get("ddb-importer", "character-update-policy-use-ddb-item-icons");

  // if we still have items to add, add them
  if (items.length > 0) {
    if (ddbItemIcons) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Magic items: adding equipment icons");
      items = await getDDBEquipmentIcons(items, true);
    }

    if (inbuiltIcons) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Magic items: adding inbuilt icons");
      items = await (0,_icons_index_js__WEBPACK_IMPORTED_MODULE_5__/* .copyInbuiltIcons */ .b)(items);
    }

    if (useSRDCompendiumIcons) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Magic items: adding srd compendium icons");
      items = await copySRDIcons(items);
    }

    if (ddbSpellIcons) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Magic items: adding ddb spell school icons");
      items = await getDDBSpellSchoolIcons(items, true);
    }
  }
  return items;
}

/**
 * Updates game folder items
 * @param {*} type
 */
async function updateFolderItems(type, input, update = true) {
  if (type === "itemSpells") {
    // eslint-disable-next-line require-atomic-updates
    input[type] = await updateMagicItemImages(input[type]);
  }

  const folderLookup = gameFolderLookup.find((c) => c.type == type);
  const itemFolderNames = [...new Set(input[type]
    .filter((item) => item.flags?.ddbimporter?.dndbeyond?.lookupName)
    .map((item) => item.flags.ddbimporter.dndbeyond.lookupName))];

  const getSubFolders = async () => {
    return Promise.all(
      itemFolderNames.map((name) => {
        return _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.getFolder */ .Z.getFolder(folderLookup.folder, name);
      })
    );
  };

  const subFolders = await getSubFolders();

  const defaultItemsFolder = await _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.getFolder */ .Z.getFolder(folderLookup.folder);
  const existingItems = await game.items.entities.filter((item) => {
    const itemFolder = subFolders.find((folder) =>
      item.data.flags?.ddbimporter?.dndbeyond?.lookupName &&
      folder.name === item.data.flags.ddbimporter.dndbeyond.lookupName
    );
    return itemFolder && item.type === folderLookup.itemType && item.data.folder === itemFolder._id;
  });

  // update or create folder items
  const updateItems = async () => {
    return Promise.all(
      input[type]
        .filter((item) => existingItems.some((idx) => idx.name === item.name))
        .map(async (item) => {
          const existingItem = await existingItems.find((existing) => item.name === existing.name);
          item._id = existingItem._id;
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Updating ${type} ${item.name}`);
          await copySupportedItemFlags(existingItem, item);
          await Item.update(item);
          return item;
        })
    );
  };

  const createItems = async () => {
    return Promise.all(
      input[type]
        .filter((item) => !existingItems.some((idx) => idx.name === item.name))
        .map(async (item) => {
          if (!game.user.can("ITEM_CREATE")) {
            ui.notifications.warn(`Cannot create ${folderLookup.type} ${item.name} for ${type}`);
          } else {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Creating ${type} ${item.name}`);
            const itemsFolder = subFolders.find((folder) =>
              item.flags?.ddbimporter?.dndbeyond?.lookupName &&
              folder.name === item.flags.ddbimporter.dndbeyond.lookupName
            );
            item.folder = (itemsFolder) ? itemsFolder._id : defaultItemsFolder._id;
            await Item.create(item);
          }
          return item;
        })
    );
  };

  if (update) await updateItems();
  await createItems();

  // lets generate our compendium info like id, pack and img for use
  // by things like magicitems
  const folderIds = [defaultItemsFolder._id, ...subFolders.map((f) => f._id)];
  const items = Promise.all(
    game.items.entities
      .filter((item) => item.type === folderLookup.itemType && folderIds.includes(item.data.folder))
      .map((result) => {
        const subFolder = (result.data.flags.ddbimporter?.dndbeyond?.lookupName)
          ? result.data.flags.ddbimporter.dndbeyond.lookupName
          : null;
        return {
          magicItem: {
            _id: result._id,
            id: result._id,
            pack: "world",
            img: result.img,
            name: result.name,
            subFolder: subFolder,
            flatDc: result.data.flags?.ddbimporter?.dndbeyond?.overrideDC,
            dc: result.data.flags?.ddbimporter?.dndbeyond?.dc,
          },
          _id: result._id,
          name: result.name,
          compendium: false,
        };
      })
  );
  return items;
}

function updateCharacterItemFlags(itemData, replaceData) {
  if (itemData.data.quantity) replaceData.data.quantity = itemData.data.quantity;
  if (itemData.data.attuned) replaceData.data.attuned = itemData.data.attuned;
  if (itemData.data.attunement) replaceData.data.attunement = itemData.data.attunement;
  if (itemData.data.equipped) replaceData.data.equipped = itemData.data.equipped;
  if (itemData.data.uses) replaceData.data.uses = itemData.data.uses;
  if (itemData.data.resources) replaceData.data.resources = itemData.data.resources;
  if (itemData.data.consume) replaceData.data.consume = itemData.data.consume;
  if (itemData.data.preparation) replaceData.data.preparation = itemData.data.preparation;
  if (itemData.data.proficient) replaceData.data.proficient = itemData.data.proficient;
  if (itemData.data.ability) replaceData.data.ability = itemData.data.ability;
  return replaceData;
}

async function updateMatchingItems(oldItems, newItems, looseMatch = false, monster = false, keepId = false) {
  let results = [];

  for (let item of newItems) {
    // logger.debug(`checking ${item.name}`);
    const matched = await looseItemNameMatch(item, oldItems, looseMatch, monster); // eslint-disable-line no-await-in-loop

    // logger.debug(`matched? ${JSON.stringify(matched)}`);
    // console.log(matched);
    // const ddbItem = items.find((orig) =>
    //   (item.name === orig.name && item.type === orig.type && orig.data.activation
    //     ? orig.data.activation.type === item.data.activation.type
    //     : true)
    // );

    if (matched) {
      if (!item.flags.ddbimporter) {
        item.flags.ddbimporter = matched.flags.ddbimporter;
      } else if (matched.flags.ddbimporter && item.flags.ddbimporter) {
        item.flags.ddbimporter = mergeObject(matched.flags.ddbimporter, item.flags.ddbimporter);
      }
      if (!item.flags.monsterMunch && matched.flags.monsterMunch) {
        item.flags.monsterMunch = matched.flags.monsterMunch;
      }
      item.flags.ddbimporter["originalItemName"] = matched.name;
      item.flags.ddbimporter["replaced"] = true;

      item = updateCharacterItemFlags(matched, item);
      // do we want to enrich the compendium item with our parsed flag data?
      // item.flags = { ...matched.flags, ...item.flags };
      if (!keepId) delete item["_id"];
      results.push(item);
    }
  }

  return results;
}

/**
 * gets items from compendium
 * @param {*} items
 */
async function getCompendiumItems(items, type, compendiumLabel = null, looseMatch = false, monsterMatch = false, keepId = false, deleteCompendiumId = true) {
  if (!compendiumLabel) {
    compendiumLabel = getCompendiumLabel(type);
  }
  const compendium = await game.packs.get(compendiumLabel);
  if (!compendium) return [];
  const index = await compendium.getIndex();
  const firstPassItems = await index.filter((i) =>
    items.some((orig) => {
      const extraNames = (orig.flags?.ddbimporter?.dndbeyond?.alternativeNames)
        ? orig.flags.ddbimporter.dndbeyond.alternativeNames
        : [];
      if (looseMatch) {
        const looseNames = getLooseNames(orig.name, extraNames);
        return looseNames.includes(i.name.split("(")[0].trim().toLowerCase());
      } else if (monsterMatch) {
        const monsterNames = getMonsterNames(orig.name);
        // console.log(magicNames)
        if (i.name === orig.name) {
          return true;
        } else if (monsterNames.includes(i.name.toLowerCase())) {
          return true;
        } else {
          return false;
        }
      } else {
        return i.name === orig.name || extraNames.includes(i.name);
      }
    })
  );

  let loadedItems = [];
  for (const i of firstPassItems) {
    // eslint-disable-next-line no-await-in-loop
    let item = await compendium.getDocument(i._id).then((doc) => {
      const docData = doc.toObject();
      if (deleteCompendiumId) delete docData._id;
      return docData;
    });
    if (item.flags.ddbimporter) {
      item.flags.ddbimporter["pack"] = compendiumLabel;
    } else {
      item.flags.ddbimporter = { pack: compendiumLabel };
    }
    loadedItems.push(item);
  }
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`compendium ${type} loaded items:`, loadedItems);
  // console.log(loadedItems);

  const results = await updateMatchingItems(items, loadedItems, looseMatch, monsterMatch, keepId);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`compendium ${type} result items:`, results);
  // console.log(results);
  return results;
}

async function getSRDCompendiumItems(items, type, looseMatch = false, keepId = false) {
  const compendiumName = srdCompendiumLookup.find((c) => c.type == type).name;
  if (!srdPacksLoaded[compendiumName]) await loadSRDPacks(compendiumName);
  const compendiumItems = srdPacks[compendiumName];

  const loadedItems = await compendiumItems.filter((i) =>
    compendiumItems.some((orig) => {
      const extraNames = (orig.flags?.ddbimporter?.dndbeyond?.alternativeNames)
        ? orig.flags.ddbimporter.dndbeyond.alternativeNames
        : [];
      if (looseMatch) {
        const looseNames = getLooseNames(orig.name, extraNames);
        return looseNames.includes(i.name.split("(")[0].trim().toLowerCase());
      } else {
        return i.name === orig.name || extraNames.includes(i.name);
      }
    })
  ).map((i) => {
    const item = i.toObject();
    if (item.flags.ddbimporter) {
      item.flags.ddbimporter["pack"] = compendiumName;
    } else {
      item.flags.ddbimporter = { pack: compendiumName };
    }
    return item;
  });
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`SRD ${type} loaded items:`, loadedItems);

  const results = await updateMatchingItems(items, loadedItems, looseMatch, false, keepId);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`SRD ${type} result items:`, results);

  return results;
}

/**
 * Add an item to effects, if available
 * @param {*} items
 */
function addItemEffectIcons(items) {
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Adding Icons to effects");

  items.forEach((item) => {
    if (item.effects && (item.img || item.img !== "" || item.img !== "icons/svg/mystery-man.svg")) {
      item.effects.forEach((effect) => {

        if (!effect.icon || effect.icon === "" || effect.icon === "icons/svg/mystery-man.svg") {
          effect.icon = item.img;
        }
      });
    }

  });
  return items;
}

/**
 * TO DO : This function should do something.
 * @param {*} effects
 */
function addACEffectIcons(effects) {
  logger.debug("Adding Icons to AC effects");

  // effects.forEach((item) => {
  //   if (!effect.icon || effect.icon === "" || effect.icon === "icons/svg/mystery-man.svg") {
  //     effect.icon = item.img;
  //   }
  // });
  return effects;
}

async function updateIcons(items, srdIconUpdate = true, monster = false, monsterName = "") {
  // this will use ddb item icons as a fall back
  const ddbItemIcons = game.settings.get("ddb-importer", "munching-policy-use-ddb-item-icons");
  if (ddbItemIcons) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("DDB Equipment Icon Match");
    items = await getDDBEquipmentIcons(items);
  }

  const inBuiltIcons = game.settings.get("ddb-importer", "munching-policy-use-inbuilt-icons");
  if (inBuiltIcons) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Inbuilt icon matching");
    items = await (0,_icons_index_js__WEBPACK_IMPORTED_MODULE_5__/* .copyInbuiltIcons */ .b)(items, monster, monsterName);
  }

  // check for SRD icons
  const srdIcons = game.settings.get("ddb-importer", "munching-policy-use-srd-icons");
  // eslint-disable-next-line require-atomic-updates
  if (srdIcons && srdIconUpdate) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("SRD Icon Matching");
    items = await copySRDIcons(items);
  }

  // this will use ddb spell school icons as a fall back
  const ddbSpellIcons = game.settings.get("ddb-importer", "munching-policy-use-ddb-spell-icons");
  if (ddbSpellIcons) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("DDB Spell School Icon Match");
    items = await getDDBSpellSchoolIcons(items, true);
  }

  // this will use ddb generic icons as a fall back
  const ddbGenericItemIcons = game.settings.get("ddb-importer", "munching-policy-use-ddb-generic-item-icons");
  if (ddbGenericItemIcons) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("DDB Generic Item Icon Match");
    items = await getDDBGenericItemIcons(items, true);
  }

  // update any generated effects
  const addEffects = game.settings.get("ddb-importer", "munching-policy-add-effects");
  if (addEffects) {
    items = addItemEffectIcons(items);
  }

  return items;
}

async function srdFiddling(items, type) {
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");
  const useSrd = game.settings.get("ddb-importer", "munching-policy-use-srd");

  if (useSrd && type == "monsters") {
    const srdItems = await getSRDCompendiumItems(items, type);
    // removed existing items from those to be imported
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Removing compendium items");
    const lessSrdItems = await removeItems(items, srdItems);
    const newIcons = lessSrdItems.concat(srdItems);
    const iconedItems = await updateIcons(newIcons);
    return iconedItems;
  } else if (useSrd) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Removing compendium items");
    let itemMap = {};
    const srdItems = await getSRDCompendiumItems(items, type);
    itemMap[type] = srdItems;
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Adding SRD compendium items");
    updateCompendium(type, itemMap, updateBool);
    // removed existing items from those to be imported
    return new Promise((resolve) => {
      removeItems(items, srdItems)
      .then((cleanedItems) => updateIcons(cleanedItems))
      .then((iconItems) => resolve(iconItems));
    });
  } else {
    const iconItems = await updateIcons(items);
    return iconItems;
  }
}


async function daeFiddling(items) {
  const fiddle = game.settings.get("ddb-importer", "munching-policy-use-dae-effects");
  const installed = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.isModuleInstalledAndActive */ .Z.isModuleInstalledAndActive("dae") &&
    (_utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.isModuleInstalledAndActive */ .Z.isModuleInstalledAndActive("Dynamic-Effects-SRD") || _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.isModuleInstalledAndActive */ .Z.isModuleInstalledAndActive("midi-srd"));

  if (fiddle && installed) {
    return (0,_dae_js__WEBPACK_IMPORTED_MODULE_4__/* .addItemsDAESRD */ .$n)(items);
  } else return items;
}

async function getCompendiumItemSpells(spells) {
  const compendiumSpells = await getCompendiumItems(spells, "spell", null, false, false, true, false);
  const lessCompendiumSpells = await removeItems(spells, compendiumSpells);
  const srdSpells = await getSRDCompendiumItems(lessCompendiumSpells, "spell", false, true);
  const foundSpells = compendiumSpells.concat(srdSpells);

  const itemSpells = foundSpells.map((result) => {
    return {
      magicItem: {
        _id: result._id,
        id: result._id,
        pack: result.flags.ddbimporter.pack,
        img: result.img,
        name: result.name,
        flatDc: result.flags.ddbimporter.dndbeyond?.overrideDC,
        dc: result.flags.ddbimporter.dndbeyond?.dc,
      },
      _id: result._id,
      name: result.name,
      compendium: true,
    };
  });

  return [foundSpells, itemSpells];
}

/**
 * This adds magic item spells to an item, by looking in compendium or from a world.
 */
async function addMagicItemSpells(input) {
  // check for existing spells in spell compendium & srdCompendium
  const [compendiumSpells, compendiumItemSpells] = await getCompendiumItemSpells(input.itemSpells);
  // if spells not found create world version
  const remainingSpells = {
    itemSpells: await removeItems(input.itemSpells, compendiumSpells),
  };
  const worldSpells = remainingSpells.length > 0
    ? await updateFolderItems("itemSpells", remainingSpells)
    : [];
  const itemSpells = worldSpells.concat(compendiumItemSpells);

  // scan the inventory for each item with spells and copy the imported data over
  input.inventory.forEach((item) => {
    if (item.flags.magicitems.spells) {
      for (let [i, spell] of Object.entries(item.flags.magicitems.spells)) {
        const itemSpell = itemSpells.find((iSpell) => iSpell.name === spell.name &&
          (iSpell.compendium || iSpell.magicItem.subFolder === item.name)
        );
        if (itemSpell) {
          for (const [key, value] of Object.entries(itemSpell.magicItem)) {
            item.flags.magicitems.spells[i][key] = value;
          }
        } else if (!game.user.can("ITEM_CREATE")) {
          ui.notifications.warn(`Magic Item ${item.name} cannot be enriched because of lacking player permissions`);
        } else {
          ui.notifications.warn(`Magic Item ${item.name}: cannot add spell ${spell.name}`);
        }
      }
    }
  });
}


/***/ }),

/***/ 633:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "eX": () => (/* binding */ checkMonsterCompendium),
/* harmony export */   "ln": () => (/* binding */ buildNPC),
/* harmony export */   "Fx": () => (/* binding */ addNPC),
/* harmony export */   "NM": () => (/* binding */ generateIconMap),
/* harmony export */   "ph": () => (/* binding */ copyExistingMonsterImages)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(555);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(259);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _import_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(193);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(192);
/* harmony import */ var _dae_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(728);







var compendiumLoaded = false;
var monsterCompendium;

/**
 *
 * @param {[string]} items Array of Strings or
 */
async function retrieveCompendiumItems(items, compendiumName) {
  const GET_ENTITY = true;

  const itemNames = items.map((item) => {
    if (typeof item === "string") return item;
    if (typeof item === "object" && Object.prototype.hasOwnProperty.call(item, "name")) return item.name;
    return "";
  });

  const results = await _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.queryCompendiumEntries */ .Z.queryCompendiumEntries(compendiumName, itemNames, GET_ENTITY);
  const cleanResults = results.filter((item) => item !== null);

  return cleanResults;
}


/**
 *
 * @param {[items]} spells Array of Strings or items
 */
async function retrieveSpells(spells) {
  const compendiumName = await game.settings.get("ddb-importer", "entity-spell-compendium");
  const compendiumItems = await retrieveCompendiumItems(spells, compendiumName);
  const itemData = compendiumItems.map((i) => i.toJSON());

  return itemData;
}

// /**
//  *
//  * @param {[string]} items Array of Strings or items
//  */
// async function retrieveItems(items) {
//   const compendiumName = await game.settings.get("ddb-importer", "entity-item-compendium");

//   return retrieveCompendiumItems(items, compendiumName);
// }

async function getMonsterCompendium() {
  if (compendiumLoaded) return monsterCompendium;
  const compendiumName = await game.settings.get("ddb-importer", "entity-monster-compendium");
  if (compendiumName && compendiumName !== "") {
    monsterCompendium = await game.packs.get(compendiumName);
    if (monsterCompendium) {
      // eslint-disable-next-line require-atomic-updates
      compendiumLoaded = true;
      return monsterCompendium;
    }
  }
  return undefined;
}

async function checkMonsterCompendium() {
  compendiumLoaded = false;
  monsterCompendium = undefined;
  return getMonsterCompendium();
}

async function addNPCToCompendium(npc) {
  const compendium = await getMonsterCompendium();
  if (compendium) {
    // unlock the compendium for update/create
    compendium.configure({ locked: false });

    const index = await compendium.getIndex();
    const npcMatch = index.contents.find((entity) => entity.name.toLowerCase() === npc.name.toLowerCase());

    let compendiumNPC;
    if (npcMatch) {
      if (game.settings.get("ddb-importer", "munching-policy-update-existing")) {
        const existingNPC = await compendium.getDocument(npcMatch._id);

        const updateImages = game.settings.get("ddb-importer", "munching-policy-update-images");
        if (!updateImages && existingNPC.data.img !== "icons/svg/mystery-man.svg") {
          npc.img = existingNPC.data.img;
        }
        if (!updateImages && existingNPC.data.token.img !== "icons/svg/mystery-man.svg") {
          npc.token.img = existingNPC.data.token.img;
        }
        npc._id = npcMatch._id;
        await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .copySupportedItemFlags */ .uf)(existingNPC.data, npc);

        await existingNPC.deleteEmbeddedDocuments("Item", [], { deleteAll: true });
        compendiumNPC = await existingNPC.update(npc);
      }
    } else {
      // create the new npc
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Creating NPC actor ${npc.name}`);
      const options = {
        temporary: true,
        displaySheet: false,
      };
      const newNPC = await Actor.create(npc, options);
      compendiumNPC = await compendium.importDocument(newNPC);
    }

    // using compendium folders?
    await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .compendiumFolders */ .EX)(compendiumNPC, "npc");
  } else {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.error */ .Z.error("Error opening compendium, check your settings");
  }
}


async function getNPCImage(data) {
  // check to see if we have munched flags to work on
  if (!data.flags || !data.flags.monsterMunch || !data.flags.monsterMunch.img) {
    return false;
  }

  const updateImages = game.settings.get("ddb-importer", "munching-policy-update-images");
  if (!updateImages && data.img !== "icons/svg/mystery-man.svg") {
    return false;
  }

  let dndBeyondImageUrl = data.flags.monsterMunch.img;
  let dndBeyondTokenImageUrl = data.flags.monsterMunch.tokenImg;
  const useAvatarAsToken = game.settings.get("ddb-importer", "munching-policy-use-full-token-image");
  const useTokenAsAvatar = game.settings.get("ddb-importer", "munching-policy-use-token-avatar-image");
  if (useAvatarAsToken) {
    dndBeyondTokenImageUrl = dndBeyondImageUrl;
  } else if (useTokenAsAvatar) {
    dndBeyondImageUrl = dndBeyondTokenImageUrl;
  }

  const npcType = data.data.details.type.value;
  const genericNPCName = npcType.replace(/[^a-zA-Z]/g, "-").replace(/-+/g, "-").trim();
  const npcName = data.name.replace(/[^a-zA-Z]/g, "-").replace(/-+/g, "-").trim();

  if (!dndBeyondImageUrl && dndBeyondTokenImageUrl) dndBeyondImageUrl = dndBeyondTokenImageUrl;
  if (!dndBeyondTokenImageUrl && dndBeyondImageUrl) dndBeyondTokenImageUrl = dndBeyondImageUrl;

  if (dndBeyondImageUrl) {
    const ext = dndBeyondImageUrl.split(".").pop().split(/#|\?|&/)[0];

    if (dndBeyondImageUrl.endsWith(npcType + "." + ext)) {
      // eslint-disable-next-line require-atomic-updates
      data.img = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .getImagePath */ .al)(dndBeyondImageUrl, "npc-generic", genericNPCName);
    } else {
      // eslint-disable-next-line require-atomic-updates
      data.img = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .getImagePath */ .al)(dndBeyondImageUrl, "npc", npcName);
    }
  }

  // Currently token images always have to be downloaded. Not sure why.
  if (dndBeyondTokenImageUrl) {
    const tokenExt = dndBeyondTokenImageUrl.split(".").pop().split(/#|\?|&/)[0];

    if (dndBeyondTokenImageUrl.endsWith(npcType + "." + tokenExt)) {
      // eslint-disable-next-line require-atomic-updates
      data.token.img = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .getImagePath */ .al)(dndBeyondTokenImageUrl, "npc-generic-token", genericNPCName, true, false);
    } else {
      // eslint-disable-next-line require-atomic-updates
      data.token.img = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .getImagePath */ .al)(dndBeyondTokenImageUrl, "npc-token", npcName, true, false);
    }
  }

  // check avatar, if not use token image
  // eslint-disable-next-line require-atomic-updates
  if (!data.img && data.token.img) data.img = data.token.img;

  // final check if image comes back as null
  // eslint-disable-next-line require-atomic-updates
  if (data.img === null) data.img = "icons/svg/mystery-man.svg";
  // eslint-disable-next-line require-atomic-updates
  if (data.token.img === null) data.token.img = "icons/svg/mystery-man.svg";

  return true;
}

function getSpellEdgeCase(spell, type, spellList) {
  const edgeCases = spellList.edgeCases;
  const edgeCase = edgeCases.find((edge) => edge.name.toLowerCase() === spell.name.toLowerCase() && edge.type === type);

  if (edgeCase) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Spell edge case for ${spell.name}`);
    switch (edgeCase.edge.toLowerCase()) {
      case "self":
      case "self only":
        spell.data.target.type = "self";
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("spell target changed to self");
        break;
      // no default
    }
    spell.name = `${spell.name} (${edgeCase.edge})`;
    spell.data.description.chat = `<p><b>Special Notes: ${edgeCase.edge}.</b></p>\n\n${spell.data.description.chat}`;
    spell.data.description.value = `<p><b>Special Notes: ${edgeCase.edge}.</b></p>\n\n${spell.data.description.value}`;

    const diceSearch = /(\d+)d(\d+)/;
    const diceMatch = edgeCase.edge.match(diceSearch);
    if (diceMatch) {
      if (spell.data.damage.parts[0] && spell.data.damage.parts[0][0]) {
        spell.data.damage.parts[0][0] = diceMatch[0];
      } else if (spell.data.damage.parts[0]) {
        spell.data.damage.parts[0] = [diceMatch[0]];
      } else {
        spell.data.damage.parts = [[diceMatch[0]]];
      }
    }

    // save DC 12
    const saveSearch = /save DC (\d+)/;
    const saveMatch = edgeCase.edge.match(saveSearch);
    if (saveMatch) {
      spell.data.save.dc = saveMatch[1];
      spell.data.save.scaling = "flat";
    }

  }

  // remove material components?
  if (!spellList.material) {
    spell.data.materials = {
      value: "",
      consumed: false,
      cost: 0,
      supply: 0
    };
    spell.data.components.material = false;
  }

}

async function addSpells(data) {
  // check to see if we have munched flags to work on
  if (!data.flags || !data.flags.monsterMunch || !data.flags.monsterMunch.spellList) {
    return;
  }

  const spellList = data.flags.monsterMunch.spellList;
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Spell List for edgecases`, spellList);
  const atWill = spellList.atwill;
  const klass = spellList.class;
  const innate = spellList.innate;
  const pact = spellList.pact;

  if (atWill.length !== 0) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Retrieving at Will spells:", atWill);
    let spells = await retrieveSpells(atWill);
    spells = spells.filter((spell) => spell !== null).map((spell) => {
      if (spell.data.level == 0) {
        spell.data.preparation = {
          mode: "prepared",
          prepared: false,
        };
      } else {
        spell.data.preparation = {
          mode: "atwill",
          prepared: false,
        };
        spell.data.uses = {
          value: null,
          max: null,
          per: "",
        };
      }
      getSpellEdgeCase(spell, "atwill", spellList);
      return spell;
    });
    // eslint-disable-next-line require-atomic-updates
    data.items = data.items.concat(spells);
  }

  // class spells
  if (klass.length !== 0) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Retrieving class spells:", klass);
    let spells = await retrieveSpells(klass);
    spells = spells.filter((spell) => spell !== null).map((spell) => {
      spell.data.preparation = {
        mode: "prepared",
        prepared: true,
      };
      getSpellEdgeCase(spell, "class", spellList);
      return spell;
    });
    // eslint-disable-next-line require-atomic-updates
    data.items = data.items.concat(spells);
  }

  // pact spells
  if (pact.length !== 0) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Retrieving pact spells:", pact);
    let spells = await retrieveSpells(pact);
    spells = spells.filter((spell) => spell !== null).map((spell) => {
      spell.data.preparation = {
        mode: "pact",
        prepared: true,
      };
      getSpellEdgeCase(spell, "pact", spellList);
      return spell;
    });
    // eslint-disable-next-line require-atomic-updates
    data.items = data.items.concat(spells);
  }

  // innate spells
  if (innate.length !== 0) {
    // innate:
    // {name: "", type: "srt/lng/day", value: 0}
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Retrieving innate spells:", innate);
    const spells = await retrieveSpells(innate);
    const innateSpells = spells.filter((spell) => spell !== null)
      .map((spell) => {
        const spellInfo = innate.find((w) => w.name.toLowerCase() == spell.name.toLowerCase());
        if (spellInfo) {
          spell.data.preparation = {
            mode: "innate",
            prepared: true,
          };
          const per = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* .default.resets.find */ .Z.resets.find((d) => d.id == spellInfo.type);
          spell.data.uses = {
            value: spellInfo.value,
            max: spellInfo.value,
            per: (per && per.type) ? per.type : "day",
          };
          getSpellEdgeCase(spell, "innate", spellList);
        }
        return spell;
      });
    // eslint-disable-next-line require-atomic-updates
    data.items = data.items.concat(innateSpells);
  }
}

async function swapItems(data) {
  const swap = game.settings.get("ddb-importer", "munching-policy-monster-items");

  if (swap) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Replacing items...");
    // console.info(data.items);
    const updatedItems = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .getCompendiumItems */ .pI)(data.items, "inventory", null, false, true);
    const itemsToRemove = updatedItems.map((item) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`${item.name} to ${item.flags.ddbimporter.originalItemName}`);
      return { name: item.flags.ddbimporter.originalItemName, type: item.type };
    });
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Swapping items", itemsToRemove);
    // console.warn(itemsToRemove);
    const lessUpdatedItems = data.items.filter((item) =>
      !itemsToRemove.some((target) => item.name === target.name && item.type === target.type)
    );
    // console.log(lessUpdatedItems);
    const newItems = lessUpdatedItems.concat(updatedItems);
    // console.error(newItems);
    // eslint-disable-next-line require-atomic-updates
    data.items = newItems;

  }
}

async function linkResourcesConsumption(actor) {
  if (actor.items.some((item) => item.data?.recharge?.value)) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Resource linking for ${actor.name}`);
    actor.items.forEach((item) => {
      if (item.data?.recharge?.value) {
        const itemID = randomID(16);
        item._id = itemID;
        item.data.consume = {
          type: "charges",
          target: itemID,
          amount: null,
        };
      }
    });
  }
  return actor;
}

// async function buildNPC(data, srdIconLibrary, iconMap) {
async function buildNPC(data, temporary = true, update = false, handleBuild = false) {
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Importing Images");
  await getNPCImage(data);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Importing Spells");
  await addSpells(data);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Checking Items");
  await swapItems(data);

  // DAE
  const daeInstalled = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.isModuleInstalledAndActive */ .Z.isModuleInstalledAndActive("dae") &&
    (_utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.isModuleInstalledAndActive */ .Z.isModuleInstalledAndActive("Dynamic-Effects-SRD") || _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.isModuleInstalledAndActive */ .Z.isModuleInstalledAndActive("midi-srd"));
  const daeCopy = game.settings.get("ddb-importer", "munching-policy-dae-copy");
  if (daeInstalled && daeCopy) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__/* .munchNote */ .ep)(`Importing DAE Item for ${data.name}`);
    // eslint-disable-next-line require-atomic-updates
    data.items = await (0,_dae_js__WEBPACK_IMPORTED_MODULE_5__/* .migrateItemsDAESRD */ .TH)(data.items);
  }

  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Importing Icons");
  // eslint-disable-next-line require-atomic-updates
  data.items = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .updateIcons */ .wo)(data.items, false, true, data.name);
  data = await linkResourcesConsumption(data);

  if (handleBuild) {
    // create the new npc
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Creating NPC actor");
    const options = {
      temporary: temporary,
      displaySheet: false,
    };
    if (update) {
      const npc = game.actors.get(data._id);
      await npc.deleteEmbeddedDocuments("Item", [], { deleteAll: true });
      await Actor.updateDocuments([data]);
      return npc;
    } else {
      const npc = await Actor.create(data, options);
      return npc;
    }

  } else {
    return data;
  }

}

async function parseNPC (data) {
  let npc = await buildNPC(data);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Adding actor ${npc.name} to compendium`);
  await addNPCToCompendium(npc);
  return npc;
}

function addNPC(data) {
  return new Promise((resolve, reject) => {
    parseNPC(data)
      .then((npc) => {
        resolve(npc);
      })
      .catch((error) => {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.error */ .Z.error(`error parsing NPC: ${error} ${data.name}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.error */ .Z.error(error.stack);
        reject(error);
      });
  });
}

async function generateIconMap(monsters) {
  let promises = [];

  const srdIcons = game.settings.get("ddb-importer", "munching-policy-use-srd-icons");
  // eslint-disable-next-line require-atomic-updates
  if (srdIcons) {
    const srdIconLibrary = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .getSRDIconLibrary */ .CW)();
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__/* .munchNote */ .ep)(`Updating SRD Icons`, true);
    let itemMap = [];

    monsters.forEach((monster) => {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__/* .munchNote */ .ep)(`Processing ${monster.name}`);
      promises.push(
        (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .copySRDIcons */ .u4)(monster.items, srdIconLibrary, itemMap).then((items) => {
          monster.items = items;
        })
      );
    });
  }

  return Promise.all(promises);
}

function copyExistingMonsterImages(monsters, existingMonsters) {
  const updated = monsters.map((monster) => {
    const existing = existingMonsters.find((m) => monster.name === m.name);
    if (existing) {
      monster.img = existing.img;
      monster.token.img = existing.token.img;
      return monster;
    } else {
      return monster;
    }
  });
  return updated;
}


/***/ }),

/***/ 184:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RS": () => (/* binding */ ABILITIES),
/* harmony export */   "BA": () => (/* binding */ getAbilities),
/* harmony export */   "Tx": () => (/* binding */ getAbilityMods)
/* harmony export */ });
const ABILITIES = [
  { id: 1, value: "str", long: "strength" },
  { id: 2, value: "dex", long: "dexterity" },
  { id: 3, value: "con", long: "constitution" },
  { id: 4, value: "int", long: "intelligence" },
  { id: 5, value: "wis", long: "wisdom" },
  { id: 6, value: "cha", long: "charisma" },
];

//     "abilities": {
  // "str": {
  //   "value": 27,
  //   "proficient": 0,
  //   "min": 3,
  //   "mod": 8,
  //   "save": 8,
  //   "prof": 0,
  //   "saveBonus": 0,
  //   "checkBonus": 0,
  //   "dc": 23
  // },
  // "dex": {
  //   "value": 14,
  //   "proficient": 1,
  //   "min": 3,
  //   "mod": 2,
  //   "save": 9,
  //   "prof": 7,
  //   "saveBonus": 0,
  //   "checkBonus": 0,
  //   "dc": 17
  // },
/**
 * Retrieves character abilities, including proficiency on saving throws
 * @param {obj} monster JSON Import
 * @param {obj} DDB_CONFIG config
 */
function getAbilities(abilities, monster, DDB_CONFIG) {
  // go through every ability
  ABILITIES.forEach((ability) => {
    const value = monster.stats.find((stat) => stat.statId === ability.id).value || 0;
    const proficient = monster.savingThrows.find((stat) => stat.statId === ability.id) ? 1 : 0;
    const proficiencyBonus = DDB_CONFIG.challengeRatings.find((cr) => cr.id == monster.challengeRatingId).proficiencyBonus;
    const mod = DDB_CONFIG.statModifiers.find((s) => s.value == value).modifier;

    abilities[ability.value]['value'] = value;
    abilities[ability.value]['proficient'] = proficient;
    abilities[ability.value]['mod'] = mod;

    if (proficient) {
      abilities[ability.value]['prof'] = proficiencyBonus;
      abilities[ability.value]['saveBonus'] = monster.savingThrows.find((stat) => stat.statId === ability.id).bonusModifier || 0;
      abilities[ability.value]['save'] = mod + proficiencyBonus + abilities[ability.value]['saveBonus'];
    }

    abilities[ability.value]['dc'] = mod + proficiencyBonus + 8;
  });

  return abilities;
}


function getAbilityMods(monster, DDB_CONFIG) {
  let abilities = {};

  ABILITIES.forEach((ability) => {
    const value = monster.stats.find((stat) => stat.statId === ability.id).value || 0;
    const mod = DDB_CONFIG.statModifiers.find((s) => s.value == value).modifier;
    abilities[ability.value] = mod;
  });

  return abilities;

}


/***/ }),

/***/ 519:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "U": () => (/* binding */ parseMonsters)
});

;// CONCATENATED MODULE: ./src/muncher/monster/senses.js
function getTextSenses(monster) {
  return monster.sensesHtml;
}

const SENSE_MAP = {
  Blindsight: "dimSight",
  Darkvision: "dimSight",
  Tremorsense: "brightSight",
  Truesight: "brightSight",
  Unknown: "dimsight",
};

//   "senses": [{
//   "id": 1,
//   "entityTypeId": 668550506,
//   "name": "Blindsight"
// }, {
//   "id": 2,
//   "entityTypeId": 668550506,
//   "name": "Darkvision"
// }, {
//   "id": 3,
//   "entityTypeId": 668550506,
//   "name": "Tremorsense"
// }, {
//   "id": 4,
//   "entityTypeId": 668550506,
//   "name": "Truesight"
// }, {
//   "id": 5,
//   "entityTypeId": 668550506,
//   "name": "Unknown"
// }],

function getTokenSenses(token, monster, DDB_CONFIG) {
  const senseLookup = DDB_CONFIG.senses;

  monster.senses.forEach((sense) => {
    const senseMatch = senseLookup.find((l) => l.id == sense.senseId);
    if (senseMatch && sense.notes) {
      const senseType = SENSE_MAP[senseMatch.name];
      const rangeMatch = sense.notes.trim().match(/^(\d+)/);
      if (rangeMatch) {
        token[senseType] = rangeMatch[1];
      }
    }
  });

  return token;
}


function getSenses(monster, DDB_CONFIG) {
  let senses = {
    darkvision: 0,
    blindsight: 0,
    tremorsense: 0,
    truesight: 0,
    units: "ft",
    special: ""
  };
  const senseLookup = DDB_CONFIG.senses;

  monster.senses.forEach((sense) => {
    const senseMatch = senseLookup.find((l) => l.id == sense.senseId);
    if (senseMatch && sense.notes && senseMatch.name.toLowerCase() in senses) {
      const rangeMatch = sense.notes.trim().match(/^(\d+)/);
      if (rangeMatch) {
        senses[senseMatch.name.toLowerCase()] = parseInt(rangeMatch[1]);
      } else {
        senses.special += `${senseMatch.name}: ${sense.notes}; `;
      }
    } else {
      senses.special += `${senseMatch.name}: ${sense.notes}; `;
    }
  });

  return senses;

}

// "senses": [
//   {
//       "senseId": 1,
//       "notes": "60 ft."
//   },
//   {
//       "senseId": 2,
//       "notes": "120 ft."
//   }
// ],

// "senses": [{
//   "senseId": 1,
//   "notes": " 60 ft. (blind beyond this radius)"
// }],


;// CONCATENATED MODULE: ./src/muncher/monster/conditions.js
const CONDITION_TYPES = [
  { name: "Blinded", value: "blinded" },
  { name: "Charmed", value: "charmed" },
  { name: "Deafened", value: "deafened" },
  { name: "Exhaustion", value: "exhaustion" },
  { name: "Frightened", value: "frightened" },
  { name: "Grappled", value: "grappled" },
  { name: "Incapacitated", value: "incapacitated" },
  { name: "Invisible", value: "invisible" },
  { name: "Paralyzed", value: "paralyzed" },
  { name: "Petrified", value: "petrified" },
  { name: "Poisoned", value: "poisoned" },
  { name: "Prone", value: "prone" },
  { name: "Restrained", value: "restrained" },
  { name: "Stunned", value: "stunned" },
  { name: "Unconscious", value: "unconscious" },
  { name: "Diseased", value: "diseased" },
  { name: "Disease", value: "diseased" },
];

const DAMAGE_TYPES = [
  "acid",
  "bludgeoning",
  "cold",
  "fire",
  "force",
  "lightning",
  "necrotic",
  "piercing",
  "poison",
  "psychic",
  "radiant",
  "slashing",
  "thunder",
];


function getAdjustmentsConfig(type, DDB_CONFIG) {
  const damageAdjustments = DDB_CONFIG.damageAdjustments;

  switch (type) {
    case "resistances":
      return damageAdjustments.filter((adj) => adj.type == 1);
    case "immunities":
      return damageAdjustments.filter((adj) => adj.type == 2);
    case "vulnerabilities":
      return damageAdjustments.filter((adj) => adj.type == 3);
    case "conditions":
      return DDB_CONFIG.conditions.map((condition) => {
        return {
          id: condition.definition.id,
          name: condition.definition.name,
          type: condition.definition.type,
          slug: condition.definition.slug,
        };
      });
    default:
      return null;
  }
}

function getDamageAdjustments(monster, type, DDB_CONFIG) {
  const config = getAdjustmentsConfig(type, DDB_CONFIG);

  let values = [];
  let custom = [];

  monster.damageAdjustments.forEach((adj) => {
    const adjustment = config.find((cadj) => adj === cadj.id);
    if (adjustment && DAMAGE_TYPES.includes(adjustment.name.toLowerCase())) {
      values.push(adjustment.name.toLowerCase());
    } else if (adjustment && adjustment.slug === "bludgeoning-piercing-and-slashing-from-nonmagical-attacks") {
      values.push("physical");
    } else if (adjustment) {
      custom.push(adjustment.name);
    }
  });

  const adjustments = {
    value: values,
    custom: custom.join("; "),
  };

  return adjustments;
}

function getDamageImmunities(monster, DDB_CONFIG) {
  return getDamageAdjustments(monster, "immunities", DDB_CONFIG);
}

function getDamageResistances(monster, DDB_CONFIG) {
  return getDamageAdjustments(monster, "resistances", DDB_CONFIG);
}
function getDamageVulnerabilities(monster, DDB_CONFIG) {
  return getDamageAdjustments(monster, "vulnerabilities", DDB_CONFIG);
}
function getConditionImmunities(monster, DDB_CONFIG) {
  const config = getAdjustmentsConfig("conditions", DDB_CONFIG);

  let values = [];
  let custom = [];

  monster.conditionImmunities.forEach((adj) => {
    const adjustment = config.find((cadj) => adj === cadj.id);
    const valueAdjustment = CONDITION_TYPES.find((condition) => condition.name.toLowerCase() == adjustment.name.toLowerCase());
    if (adjustment && valueAdjustment) {
      values.push(valueAdjustment.value);
    } else if (adjustment) {
      custom.push(adjustment.name);
    }
  });

  const adjustments = {
    value: values,
    custom: custom.join("; "),
  };

  return adjustments;
}

// EXTERNAL MODULE: ./src/muncher/monster/abilities.js
var monster_abilities = __webpack_require__(184);
// EXTERNAL MODULE: ./src/muncher/monster/skills.js
var skills = __webpack_require__(415);
;// CONCATENATED MODULE: ./src/muncher/monster/languages.js
const LANGUAGES = [
  { name: "Common", value: "common" },
  { name: "Aarakocra", value: "aarakocra" },
  { name: "Abyssal", value: "abyssal" },
  { name: "Aquan", value: "aquan" },
  { name: "Auran", value: "auran" },
  { name: "Celestial", value: "celestial" },
  { name: "Deep Speech", value: "deep" },
  { name: "Draconic", value: "draconic" },
  { name: "Druidic", value: "druidic" },
  { name: "Dwarvish", value: "dwarvish" },
  { name: "Elvish", value: "elvish" },
  { name: "Giant", value: "giant" },
  { name: "Gith", value: "gith" },
  { name: "Gnomish", value: "gnomish" },
  { name: "Goblin", value: "goblin" },
  { name: "Gnoll", value: "gnoll" },
  { name: "Halfling", value: "halfling" },
  { name: "Ignan", value: "ignan" },
  { name: "Infernal", value: "infernal" },
  { name: "Orc", value: "orc" },
  { name: "Primordial", value: "primordial" },
  { name: "Terran", value: "terran" },
  { name: "Sylvan", value: "sylvan" },
  { name: "Thieves' Cant", value: "cant" },
  { name: "Thievesâ€™ Cant", value: "cant" },
  { name: "Undercommon", value: "undercommon" },
];


//      "languages": {
//   "value": [
//     "common",
//     "draconic"
//   ],
//   "custom": ""
// },
function getLanguages (monster, DDB_CONFIG) {
  const config = DDB_CONFIG.languages;

  let values = [];
  let custom = [];

  monster.languages.forEach((lng) => {
    const language = config.find((cfg) => lng.languageId == cfg.id);
    const foundryLanguage = LANGUAGES.find((lang) => lang.name == language.name);
    if (foundryLanguage && lng.notes == '') {
      values.push(foundryLanguage.value);
    } else {
      const notes = (lng.notes !== '') ? ` ${lng.notes}` : "";
      custom.push(language.name + notes);
    }
  });

  custom.push(monster.languageNote);

  const languages = {
    value: values,
    custom: custom.join("; "),
  };

  return languages;
}

;// CONCATENATED MODULE: ./src/muncher/monster/hp.js


// "hp": {
//   "value": 0,
//   "min": 0,
//   "max": 0,
//   "temp": 0,
//   "tempmax": 0,
//   "formula": ""
// },

// "hp": {
//   "value": 367,
//   "min": 0,
//   "max": 367,
//   "temp": 0,
//   "tempmax": 0,
//   "formula": "21d20 + 147"
// },

// data.
// "hitPointDice": {
//   "diceCount": 21,
//   "diceValue": 20,
//   "diceMultiplier": 0,
//   "fixedValue": 147,
//   "diceString": "21d20 + 147"
// },


function getHitPoints (monster, removedHitPoints, temporaryHitPoints) {
  const hitPointDice = monster.hitPointDice;
  // const maxHP = (hitPointDice.diceCount * hitPointDice.diceValue) + hitPointDice.fixedValue;

  const hp = {
    "value": monster.averageHitPoints - removedHitPoints,
    "min": 0,
    "max": monster.averageHitPoints,
    "temp": temporaryHitPoints,
    "tempmax": 0,
    "formula": hitPointDice.diceString,
  };

  return hp;
}

;// CONCATENATED MODULE: ./src/muncher/monster/movement.js
// "movements": [
//   {
//     "movementId": 1,
//     "speed": 40,
//     "notes": null
// },
// {
//     "movementId": 4,
//     "speed": 80,
//     "notes": null
// },
// {
//     "movementId": 5,
//     "speed": 40,
//     "notes": null
// }
// ],

// "speed": {
//   "value": "40 ft.",
//   "special": "Fly 80 ft., Swim 40 ft."
// },
function getSpeed (monster, DDB_CONFIG) {
  const movementConfig = DDB_CONFIG.movements;
  const monsterMovements = monster.movements;

  let values = "";
  let special = [];

  let movements = {
    burrow: 0,
    climb: 0,
    fly: 0,
    swim: 0,
    walk: 0,
    units: "ft",
    hover: false,
  };

  monsterMovements.forEach((monsterMovement) => {
    const movement = movementConfig.find((mv) => mv.id == monsterMovement.movementId);
    movements[movement.name.toLowerCase()] = monsterMovement.speed;

    if (monsterMovement.notes && monsterMovement.notes.toLowerCase().includes('hover')) movements.hover = true;

    if (movement.name == "Walk") {
      values = `${monsterMovement.speed}ft.`;
      if (monsterMovement.notes !== null) {
        special.push(`${monsterMovement.speed}ft. ${movement.description} (${monsterMovement.notes})`);
      }
    } else {
      const noteMovement = monsterMovement.notes ? ` ${monsterMovement.notes}` : "";
      const specialMovement = `${monsterMovement.speed}ft ${movement.description}${noteMovement}`;
      special.push(specialMovement);
    }
  });

  const speed = {
    value: values,
    special: special.join(", "),
  };

  return {
    speed: speed,
    movement: movements,
  };

}

;// CONCATENATED MODULE: ./src/muncher/monster/size.js
// "creatureSizes": [{
//   "id": 2,
//   "entityTypeId": 127108918,
//   "name": "Tiny",
//   "weightType": 1
// }, {


//   "traits": {
//     "size": "grg",


//     "sizeId": 7,

const SIZES = [
  { name: "Tiny", value: "tiny", size: 0.5 },
  { name: "Small", value: "sm", size: 0.8 },
  { name: "Medium", value: "med", size: 1 },
  { name: "Large", value: "lg", size: 2 },
  { name: "Huge", value: "huge", size: 3 },
  { name: "Gargantuan", value: "grg", size: 4 },
];

function getSizeFromId(sizeId, DDB_CONFIG) {
  const size = DDB_CONFIG.creatureSizes.find((s) => s.id == sizeId).name;
  const sizeData = SIZES.find((s) => size == s.name);
  return sizeData;
}

function getSize (monster, DDB_CONFIG) {
  const sizeData = getSizeFromId(monster.sizeId, DDB_CONFIG);
  let token = {
    scale: 1,
    value: sizeData.size,
  };
  if (token.value < 1) {
    token.scale = token.value;
    token.value = 1;
  }

  const data = {
    value: sizeData.value,
    token: token,
  };

  return data;

}

;// CONCATENATED MODULE: ./src/muncher/monster/source.js
function getSource(monster, DDB_CONFIG) {
  const fullSource = game.settings.get("ddb-importer", "use-full-source");
  const sourceObject = DDB_CONFIG.sources.find((cnf) => cnf.id == monster.sourceId);
  const sourceBook = (sourceObject)
    ? (fullSource) ? sourceObject.description : sourceObject.name
    : "Homebrew";
  const page = (monster.sourcePageNumber) ? ` pg ${monster.sourcePageNumber}` : "";
  const source = `${sourceBook}${page}`;
  return source;
}

;// CONCATENATED MODULE: ./src/muncher/monster/environments.js

function getEnvironments(monster, DDB_CONFIG) {
  const environments = monster.environments.filter((env) =>
    DDB_CONFIG.environments.some((c) => env == c.id)
  ).map((env) => {
    return DDB_CONFIG.environments.find((c) => env == c.id).name;
  });

  return environments.join(", ");
}

// EXTERNAL MODULE: ./src/utils.js
var utils = __webpack_require__(555);
;// CONCATENATED MODULE: ./src/muncher/monster/templates/feat.js


function newFeat(name) {
  let feat = {
    name: name,
    type: "feat",
    data: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("feat")),
    flags: {
      ddbimporter: {
        dndbeyond: {
        },
      },
    },
  };
  return feat;
};

// EXTERNAL MODULE: ./src/muncher/table.js + 2 modules
var table = __webpack_require__(967);
;// CONCATENATED MODULE: ./src/muncher/monster/features/lair.js




// "lairDescription": "<p>Black dragons dwell in swamps on the frayed edges of civilization. A black dragon&rsquo;s lair is a dismal cave, grotto, or ruin that is at least partially flooded, providing pools where the dragon rests, and where its victims can ferment. The lair is littered with the acid-pitted bones of previous victims and the fly-ridden carcasses of fresh kills, watched over by crumbling statues. Centipedes, scorpions, and snakes infest the lair, which is filled with the stench of death and decay.</p>\r\n<h4>Lair Actions</h4>\r\n<p>On initiative count 20 (losing initiative ties), the dragon takes a lair action to cause one of the following effects; the dragon can&rsquo;t use the same effect two rounds in a row:</p>\r\n<ul>\r\n<li>Pools of water that the dragon can see within 120 feet of it surge outward in a grasping tide. Any creature on the ground within 20 feet of such a pool must succeed on a DC 15 Strength saving throw or be pulled up to 20 feet into the water and knocked prone.</li>\r\n<li>A cloud of swarming insects fills a 20-foot-radius sphere centered on a point the dragon chooses within 120 feet of it. The cloud spreads around corners and remains until the dragon dismisses it as an action, uses this lair action again, or dies. The cloud is lightly obscured. Any creature in the cloud when it appears must make on a DC 15 Constitution saving throw, taking 10 (3d6) piercing damage on a failed save, or half as much damage on a successful one. A creature that ends its turn in the cloud takes 10 (3d6) piercing damage.</li>\r\n<li>Magical darkness spreads from a point the dragon chooses within 60 feet of it, filling a 15-foot-radius sphere until the dragon dismisses it as an action, uses this lair action again, or dies. The darkness spreads around corners. A creature with darkvision can&rsquo;t see through this darkness, and nonmagical light can&rsquo;t illuminate it. If any of the effect&rsquo;s area overlaps with an area of light created by a spell of 2nd level or lower, the spell that created the light is dispelled.</li>\r\n</ul>\r\n<h4>Regional Effects</h4>\r\n<p>The region containing a legendary black dragon&rsquo;s lair is warped by the dragon&rsquo;s magic, which creates one or more of the following effects:</p>\r\n<ul>\r\n<li>The land within 6 miles of the lair takes twice as long as normal to traverse, since the plants grow thick and twisted, and the swamps are thick with reeking mud.</li>\r\n<li>Water sources within 1 mile of the lair are supernaturally fouled. Enemies of the dragon that drink such water regurgitate it within minutes.<br />Fog lightly obscures the land within 6 miles of the lair.</li>\r\n</ul>\r\n<p>If the dragon dies, vegetation remains as it has grown, but other effects fade over 1d10 days.</p>",

function addPlayerDescription(monster, action) {
  let playerDescription = `</section>\nThe ${monster.name} uses a ${action.name}!`;
  return playerDescription;
}

function getLairActions(monster, DDB_CONFIG) {
  let resource = {
    value: false,
    initiative: null
  };

  if (!monster.hasLair && monster.lairDescription == "") {
    return {
      resource: resource,
      lairActions: [],
    };
  }

  const updateExisting = game.settings.get("ddb-importer", "munching-policy-update-existing");
  const hideDescription = game.settings.get("ddb-importer", "munching-policy-hide-description");

  let dom = new DocumentFragment();
  $.parseHTML(monster.lairDescription).forEach((element) => {
    dom.appendChild(element);
  });

  dom.childNodes.forEach((node) => {
    if (node.textContent == "\n" || node.textContent == "\r\n") {
      dom.removeChild(node);
    }
  });

  let dynamicActions = [];

  let defaultAction = newFeat("Lair Actions");
  defaultAction.data.activation.type = "lair";
  defaultAction.data.source = getSource(monster, DDB_CONFIG);
  dynamicActions.push(defaultAction);

  dom.querySelectorAll("h4").forEach((node) => {
    const name = node.textContent.trim();
    let action = newFeat(name);
    if (node.textContent == "Lair Actions" || node.textContent == "") {
      return;
    }
    action.data.source = getSource(monster, DDB_CONFIG);
    if (action.name !== "") dynamicActions.push(action);
  });

  dom.querySelectorAll("h3").forEach((node) => {
    const name = node.textContent.trim();
    let action = newFeat(name);
    if (node.textContent == "Lair Actions" || action.name == "") {
      return;
    }
    action.data.source = getSource(monster, DDB_CONFIG);
    if (action.name !== "") dynamicActions.push(action);
  });

  let actionType = "Lair Actions";
  let action = dynamicActions.find((act) => act.name == actionType);

  if (!action) {
    action = dynamicActions[0];
  } else if (hideDescription) {
    action.data.description.value = "<section class=\"secret\">\n";
  }

  dom.childNodes.forEach((node) => {
    // const switchAction = dynamicActions.find((act) => act.name == node.textContent);
    const nodeName = node.textContent.split('.')[0].trim();
    const switchAction = dynamicActions.find((act) => nodeName === act.name);
    let startFlag = false;
    if (switchAction) {
      actionType = node.textContent;
      if (action.data.description.value !== "" && hideDescription) {
        action.data.description.value += addPlayerDescription(monster, action);
      }
      action = switchAction;
      if (action.data.description.value === "") startFlag = true;
      if ((action.data.description.value === "" || action.name === "Lair Actions") && hideDescription) {
        action.data.description.value += "<section class=\"secret\">\n";
      }
    }
    if (node.outerHTML) {
      let outerHTML = node.outerHTML;
      if (switchAction && startFlag) {
        outerHTML = outerHTML.replace(`${nodeName}.`, "");
      }
      action.data.description.value += outerHTML;
    }

    const initiativeMatch = node.textContent.match(/initiative count (\d+)/);
    if (initiativeMatch) {
      resource = {
        value: true,
        initiative: parseInt(initiativeMatch[1]),
      };
    }
  });

  if (action && action.data.description.value !== "" && hideDescription) {
    action.data.description.value += addPlayerDescription(monster, action);
  }
  if (action) action.data.description.value = (0,table/* generateTable */.p)(monster.name, action.data.description.value, updateExisting);

  return {
    resource: resource,
    lairActions: dynamicActions,
  };
}

;// CONCATENATED MODULE: ./src/muncher/monster/dict.js
const DICTIONARY = {
  weapons: [
    { name: "Hand Crossbow", actionType: "rwak", weaponType: "martialR", properties: { amm: true, lgt: true, lod: true } },
    { name: "Glaive", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, rch: true, two: true } },
    { name: "Dagger", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true, fin: true, thr: true } },
    { name: "Longsword", actionType: "mwak", weaponType: "martialM", properties: { ver: true } },
    { name: "Club", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true } },
    { name: "Greatclub", actionType: "mwak", weaponType: "simpleM", properties: { two: true } },
    { name: "Handaxe", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true, thr: true } },
    { name: "Javelin", actionType: "mwak", weaponType: "simpleM", properties: { thr: true } },
    { name: "Light Hammer", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true, thr: true } },
    { name: "Mace", actionType: "mwak", weaponType: "simpleM", properties: {} },
    { name: "Quarterstaff", actionType: "mwak", weaponType: "simpleM", properties: { ver: true } },
    { name: "Sickle", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true } },
    { name: "Spear", actionType: "mwak", weaponType: "simpleM", properties: { thr: true, ver: true } },
    { name: "Light Crossbow", actionType: "rwak", weaponType: "simpleR", properties: { amm: true, lod: true, two: true } },
    { name: "Dart", actionType: "rwak", weaponType: "simpleR", properties: { fin: true, thr: true } },
    { name: "Shortbow", actionType: "rwak", weaponType: "simpleR", properties: { amm: true, two: true } },
    { name: "Sling", actionType: "rwak", weaponType: "simpleR", properties: { amm: true } },
    { name: "Battleaxe", actionType: "mwak", weaponType: "martialM", properties: { ver: true } },
    { name: "Flail", actionType: "mwak", weaponType: "martialM", properties: {} },
    { name: "Greataxe", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true } },
    { name: "Greatsword", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true } },
    { name: "Halberd", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true, rch: true } },
    { name: "Lance", actionType: "mwak", weaponType: "martialM", properties: { rch: true, spc: true } },
    { name: "Maul", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true } },
    { name: "Morningstar", actionType: "mwak", weaponType: "martialM", properties: {} },
    { name: "Pike", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true, rch: true } },
    { name: "Rapier", actionType: "mwak", weaponType: "martialM", properties: { fin: true } },
    { name: "Scimitar", actionType: "mwak", weaponType: "martialM", properties: { fin: true, lgt: true } },
    { name: "Shortsword", actionType: "mwak", weaponType: "martialM", properties: { fin: true, lgt: true } },
    { name: "Trident", actionType: "mwak", weaponType: "martialM", properties: { ver: true, thr: true } },
    { name: "War Pick", actionType: "mwak", weaponType: "martialM", properties: {} },
    { name: "Warhammer", actionType: "mwak", weaponType: "martialM", properties: { ver: true } },
    { name: "Whip", actionType: "mwak", weaponType: "martialM", properties: { fin: true, rch: true } },
    { name: "Blowgun", actionType: "rwak", weaponType: "martialR", properties: { amm: true, lod: true } },
    { name: "Heavy Crossbow", actionType: "rwak", weaponType: "martialR", properties: { amm: true, hvy: true, two: true, lod: true } },
    { name: "Longbow", actionType: "rwak", weaponType: "martialR", properties: { amm: true, hvy: true, two: true } },
    { name: "Net", actionType: "mwak", weaponType: "martialR", properties: { spc: true, thw: true } },
    { name: "Boomerang", actionType: "rwak", weaponType: "simpleR", properties: { amm: true } },
    { name: "Yklwa", actionType: "rwak", weaponType: "simpleR", properties: { amm: true } },
    { name: "Pistol", actionType: "rwak", weaponType: "martialR", properties: { amm: true, lod: true, fir: true } },
    { name: "Musket", actionType: "rwak", weaponType: "martialR", properties: { amm: true, lod: true, fir: true } },
    { name: "Bite", actionType: "mwak", weaponType: "natural", properties: {} },
    { name: "Claw", actionType: "mwak", weaponType: "natural", properties: {} },
    { name: "Tail", actionType: "mwak", weaponType: "natural", properties: {} },
    { name: "Wing", actionType: "mwak", weaponType: "natural", properties: {} },
    { name: "Slam", actionType: "mwak", weaponType: "natural", properties: {} },
    { name: "Rake", actionType: "mwak", weaponType: "natural", properties: {} },
    { name: "Beak", actionType: "mwak", weaponType: "natural", properties: {} },
    { name: "Tentacles", actionType: "mwak", weaponType: "natural", properties: {} },
  ],
  resets: [
    { id: 1, value: "sr" },
    { id: "ShortRest", value: "sr" },
    { id: "Short", value: "sr" },
    { id: "short", value: "sr" },
    { id: 2, value: "lr" },
    { id: "LongRest", value: "lr" },
    { id: "Long", value: "lr" },
    { id: "long", value: "lr" },
    { id: "Day", value: "day" },
    { id: "day", value: "day" },
    { id: "Dawn", value: "day" },
    { id: "dusk", value: "day" },
    { id: "Consumable", value: "charges" },
    { id: "Other", value: "charges" },
  ],
};
/* harmony default export */ const dict = (DICTIONARY);


// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(259);
;// CONCATENATED MODULE: ./src/muncher/monster/utils.js





// replaces matchAll, requires a non global regexp
function reMatchAll(regexp, string) {
  const matches = string.match(new RegExp(regexp, "gm"));
  if (matches) {
      let start = 0;
      return matches.map((group0) => {
          const match = group0.match(regexp);
          match.index = string.indexOf(group0, start);
          start = match.index;
          return match;
      });
  }
  return matches;
}

function damageModReplace(text, attackInfo, damageType) {
  let result;
  const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
  const damageHint = globalDamageHints && damageType ? `[${damageType}]` : "";
  const diceParse = utils/* default.parseDiceString */.Z.parseDiceString(text, null, damageHint);
  if (attackInfo.baseAbility) {
    const baseAbilityMod = attackInfo.abilities[attackInfo.baseAbility];
    const bonusMod = (diceParse.bonus && diceParse.bonus !== 0) ? diceParse.bonus - baseAbilityMod : "";
    const useMod = (diceParse.bonus && diceParse.bonus !== 0) ? " + @mod " : "";
    const reParse = utils/* default.diceStringResultBuild */.Z.diceStringResultBuild(diceParse.diceMap, diceParse.dice, bonusMod, useMod, damageHint);
    result = reParse.diceString;
  } else {
    result = diceParse.diceString;
  }

  return result;
}

// eslint-disable-next-line complexity
function getExtendedDamage(description, attackInfo) {
  let result = {
    damage: {
      parts: [],
      versatile: ""
    },
    save: {
      dc: null,
      ability: null
    },
    formula: "",
  };

  const hitIndex = description.indexOf("Hit:");
  let hit = description;
  if (hitIndex > 0) hit = description.slice(hitIndex);
  hit = hit.replace(/[â€“-â€“âˆ’]/g, "-");
  // console.warn(hit);
  // Using match with global modifier then map to regular match because RegExp.matchAll isn't available on every browser
  // eslint-disable-next-line no-useless-escape
  const damageExpression = new RegExp(/([\w]* )(?:([0-9]+))?(?:\s*\(?([0-9]*d[0-9]+(?:\s*[-+]\s*[0-9]+)?(?:\s+plus [^\)]+)?)\)?)?\s*([\w ]*?)\s*damage(?: when used with | if used with )?(\s?two hands|\s?at the start of)?/);
  const matches = reMatchAll(damageExpression, hit) || [];
  const regainExpression = new RegExp(/(regains)\s+?(?:([0-9]+))?(?: *\(?([0-9]*d[0-9]+(?:\s*[-+]\s*[0-9]+)??)\)?)?\s+hit\s+points/);
  const regainMatch = hit.match(regainExpression);

  // console.warn(matches);
  let versatile = false;
  for (let dmg of matches) {
    let other = false;
    if (dmg[1] == "DC " || dmg[4] == "hit points by this") {
        continue; // eslint-disable-line no-continue
    }
    // check for versatile
    if (dmg[1] == "or " || dmg[5] == "two hands") {
      versatile = true;
    }
    // check for other
    if (dmg[5] && dmg[5].trim() == "at the start of") other = true;
    const damage = dmg[3] || dmg[2];
    // Make sure we did match a damage
    if (damage) {
      const includesDiceRegExp = /[0-9]*d[0-9]+/;
      const includesDice = includesDiceRegExp.test(damage);
      const finalDamage = (attackInfo && includesDice)
          ? damageModReplace(damage.replace("plus", "+"), attackInfo, dmg[4])
          : damage.replace("plus", "+");
      // assumption here is that there is just one field added to versatile. this is going to be rare.
      if (other) {
        if (result.formula == "") result.formula = finalDamage;
      } else if (versatile) {
        if (result.damage.versatile == "") result.damage.versatile = finalDamage;
        // so things like the duergar mind master have oddity where we might want to use a different thing
        // } else {
        //   result.damage.versatile += ` + ${finalDamage}`;
        // }
      } else {
        result.damage.parts.push([finalDamage, dmg[4]]);
      }
    }
  }

  if (regainMatch) {
    const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
    const damageHint = globalDamageHints ? `[healing]` : "";
    result.damage.parts.push([utils/* default.parseDiceString */.Z.parseDiceString(regainMatch[3], null, damageHint).diceString, 'healing']);
  }

  const save = hit.match(/DC ([0-9]+) (.*?) saving throw/);
  if (save) {
      result.save.dc = save[1];
      result.save.ability = save[2].toLowerCase().substr(0, 3);
  } else {
      const escape = hit.match(/escape DC ([0-9]+)/);
      if (escape) {
        result.save.dc = escape[1];
        result.save.ability = "Escape";
      }
  }

  return result;
}

function getDamage(description) {
  const extendedDamage = getExtendedDamage(description);
  return extendedDamage.damage;
}

function getAction(text, type = "action") {
  let action = type;
  // fodunry doesn't support mythic actions
  if (type === "mythic") action = "special";
  // const actionAction = text.toLowerCase().match(/as an action/);
  const bonusAction = text.toLowerCase().match(/as a bonus action/);
  const reAction = text.toLowerCase().match(/as a reaction/);
  // e.g. mephit death
  const specialDie = text.toLowerCase().match(/dies/);
  if (bonusAction) {
    action = "bonus";
  } else if (reAction) {
    action = "reaction";
  } else if (specialDie) {
    action = "special";
  }
  return action;
}

function getUses(text, name = false) {
  let uses = {
    value: 0,
    max: 0,
    per: null,
  };

  const usesSearch = name ? /(\d+)\/(\w+)\)/ : /\((\d+)\/(\w+)\)/;
  const usesMatch = text.match(usesSearch);
  // console.log(usesMatch);
  if (usesMatch && usesMatch[2].toLowerCase() !== "turn") {
    uses.value = usesMatch[1];
    uses.max = usesMatch[1];
    uses.per = "day";
    const perMatch = dict.resets.find((reset) => reset.id === usesMatch[2]);
    if (perMatch) uses.per = perMatch.value;
  }

  return uses;
}

function getRecharge(text) {
  const matches = text.toLowerCase().match(/\(recharge ([0-9â€“â€“âˆ’-]+)\)/);
  if (matches) {
    const value = matches[1].replace(/[â€“â€“âˆ’-]/, "-").split("-").shift();
    return {
      value: parseInt(value),
      charged: true
    };
  }

  return {
    value: null,
    charged: null
  };
}

function getActivation(text) {
  const matches = text.toLowerCase().match(/\(costs ([0-9]+) actions\)/i);
  if (matches) return parseInt(matches[1]);
  return null;
}

function getFeatSave(text, save) {
  const saveSearch = /DC (\d+) (\w+) saving throw/;
  const match = text.match(saveSearch);
  if (match) {
    save.dc = parseInt(match[1]);
    save.ability = match[2].toLowerCase().substr(0, 3);
    save.scaling = "flat";
  }
  return save;
}

function getReach(text) {
  const reachSearch = /reach\s*(\s*\d+\s*)\s*ft/;
  const match = text.match(reachSearch);
  if (match) {
    return match[1];
  }
  return "";
}

function getRange(text) {
  let range = {
    value: null,
    long: null,
    units: "",
  };

  const rangeSearch1 = /range\s*(\d+)\s*\s*\/\s*(\d+)\s*\s*ft/;
  const rangeSearch2 = /range\s*(\d+)\s*ft[.]*\s*\s*\/\s*(\d+)\s*\s*ft/;
  const rangeSearch3 = /range\s*(\d+)\s*\s*ft/;
  const reachSearch = /reach\s*(\d+)\s*\s*ft/;

  const matches1 = text.match(rangeSearch1);
  const matches2 = text.match(rangeSearch2);
  const matches3 = text.match(rangeSearch3);
  const reachMatch = text.match(reachSearch);

  if (matches1) {
    range.value = parseInt(matches1[1]);
    range.long = parseInt(matches1[2]);
    range.units = "ft";
  } else if (matches2) {
    range.value = parseInt(matches2[1]);
    range.long = parseInt(matches2[2]);
    range.units = "ft";
  } else if (matches3) {
    range.value = parseInt(matches3[1]);
    range.units = "ft";
  } else if (reachMatch) {
    range.value = parseInt(reachMatch[1]);
    range.units = "ft";
  }

  return range;
}

function checkAbility(abilities, mods, proficiencyBonus, target) {
  let result = {
    success: false,
    ability: null,
    proficient: null
  };

  for (const ability of abilities) {
    if (target == proficiencyBonus + mods[ability]) {
      result.success = true;
      result.ability = ability;
      result.proficient = true;
      break;
    } else if (result.toHit == mods[ability]) {
      result.success = true;
      result.ability = ability;
      result.proficient = false;
      break;
    }
  }

  return result;
}

function checkAbilities(abilities, mods, proficiencyBonus, target, negatives = false) {

  const results = abilities.map((ability) => {
    let result = {
      success: false,
      ability: ability,
      proficient: null,
      bonus: 0
    };
    if (target > proficiencyBonus + mods[ability]) {
      result.success = true;
      result.proficient = true;
      result.bonus = target - proficiencyBonus - mods[ability];
    } else if (result.toHit > mods[ability]) {
      result.success = true;
      result.proficient = false;
      result.bonus = target - mods[ability];
    } else if (negatives) {
      result.success = true;
      result.proficient = false;
      result.bonus = target - mods[ability];
    }
    return result;
  });

  return results;
}

function getWeaponAttack(resultData, proficiencyBonus) {
  let result = JSON.parse(JSON.stringify(resultData));
  const abilities = ["str", "dex", "int", "wis", "cha", "con"];
  let initialAbilities = [];
  let weaponAbilities = ["str", "dex"];
  let spellAbilities = ["cha", "wis", "int"];

  const lookup = dict.weapons.find((weapon) => result.name.startsWith(weapon.name));
  // we have a weapon name match so we can infer a bit more
  if (lookup) {
    for (const [key, value] of Object.entries(lookup.properties)) {
      // logger.info(`${key}: ${value}`);
      result.properties[key] = value;
    }
    const versatileWeapon = result.properties.ver && result.abilities['dex'] > result.abilities['str'];
    if (versatileWeapon || lookup.actionType == "rwak") {
      weaponAbilities = ["dex"];
    } else if (lookup.actionType == "mwak") {
      weaponAbilities = ["str"];
    }
    result.weaponType = lookup.weaponType;
  }

  if (result.spellAttack) {
    initialAbilities = spellAbilities;
  } else if (result.weaponAttack) {
    initialAbilities = weaponAbilities;
  } else {
    initialAbilities = abilities;
  }

  if (result.weaponAttack || result.spellAttack) {
    // check most likely initial attacks - str and dex based weapon, mental for spell
    const checkInitialAbilities = checkAbility(initialAbilities, result.abilities, proficiencyBonus, result.toHit);
    if (checkInitialAbilities.success) {
      result.baseAbility = checkInitialAbilities.ability;
      result.proficient = checkInitialAbilities.proficient;
    }

    // okay lets see if its one of the others then!
    if (!result.baseAbility) {
      const checkAllAbilities = checkAbility(abilities, result.abilities, proficiencyBonus, result.toHit);
      if (checkAllAbilities.success) {
        result.baseAbility = checkAllAbilities.ability;
        result.proficient = checkAllAbilities.proficient;
      }
    }

    // okay, some oddity, maybe magic bonus, lets calculate one!
    // we are going to assume it's dex or str based.
    if (!result.baseAbility) {
      const magicAbilities = checkAbilities(initialAbilities, result.abilities, proficiencyBonus, result.toHit);
      // logger.info(magicAbilities);

      const filteredAbilities = magicAbilities.filter((ab) => ab.success == true).sort((a, b) => {
        if (a.proficient == !b.proficient) return -1;
        if (b.proficient == !a.proficient) return 1;
        if (a.proficient == b.proficient) {
          if (a.bonus > b.bonus) return 1;
          if (b.bonus > a.bonus) return -1;
        }
        return 0;
      });

      // fine lets use the first hit
      if (filteredAbilities.length >= 1 && filteredAbilities[0].success) {
        result.baseAbility = filteredAbilities[0].ability;
        result.proficient = filteredAbilities[0].proficient;
        result.extraAttackBonus = filteredAbilities[0].bonus;
      }
    }

    // negative mods!
    if (!result.baseAbility) {
      logger/* default.warn */.Z.warn("NEGATIVE PARSE!");
      logger/* default.warn */.Z.warn(result.monsterName);
      logger/* default.warn */.Z.warn(result.name);
      logger/* default.info */.Z.info(result.toHit);

      const magicAbilities = checkAbilities(initialAbilities, result.abilities, proficiencyBonus, result.toHit, true);
      // logger.info(magicAbilities);

      const filteredAbilities = magicAbilities.filter((ab) => ab.success == true).sort((a, b) => {
        if (a.proficient == !b.proficient) return -1;
        if (b.proficient == !a.proficient) return 1;
        if (a.proficient == b.proficient) {
          if (a.bonus < b.bonus) return 1;
          if (b.bonus < a.bonus) return -1;
        }
        return 0;
      });
      logger/* default.debug */.Z.debug("Filtered abilities", filteredAbilities);
      logger/* default.debug */.Z.debug(result.text);
      // fine lets use the first hit
      if (filteredAbilities.length >= 1 && filteredAbilities[0].success) {
        result.baseAbility = filteredAbilities[0].ability;
        result.proficient = filteredAbilities[0].proficient;
        result.extraAttackBonus = filteredAbilities[0].bonus;
      } else {
        logger/* default.error */.Z.error("Unable to calculate attack!");
        logger/* default.info */.Z.info(result.text);
      }
    }
  }

  return result;
}

function getTarget(text) {
  let target = {
    "value": null,
    "width": null,
    "units": "",
    "type": ""
  };

  // 90-foot line that is 10 feet wide
  // in a 90-foot cone
  const matchText = text.replace(/[Â­â€“â€“âˆ’-]/gu, "-").replace(/-+/g, "-");
  // console.warn(matchText);
  const lineSearch = /(\d+)-foot line/;
  const coneSearch = /(\d+)-foot cone/;
  const cubeSearch = /(\d+)-foot cube/;
  const sphereSearch = /(\d+)-foot-radius sphere/;

  const coneMatch = matchText.match(coneSearch);
  const lineMatch = matchText.match(lineSearch);
  const cubeMatch = matchText.match(cubeSearch);
  const sphereMatch = matchText.match(sphereSearch);

  // console.log(coneMatch);
  // console.log(lineMatch);
  // console.log(cubeMatch);
  // console.log(sphereMatch);

  if (coneMatch) {
    target.value = parseInt(coneMatch[1]);
    target.units = "ft";
    target.type = "cone";
  } else if (lineMatch) {
    target.value = parseInt(lineMatch[1]);
    target.units = "ft";
    target.type = "line";
  } else if (cubeMatch) {
    target.value = parseInt(cubeMatch[1]);
    target.units = "ft";
    target.type = "cube";
  } else if (sphereMatch) {
    target.value = parseInt(sphereMatch[1]);
    target.units = "ft";
    target.type = "sphere";
  }

  return target;
}

function getActionInfo(monster, DDB_CONFIG, name, text) {
  const matches = text.match(
    /(Melee|Ranged|Melee\s+or\s+Ranged)\s+(|Weapon|Spell)\s*Attack:\s*([+-]\d+)\s+to\s+hit/i
  );
  const proficiencyBonus = DDB_CONFIG.challengeRatings.find((cr) => cr.id == monster.challengeRatingId).proficiencyBonus;
  const abilities = (0,monster_abilities/* getAbilityMods */.Tx)(monster, DDB_CONFIG);


  let result = {
    monsterName: monster.name,
    name: name,
    abilities: abilities,
    weaponAttack: false,
    spellAttack: false,
    meleeAttack: false,
    rangedAttack: false,
    weaponType: null,
    toHit: 0,
    damage: {
      parts: [],
      versatile: ""
    },
    target: {
      "value": null,
      "width": null,
      "units": "",
      "type": ""
    },
    duration: {
      "value": null,
      "units": "inst"
    },
    extraAttackBonus: 0,
    baseAbility: null,
    proficient: false,
    properties: {
      "amm": false,
      "fin": false,
      "fir": false,
      "foc": false,
      "hvy": false,
      "lgt": false,
      "lod": false,
      "rch": false,
      "rel": false,
      "ret": false,
      "spc": false,
      "thr": false,
      "two": false,
      "ver": false
    },
    reach: "",
    range: {
      value: null,
      long: null,
      units: "",
    },
    recharge: { value: null, charged: true },
    activation: null,
    save: {
      dc: null,
      ability: null,
      scaling: "flat",
    },
    text: text,
    uses: {
      value: 0,
      max: 0,
      per: null,
    },
  };
  if (matches) {
    result.isAttack = matches[1] !== undefined;
    result.weaponAttack = matches[2].toLowerCase() === "weapon" || matches[2] === "";
    result.spellAttack = matches[2].toLowerCase() === "spell";
    result.meleeAttack = matches[1].indexOf("Melee") !== -1;
    result.rangedAttack = matches[1].indexOf("Ranged") !== -1;
    result.toHit = parseInt(matches[3]);
  }

  if (result.weaponAttack || result.spellAttack) {
    result = getWeaponAttack(result, proficiencyBonus);
  }
  const damage = getExtendedDamage(text, result);
  result.damage = damage.damage;
  result.formula = damage.formula;

  result.reach = getReach(text);
  result.range = getRange(text);
  if (result.reach != "") result.properties.rch = true;
  result.recharge = getRecharge(name);
  result.activation = getActivation(text);
  result.save = getFeatSave(text, result.save);
  result.target = getTarget(text);
  result.uses = getUses(text);

  return result;
}

function stripHtml(html) {
   let tmp = document.createElement("DIV");
   tmp.innerHTML = html;
   return tmp.textContent || tmp.innerText || "";
}

;// CONCATENATED MODULE: ./src/muncher/monster/features/legendary.js





function legendary_addPlayerDescription(monster, action) {
  let playerDescription = `</section>\nThe ${monster.name} performs ${action.name}!`;
  return playerDescription;
}


function getLegendaryActions(monster, DDB_CONFIG, monsterActions) {
  if (monster.legendaryActionsDescription == "") {
    return {
      actions: {
        "value": 0,
        "max": 0
      },
      legendaryActions: [],
    };
  }

  const updateExisting = game.settings.get("ddb-importer", "munching-policy-update-existing");
  const hideDescription = game.settings.get("ddb-importer", "munching-policy-hide-description");

  let actionResource = {
    value: 3,
    max: 3
  };

  let dom = new DocumentFragment();

  let fixedLegendaryActionsDescription = monster.legendaryActionsDescription
    .replace(/<\/strong> <strong>/g, "").replace(/<\/strong><strong>/g, "");
  $.parseHTML(fixedLegendaryActionsDescription).forEach((element) => {
    dom.appendChild(element);
  });

  dom.childNodes.forEach((node) => {
    if (node.textContent == "\n") {
      dom.removeChild(node);
    }
  });

  let dynamicActions = [];

  // Base feat
  let feat = newFeat("Legendary Actions");
  feat.data.source = getSource(monster, DDB_CONFIG);
  feat.data.description.value = "";
  if (hideDescription) feat.data.description.value += "<section class=\"secret\">\n";
  feat.data.description.value += monster.legendaryActionsDescription;
  if (hideDescription) feat.data.description.value += "</section>\n Performing a Legendary Action.\n\n";
  feat.flags.monsterMunch = {};
  feat.flags.monsterMunch['actionCopy'] = false;
  dynamicActions.push(feat);


  // build out skeleton actions
  dom.querySelectorAll("strong").forEach((node) => {
    const name = node.textContent.trim().replace(/\.$/, '').trim();
    let action = newFeat(name);

    const actionMatch = monsterActions.find((mstAction) =>
      name == mstAction.name ||
      name == `${mstAction.name} Attack` ||
      name == `${mstAction.name}`.split('(', 1)[0].trim() ||
      name == `${mstAction.name} Attack`.split('(', 1)[0].trim()
    );

    action.flags.monsterMunch = {};
    if (actionMatch) {
      action = JSON.parse(JSON.stringify(actionMatch));
      action.flags.monsterMunch['actionCopy'] = true;
    } else {
      action.flags.monsterMunch['actionCopy'] = false;
    }
    action.data.activation.type = "legendary";
    action.data.source = getSource(monster, DDB_CONFIG);
    action.data.consume = {
      type: "attribute",
      target: "resources.legact.value",
      amount: 1
    };
    dynamicActions.push(action);
  });

  let action = dynamicActions.find((act) => act.name == "Legendary Actions");

  dom.childNodes
  .forEach((node) => {
    // check for action numbers
    // can take 3 legendary actions
    let startFlag = false;
    const actionMatch = node.textContent.match(/can take (d+) legendary actions/);
    if (actionMatch) {
      actionResource.value = parseInt(actionMatch[1]);
      actionResource.max = parseInt(actionMatch[1]);
    }

//    const switchAction = dynamicActions.find((act) => node.textContent.startsWith(act.name));
    const nodeName = node.textContent.split('.')[0].trim();
    const switchAction = dynamicActions.find((act) => nodeName === act.name);
    if (action.name !== "Legendary Actions" || switchAction) {

      if (switchAction) {
        if (action.data.description.value !== "" && hideDescription && action.name !== "Legendary Actions") {
          action.data.description.value += legendary_addPlayerDescription(monster, action);
        }
        action.data.description.value = (0,table/* generateTable */.p)(action.name, action.data.description.value, updateExisting);
        action = switchAction;
        if (action.data.description.value === "") {
          startFlag = true;
          if (hideDescription) {
            action.data.description.value = "<section class=\"secret\">\n";
          }
        }
      }
      // console.log(action)
      if (action.flags && action.flags.monstersMunch && action.flags.monsterMunch.actionCopy) return;
      if (node.outerHTML) {
        let outerHTML = node.outerHTML;
        if (switchAction && startFlag) {
          outerHTML = outerHTML.replace(`${nodeName}.`, "");
        }
        action.data.description.value += outerHTML;
      }

      const activationCost = getActivation(node.textContent);
      if (activationCost) {
        action.data.activation.cost = activationCost;
        action.data.consume.amount = activationCost;
      } else {
        action.data.activation.cost = 1;
      }

      // only attempt to update these if we don't parse an action
      if (!action.flags.monsterMunch.actionCopy) {
        action.data.recharge = getRecharge(node.textContent);
        action.data.save = getFeatSave(node.textContent, action.data.save);
        // assumption - if we have parsed a save dc set action type to save
        if (action.data.save.dc) {
          action.data.actionType = "save";
          // action.type = "weapon";
        }
        action.data.range = getRange(node.textContent);
        action.data.target = getTarget(node.textContent);
        action.data.damage = getDamage(node.textContent);
      }
    }
  });

  if (action && action.data.description.value !== "" && hideDescription && action.name !== "Legendary Actions") {
    action.data.description.value += legendary_addPlayerDescription(monster, action);
  }
  if (action) action.data.description.value = (0,table/* generateTable */.p)(monster.name, action.data.description.value, updateExisting);


  // console.log(dynamicActions);

  return {
    actions: actionResource,
    legendaryActions: dynamicActions,
  };
}

;// CONCATENATED MODULE: ./src/muncher/monster/features/actions.js





// "actionsDescription": "<p><em><strong>Multiattack.</strong></em> The dragon can use its Frightful Presence. It then makes three attacks: one with its bite and two with its claws.</p>\r\n<p><em><strong>Bite.</strong></em> <em>Melee Weapon Attack:</em> +15 to hit, reach 15 ft., one target. <em>Hit:</em> 19 (2d10 + 8) piercing damage plus 9 (2d8) acid damage.</p>\r\n<p><em><strong>Claw.</strong></em> <em>Melee Weapon Attack:</em> +15 to hit, reach 10 ft., one target. <em>Hit:</em> 15 (2d6 + 8) slashing damage.</p>\r\n<p><em><strong>Tail.</strong></em> <em>Melee Weapon Attack:</em> +15 to hit, reach 20 ft., one target. <em>Hit:</em> 17 (2d8 + 8) bludgeoning damage.</p>\r\n<p><em><strong>Frightful Presence.</strong></em> Each creature of the dragon's choice that is within 120 feet of the dragon and aware of it must succeed on a DC 19 Wisdom saving throw or become frightened for 1 minute. A creature can repeat the saving throw at the end of each of its turns, ending the effect on itself on a success. If a creature's saving throw is successful or the effect ends for it, the creature is immune to the dragon's Frightful Presence for the next 24 hours.</p>\r\n<p><em><strong>Acid Breath (Recharge 5&ndash;6).</strong></em> The dragon exhales acid in a 90-foot line that is 10 feet wide. Each creature in that line must make a DC 22 Dexterity saving throw, taking 67 (15d8) acid damage on a failed save, or half as much damage on a successful one.</p>",

function generatePlayerDescription(monster, action) {
  let playerDescription = `<section class="secret">\n${action.data.description.value}`;
  if (["rwak", "mwak"].includes(action.data.actionType)) {
    playerDescription += `\n</section>\nThe ${monster.name} attacks with its ${action.name}.`;
  } else if (["rsak", "msak"].includes(action.data.actionType)) {
    playerDescription += `\n</section>\nThe ${monster.name} casts ${action.name}.`;
  } else if (["save"].includes(action.data.actionType)) {
    playerDescription += `\n</section>\nThe ${monster.name} uses ${action.name} and a save is required.`;
  } else {
    playerDescription += `\n</section>\nThe ${monster.name} uses ${action.name}.`;
  }
  return playerDescription;
}

function buildAction(action, actionInfo, textContent, type) {
  // console.log("&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&");
  // console.log(JSON.stringify(actionInfo, null, 4));
  // console.log("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^");
  // console.warn(action.name);

  if (actionInfo.activation) {
    action.data.activation.cost = actionInfo.activation;
    action.data.consume.amount = actionInfo.activation;
  } else {
    action.data.activation.cost = 1;
  }
  action.data.activation.type = getAction(textContent, type);

  action.data.recharge = actionInfo.recharge;
  action.data.save = actionInfo.save;
  // assumption - if we have parsed a save dc set action type to save
  if (action.data.save.dc) {
    action.data.actionType = "save";
  }

  action.data.damage = actionInfo.damage;
  action.data.formula = actionInfo.formula;
  action.data.properties = actionInfo.properties;
  action.data.proficient = actionInfo.proficient;
  action.data.ability = actionInfo.baseAbility;
  action.data.attackBonus = actionInfo.extraAttackBonus;

  if (actionInfo.weaponAttack) {
    action.data.weaponType = actionInfo.weaponType;
    action.data.equipped = true;
    // console.log(actionInfo.weaponAttack);
    // console.log(actionInfo.meleeAttack);
    // console.log(actionInfo.rangedAttack);
    if (actionInfo.meleeAttack) {
      action.data.actionType = "mwak";
    } else if (actionInfo.rangedAttack) {
      action.data.actionType = "rwak";
    }
  } else if (actionInfo.spellAttack) {
    if (actionInfo.meleeAttack) {
      action.data.actionType = "msak";
    } else if (actionInfo.rangedAttack) {
      action.data.actionType = "rsak";
    } else {
      action.data.actionType = "save";
    }
  } else if (actionInfo.save.dc) {
    action.data.actionType = "save";
  }

  if (actionInfo.isAttack) {
    action.type = "weapon";
  }

  action.data.range = actionInfo.range;
  action.data.target = actionInfo.target;
  action.data.duration = actionInfo.duration;
  action.data.uses = actionInfo.uses;

  if (action.name.includes("/Day")) {
    action.data.uses = getUses(action.name, true);
  }

  return action;
}

function getActions(monster, DDB_CONFIG, type = "action") {
  const hideDescription = game.settings.get("ddb-importer", "munching-policy-hide-description");
  const updateExisting = game.settings.get("ddb-importer", "munching-policy-update-existing");
  let actions;
  let characterDescription;

  switch (type) {
    case "action":
      actions = monster.actionsDescription ?? "";
      break;
    case "reaction":
      actions = monster.reactionsDescription ?? "";
      break;
    case "bonus":
      actions = monster.bonusActionsDescription ?? "";
      break;
    case "mythic":
      actions = monster.mythicActionsDescription ?? "";
      break;
    default:
      actions = "";
  }

  if (actions == "") {
    return [[], null];
  }

  let splitActions = actions.split("<h3>Roleplaying Information</h3>");
  if (splitActions.length > 1) {
    characterDescription = `<h3>Roleplaying Information</h3>${splitActions[1]}`;
  }
  actions = splitActions[0]
    .replace(/<\/strong> <strong>/g, "")
    .replace(/<\/strong><strong>/g, "")
    .replace(/&shy;/g, "");

  let dom = new DocumentFragment();
  $.parseHTML(actions).forEach((element) => {
    dom.appendChild(element);
  });

  // console.error(`Starting ${type} processing`)
  // console.warn(dom);
  // console.log(actions);
  // console.log(dom.childNodes);

  dom.childNodes.forEach((node) => {
    if (node.textContent == "\n") {
      dom.removeChild(node);
    }
  });

  let dynamicActions = [];

  // build out skeleton actions
  dom.querySelectorAll("p").forEach((node) => {

    let pDom = new DocumentFragment();
    $.parseHTML(node.outerHTML).forEach((element) => {
      pDom.appendChild(element);
    });
    const query = pDom.querySelector("strong");
    if (!query) return;
    let name = query.textContent.trim().replace(/\./g, '');
    if (!name.includes("Spell;")) {
      name = name.split(";").pop().trim();
    }
    let action = newFeat(name);
    action.data.source = getSource(monster, DDB_CONFIG);
    action.flags.monsterMunch = {
      titleHTML: query.outerHTML,
      fullName: query.textContent,
    };
    dynamicActions.push(action);
  });

  let action = dynamicActions[0];

  // there is inconsistent formatting
  if (dynamicActions.length == 0) {
    dom.querySelectorAll("p").forEach((node) => {

      let pDom = new DocumentFragment();
      $.parseHTML(node.outerHTML).forEach((element) => {
        pDom.appendChild(element);
      });
      const query = pDom.querySelector("b");
      if (!query) return;
      const name = query.textContent.trim().replace(/\./g, '').split(";").pop().trim();
      let action = newFeat(name);
      action.data.source = getSource(monster, DDB_CONFIG);
      action.flags.monsterMunch = {
        titleHTML: query.outerHTML,
        fullName: query.textContent,
      };
      dynamicActions.push(action);
    });
    action = dynamicActions[0];
  }


  // there is inconsistent formatting
  if (dynamicActions.length == 0) {
    dom.querySelectorAll("p").forEach((node) => {

      let pDom = new DocumentFragment();
      $.parseHTML(node.outerHTML).forEach((element) => {
        pDom.appendChild(element);
      });
      const title = pDom.textContent.split('.')[0];
      const name = title.trim();
      let action = newFeat(name);
      action.data.source = getSource(monster, DDB_CONFIG);
      if (pDom.outerHTML) {
        action.flags.monsterMunch = {
          titleHTML: pDom.outerHTML.split('.')[0],
        };
      }
      if (action.name) dynamicActions.push(action);
    });
    action = dynamicActions[0];
  }

  // homebrew fun
  if (dynamicActions.length == 0) {
    dom.querySelectorAll("div").forEach((node) => {

      let pDom = new DocumentFragment();
      $.parseHTML(node.outerHTML).forEach((element) => {
        pDom.appendChild(element);
      });
      const title = pDom.textContent.split('.')[0];
      const name = title.trim();
      let action = newFeat(name);
      action.data.source = getSource(monster, DDB_CONFIG);
      if (pDom.outerHTML) {
        action.flags.monsterMunch = {
          titleHTML: pDom.outerHTML.split('.')[0],
        };
      }
      if (action.name) dynamicActions.push(action);
    });
    action = dynamicActions[0];
  }

  // console.error(dynamicActions);

  dom.childNodes.forEach((node) => {
    // console.log("***");
    // console.warn(action);
    // console.log("***");
    // console.log(node.textContent);
    // const switchAction = dynamicActions.find((act) => node.textContent.startsWith(act.name));
    const nodeContextSplit = node.textContent.split('.');
    // console.log(nodeContextSplit);
    const nodeName = nodeContextSplit[0].trim();
    const longNodeName = (nodeContextSplit.length > 2 && nodeContextSplit[1].trim().startsWith('('))
      ? `${nodeName} ${nodeContextSplit[1].trim()}`
      : nodeName;
    let switchAction = dynamicActions.find((act) => nodeName === act.name || longNodeName === act.name);

    if (!switchAction) {
      switchAction = dynamicActions.find((act) => node.textContent.startsWith(act.flags.monsterMunch.fullName));
    }
    // console.warn(nodeName);
    // console.warn(longNodeName);
    // console.warn(switchAction);
    let startFlag = false;
    if (switchAction) {
      action = switchAction;
      if (action.data.description.value === "") {
        startFlag = true;
      }
    }

    // console.warn(node);
    // console.warn(action);
    if (!action) return;

    if (node.outerHTML) {
      let outerHTML = node.outerHTML;
      if (switchAction && startFlag) {
        // const name = new RegExp(`^${nodeName}\.?`);
        // outerHTML = outerHTML.replace(name, "");
        if (action.flags?.monsterMunch?.fullName) {
          outerHTML = outerHTML.replace(action.flags.monsterMunch.fullName, "");
        } else {
          outerHTML = outerHTML.replace(nodeName, "");
        }
        const titleDom = new DocumentFragment();
        $.parseHTML(outerHTML).forEach((element) => {
          titleDom.appendChild(element);
        });
        if (titleDom.textContent.startsWith(".")) outerHTML = outerHTML.replace(".", "");
      }
      action.data.description.value += outerHTML;
    }
  });

  dynamicActions = dynamicActions.map((da) => {
    const actionDescription = stripHtml(da.data.description.value);
    const actionInfo = getActionInfo(monster, DDB_CONFIG, da.name, actionDescription);
    const result = buildAction(da, actionInfo, actionDescription, type);
    if (hideDescription) {
      da.data.description.value = generatePlayerDescription(monster, da);
    }
    da.data.description.value = (0,table/* generateTable */.p)(monster.name, da.data.description.value, updateExisting);
    return result;
  });

  // console.warn(dynamicActions);
  // console.log(JSON.stringify(dynamicActions, null, 4));

  return [dynamicActions, characterDescription];
}

;// CONCATENATED MODULE: ./src/muncher/monster/features/specialtraits.js
// specialTraitsDescription
// handle legendary resistance here






function specialtraits_addPlayerDescription(monster, action) {
  let playerDescription = `</section>\nThe ${monster.name} uses ${action.name}!`;
  return playerDescription;
}

function getSpecialTraits(monster, DDB_CONFIG) {
  if (monster.specialTraitsDescription == "") {
    return {
      resistance: {
        "value": 0,
        "max": 0
      },
      specialActions: [],
      characterDescription: null,
    };
  }

  const updateExisting = game.settings.get("ddb-importer", "munching-policy-update-existing");
  const hideDescription = game.settings.get("ddb-importer", "munching-policy-hide-description");

  let resistanceResource = {
    value: 0,
    max: 0
  };
  let characterDescription;

  let dom = new DocumentFragment();
  let splitActions = monster.specialTraitsDescription.split("<h3>Roleplaying Information</h3>");
  if (splitActions.length > 1) {
    characterDescription = `<h3>Roleplaying Information</h3>${splitActions[1]}`;
  }

  const fixedDescription = splitActions[0]
    .replace(/<\/strong> <strong>/g, "").replace(/<\/strong><strong>/g, "")
    .replace(/&shy;/g, "")
    .replace(/<br \/>/g, "</p><p>");
  $.parseHTML(fixedDescription).forEach((element) => {
    dom.appendChild(element);
  });

  dom.childNodes.forEach((node) => {
    if (node.textContent == "\n") {
      dom.removeChild(node);
    }
  });

  // console.error(`Starting special traits processing`)
  // console.warn(dom);
  // console.log(fixedDescription);
  // console.log(dom.childNodes);

  let dynamicActions = [];

  // build out skeleton actions
  dom.querySelectorAll("p").forEach((node) => {
    let action = newFeat(name);
    let pDom = new DocumentFragment();
    $.parseHTML(node.outerHTML).forEach((element) => {
      pDom.appendChild(element);
    });
    const query = pDom.querySelector("em");
    if (!query) return;
    action.name = query.textContent.trim().replace(/\./g, '').split(";").pop().trim();
    action.data.source = getSource(monster, DDB_CONFIG);
    action.flags.monsterMunch = {
      titleHTML: query.outerHTML,
      fullName: query.textContent,
    };
    if (action.name) dynamicActions.push(action);
  });

  if (dynamicActions.length == 0) {
    dom.querySelectorAll("p").forEach((node) => {
      let pDom = new DocumentFragment();
      $.parseHTML(node.outerHTML).forEach((element) => {
        pDom.appendChild(element);
      });
      const query = pDom.querySelector("strong");
      if (!query) return;
      const name = query.textContent.trim().replace(/\./g, '').split(";").pop().trim();
      let action = newFeat(name);
      action.data.source = getSource(monster, DDB_CONFIG);
      action.flags.monsterMunch = {
        titleHTML: query.outerHTML,
        fullName: query.textContent,
      };
      if (action.name) dynamicActions.push(action);
    });
  }

  if (dynamicActions.length == 0) {
    dom.querySelectorAll("em").forEach((node) => {
      const name = node.textContent.trim().replace(/\.$/, '').trim();
      let action = newFeat(name);
      action.data.source = getSource(monster, DDB_CONFIG);
      action.flags.monsterMunch = {
        titleHTML: node.outerHTML,
        fullName: node.textContent,
      };
      if (action.name) dynamicActions.push(action);
    });
  }

  if (dynamicActions.length == 0) {
    dom.querySelectorAll("strong").forEach((node) => {
      const name = node.textContent.trim().replace(/\.$/, '').trim();
      let action = newFeat(name);
      action.data.source = getSource(monster, DDB_CONFIG);
      action.flags.monsterMunch = {
        titleHTML: node.outerHTML,
        fullName: node.textContent,
      };
      if (action.name) dynamicActions.push(action);
    });
  }

  if (dynamicActions.length == 0) {
    let action = newFeat("Special Traits");
    action.data.source = getSource(monster, DDB_CONFIG);
    action.flags.monsterMunch = {};
    if (action.name) dynamicActions.push(action);
  }

  let action = dynamicActions[0];

  // console.warn(dynamicActions);

  dom.childNodes.forEach((node) => {
    // console.warn(node.textContent);
    // const switchAction = dynamicActions.find((act) => node.textContent.startsWith(act.name));
    const nodeName = node.textContent.split('.')[0].trim();
    let switchAction = dynamicActions.find((act) => nodeName === act.name);
    if (!switchAction) {
      switchAction = dynamicActions.find((act) => node.textContent.startsWith(act.flags.monsterMunch.fullName));
    }
    // console.log(switchAction);
    let startFlag = false;
    if (switchAction) {
      if (action.data.description.value !== "" && hideDescription) {
        action.data.description.value += specialtraits_addPlayerDescription(monster, action);
      }
      action.data.description.value = (0,table/* generateTable */.p)(action.name, action.data.description.value, updateExisting);
      action = switchAction;
      if (action.data.description.value === "") {
        startFlag = true;
        if (hideDescription) {
          action.data.description.value = "<section class=\"secret\">\n";
        }
      }
    }

    if (node.outerHTML) {
      let outerHTML = node.outerHTML;
      if (switchAction && startFlag) {
        if (action.flags?.monsterMunch?.fullName) {
          outerHTML = outerHTML.replace(action.flags.monsterMunch.fullName, "");
        } else {
          outerHTML = outerHTML.replace(nodeName, "");
          // outerHTML = outerHTML.replace(`${nodeName}.`, "");
        }
      }
      const titleDom = new DocumentFragment();
      $.parseHTML(outerHTML).forEach((element) => {
        titleDom.appendChild(element);
      });
      if (titleDom.textContent.startsWith(". ")) outerHTML = outerHTML.replace(". ", "");
      action.data.description.value += outerHTML;
    }

    // If we have already parsed bits of this action, we probably don't want to
    // do it again!
    // if (!startFlag) return;

    const activationCost = getActivation(node.textContent);
    if (activationCost) {
      action.data.activation.cost = activationCost;
      action.data.consume.amount = activationCost;
    } else {
      action.data.activation.cost = 1;
    }
    action.data.activation.type = getAction(node.textContent, "");

    action.data.uses = getUses(node.textContent);
    action.data.recharge = getRecharge(node.textContent);
    action.data.save = getFeatSave(node.textContent, action.data.save);
    action.data.target = getTarget(node.textContent);
    // assumption - if we have parsed a save dc set action type to save
    if (action.data.save.dc) {
      action.data.actionType = "save";
    }
    action.data.damage = getDamage(node.textContent);
    // assumption - if the action type is not set but there is damage, the action type is other
    if (!action.data.actionType && action.data.damage.parts.length != 0) {
      action.data.actionType = "other";
    }

    // legendary resistance check
    const actionMatch = node.textContent.match(/Legendary Resistance \((\d+)\/Day\)/);
    if (actionMatch) {
      resistanceResource.value = parseInt(actionMatch[1]);
      resistanceResource.max = parseInt(actionMatch[1]);
      action.data.activation.type = "special";
      action.data.activation.const = null;
      action.data.consume = {
        type: "attribute",
        target: "resources.legres.value",
        amount: 1
      };
    }

  });

  if (action && action.data.description.value !== "" && hideDescription) {
    action.data.description.value += specialtraits_addPlayerDescription(monster, action);
  }
  if (action) action.data.description.value = (0,table/* generateTable */.p)(monster.name, action.data.description.value, updateExisting);

  // console.log(dynamicActions);

  return {
    resistance: resistanceResource,
    specialActions: dynamicActions,
    characterDescription: characterDescription,
  };
}

;// CONCATENATED MODULE: ./src/muncher/monster/spells.js




function parseSpellcasting(text) {
  let spellcasting = "";
  const abilitySearch = "(?:spellcasting ability is|uses) (\\w+)(?: as \\w+ spellcasting ability| )";
  const match = text.match(abilitySearch);
  if (match) {
    spellcasting = match[1].toLowerCase().substr(0, 3);
  }
  return spellcasting;
}

function parseSpellLevel(text) {
  let spellLevel = "";
  const levelSearch = /is (?:a|an) (\d+)(?:th|nd|rd|st)(?:-| )level spellcaster/;
  const match = text.match(levelSearch);
  if (match) {
    spellLevel = parseInt(match[1]);
  }
  return spellLevel;
}

function parseSpelldc(text) {
  let dc = 10;
  const dcSearch = "spell\\s+save\\s+DC\\s*(\\d+)(?:,|\\)|\\s)";
  const match = text.match(dcSearch);
  // console.log("Â£Â£Â£Â£Â£")
  // console.log(match);
  if (match) {
    dc = parseInt(match[1]);
  }
  return dc;
}

function parseBonusSpellAttack(text, monster, DDB_CONFIG) {
  let spellAttackBonus = 0;
  const dcSearch = "([+-]\\d+)\\s+to\\s+hit\\s+with\\s+spell\\s+attacks";
  const match = text.match(dcSearch);
  if (match) {
    const toHit = match[1];
    const proficiencyBonus = DDB_CONFIG.challengeRatings.find((cr) => cr.id == monster.challengeRatingId).proficiencyBonus;
    const abilities = (0,monster_abilities/* getAbilityMods */.Tx)(monster, DDB_CONFIG);
    const castingAbility = parseSpellcasting(text);
    spellAttackBonus = toHit - proficiencyBonus - abilities[castingAbility];
  }
  return spellAttackBonus;
}

function parseInnateSpells(text, spells, spellList) {
 // handle innate style spells here
  // 3/day each: charm person (as 5th-level spell), color spray, detect thoughts, hold person (as 3rd-level spell)
  // console.log(text);
  const innateSearch = /^(\d+)\/(\w+)(?:\s+each)?:\s+(.*$)/;
  const innateMatch = text.match(innateSearch);
  // console.log(innateMatch);
  if (innateMatch) {
    const spellArray = innateMatch[3].split(",").map((spell) => spell.trim());
    spellArray.forEach((spell) => {
      spellList.innate.push({ name: spell, type: innateMatch[2], value: innateMatch[1] });
    });
  }

  // At will: dancing lights
  const atWillSearch = /^At (?:Will|will):\s+(.*$)/;
  const atWillMatch = text.match(atWillSearch);
  if (atWillMatch) {
    const spellArray = atWillMatch[1].split(",").map((spell) => spell.trim());
    spellArray.forEach((spell) => {
      spellList.atwill.push(spell);
    });
  }

  // last ditch attempt, mephits have some weird formating
  if (!innateMatch && !atWillMatch) {
    const mephitMatch = text.match(/(\d+)\/(\w+)(?:.*)?cast (.*),/);
    if (mephitMatch) {
      const spell = mephitMatch[3].trim();
      spellList.innate.push({ name: spell, type: mephitMatch[2], value: mephitMatch[1] });
    }
  }

  return [spells, spellList];

}


// e.g. The archmage can cast disguise self and invisibility at will and has the following wizard spells prepared:
function parseAdditionalAtWill(text) {
  const atWillSearch = /can cast (.*?) at will/;
  const atWillMatch = text.match(atWillSearch);
  let atWillSpells = [];
  if (atWillMatch) {
    atWillSpells = atWillMatch[1].replace(" and", ",").split(",").map((spell) => spell.split('(', 1)[0].trim());
  }
  return atWillSpells;
}

function parseSpells(text, spells, spellList) {
    // console.log(text);
    const spellLevelSearch = /^(Cantrip|\d)(?:st|th|nd|rd)?(?:\s*(?:Level|level))?(?:s)?\s+\((at will|at-will|\d)\s*(?:slot|slots)?\):\s+(.*$)/;
    const match = text.match(spellLevelSearch);
    // console.log(match);

    const warlockLevelSearch = /^1stâ€“(\d)(?:st|th|nd|rd)\s+level\s+\((\d)\s+(\d)(?:st|th|nd|rd)?\s*(?:Level|level|-level)\s*(?:slot|slots)?\):\s+(.*$)/;
    const warlockMatch = text.match(warlockLevelSearch);

    if (!match && !warlockMatch) return parseInnateSpells(text, spells, spellList);

    const spellLevel = (match) ? match[1] : 'pact';
    const slots = (match) ? match[2] : warlockMatch[2];
    const spellMatches = (match) ? match[3] : warlockMatch[4];

    if (Number.isInteger(parseInt(spellLevel)) && Number.isInteger(parseInt(slots))) {
      spells[`spell${spellLevel}`]['value'] = slots;
      spells[`spell${spellLevel}`]['max'] = slots;
      spells[`spell${spellLevel}`]['override'] = slots;
      const spellArray = spellMatches.split(",").map((spell) => spell.trim());
      spellList.class.push(...spellArray);
    } else if (spellLevel === 'pact' && Number.isInteger(parseInt(slots))) {
      spells[spellLevel]['value'] = slots;
      spells[spellLevel]['max'] = slots;
      spells[spellLevel]['override'] = slots;
      spells[spellLevel]['level'] = warlockMatch[3];
      const spellArray = spellMatches.split(",").map((spell) => spell.trim());
      spellList.pact.push(...spellArray);
    } else if (["at will", "at-will"].includes(slots)) {
      // at will spells
      const spellArray = spellMatches.replace(/\*/g, '').split(",").map((spell) => spell.trim());
      spellList.atwill.push(...spellArray);
    }

    // console.log(spellList);

    return [spells, spellList];

}


function splitEdgeCase(spell) {
  let result = {
    name: spell,
    edge: null,
  };

  const splitSpell = spell.split("(");
  if (splitSpell.length > 1) {
    result.name = splitSpell[0].trim();
    result.edge = splitSpell[1].split(")")[0].trim();
  }

  return result;
}

function getEdgeCases(spellList) {
  let results = {
    class: [],
    pact: [],
    atwill: [],
    // {name: "", type: "srt/lng/day", value: 0} // check these values
    innate: [],
    edgeCases: [], // map { name: "", type: "", edge: "" }
  };

  // class and atwill
  spellList.class.forEach((spell) => {
    const edgeCheck = splitEdgeCase(spell);
    results.class.push(edgeCheck.name);
    if (edgeCheck.edge) {
      const edgeEntry = {
        name: edgeCheck.name,
        type: "class",
        edge: edgeCheck.edge,
      };
      results.edgeCases.push(edgeEntry);
    }
  });
  spellList.atwill.forEach((spell) => {
    const edgeCheck = splitEdgeCase(spell);
    results.atwill.push(edgeCheck.name);
    if (edgeCheck.edge) {
      const edgeEntry = {
        name: edgeCheck.name,
        type: "atwill",
        edge: edgeCheck.edge,
      };
      results.edgeCases.push(edgeEntry);
    }
  });
  spellList.pact.forEach((spell) => {
    const edgeCheck = splitEdgeCase(spell);
    results.pact.push(edgeCheck.name);
    if (edgeCheck.edge) {
      const edgeEntry = {
        name: edgeCheck.name,
        type: "pact",
        edge: edgeCheck.edge,
      };
      results.edgeCases.push(edgeEntry);
    }
  });
  // innate
  spellList.innate.forEach((spellMap) => {
    const edgeCheck = splitEdgeCase(spellMap.name);
    spellMap.name = edgeCheck.name;
    results.innate.push(spellMap);
    if (edgeCheck.edge) {
      const edgeEntry = {
        name: edgeCheck.name,
        type: "innate",
        edge: edgeCheck.edge,
      };
      results.edgeCases.push(edgeEntry);
    }
  });

  return results;
}


// <p><em><strong>Innate Spellcasting.</strong></em> The oblex&rsquo;s innate spellcasting ability is Intelligence (spell save DC 15). It can innately cast the following spells, requiring no components:</p>\r\n<p>3/day each: charm person (as 5th-level spell), color spray, detect thoughts, hold person (as 3rd-level spell)</p>


function getSpells(monster, DDB_CONFIG) {
  let spelldc = 10;
  // data.details.spellLevel (spellcasting level)
  let spellLevel = 0;
  let spellList = {
    class: [],
    pact: [],
    atwill: [],
    // {name: "", type: "srt/lng/day", value: 0} // check these values
    innate: [],
    edgeCases: [], // map { name: "", type: "", edge: "" }
    material: true,
  };

  // ability associated
  let spellcasting = "";
  let spellAttackBonus = 0;

  let spells = {
    "spell1": {
      "value": 0,
      "max": 0,
      "override": null
    },
    "spell2": {
      "value": 0,
      "max": 0,
      "override": null
    },
    "spell3": {
      "value": 0,
      "max": 0,
      "override": null
    },
    "spell4": {
      "value": 0,
      "max": 0,
      "override": null
    },
    "spell5": {
      "value": 0,
      "max": 0,
      "override": null
    },
    "spell6": {
      "value": 0,
      "max": 0,
      "override": null
    },
    "spell7": {
      "value": 0,
      "max": 0,
      "override": null
    },
    "spell8": {
      "value": 0,
      "max": 0,
      "override": null
    },
    "spell9": {
      "value": 0,
      "max": 0,
      "override": null
    },
    "pact": {
      "value": 0,
      "max": 0,
      "override": null,
      "level": 0
    }
  };

  let dom = new DocumentFragment();

  // some monsters have poor spell formating, reported and might be able to remove in future
  // https://www.dndbeyond.com/forums/d-d-beyond-general/bugs-support/91228-sir-godfrey-gwilyms-spell-statblock
  // let specialTraits = monster.specialTraitsDescription;
  const possibleSpellSources = monster.specialTraitsDescription + monster.actionsDescription;
  let specialTraits = possibleSpellSources.replace(/<br \/>/g, "</p><p>");
//   const specialCases = ["Sir Godfrey Gwilym", "Hlam", "Ygorl, Lord of Entropy",
//     "Whymsee (Kraken Priest Variant)", "Strahd Zombie", "Skrâ€™a Sâ€™orsk",
//     "Mongrelfolk", "Laeral Silverhand", "Jarlaxle Baenre", "Gar Shatterkeel (Noncore)", "Forlarren",
//     "Fog Giant", "Fhenimore (Kraken Priest Variant)", "Drow Arachnomancer",
//     "Archon of the Triumvirate", "Amble",
// ];
//   if (specialCases.includes(monster.name)) {
//     specialTraits = specialTraits.replace(/<br \/>/g, "</p><p>");
//     logger.warn(`Fiddling with ${monster.name} spells due to bad formatting`);
//   }
//   if (specialTraits.includes("<br />")) console.error(`"SPECIAL CASE ${monster.name}`);

// console.warn(specialTraits);
  $.parseHTML(specialTraits).forEach((element) => {
    dom.appendChild(element);
  });

  dom.childNodes.forEach((node) => {
    if (node.textContent == "\n") {
      dom.removeChild(node);
    }
  });

  dom.childNodes.forEach((node) => {
    const spellText = node.textContent.replace(/â€™/g, "'");
    const spellcastingMatch = spellText.trim().match(/^Spellcasting|^Innate Spellcasting/);
    if (spellcastingMatch) {
      spellcasting = parseSpellcasting(spellText);
      spelldc = parseSpelldc(spellText);
      spellLevel = parseSpellLevel(spellText);
      spellAttackBonus = parseBonusSpellAttack(spellText, monster, DDB_CONFIG);
    }

    const noMaterialSearch = /no material component|no component/;
    const noMaterialMatch = spellText.match(noMaterialSearch);

    if (noMaterialMatch) {
      spellList.material = false;
    }

    [spells, spellList] = parseSpells(spellText, spells, spellList);
    const additionalAtWill = parseAdditionalAtWill(spellText);
    spellList.atwill.push(...additionalAtWill);
  });

  spellList = getEdgeCases(spellList);

  // console.warn(spellList);
  logger/* default.debug */.Z.debug("Parsed spell list", spellList);

  // console.log("*****")

  const result = {
    spelldc: spelldc,
    spellcasting: spellcasting,
    spellLevel: spellLevel,
    spells: spells,
    spellList: spellList,
    spellAttackBonus: spellAttackBonus,
  };

  // console.log(JSON.stringify(result, null, 4));
  return result;

}


;// CONCATENATED MODULE: ./src/muncher/monster/type.js


//   "value": "",
//   "subtype": "",
//   "swarm": {
//     "isSwarm": false,
//     "size": ""
//   },
//   "custom": ""


function getType(monster, DDB_CONFIG) {

  const result = {
    "value": "",
    "subtype": "",
    "swarm": "",
    // "swarm": {
    //   "isSwarm": false,
    //   "size": ""
    // },
    "custom": ""
  };

  if (monster.swarm) {
    // result.swarm.isSwarm = true;
    // result.swarm.size = getSizeFromId(monster.swarm.sizeId, DDB_CONFIG).value;
    result.swarm = getSizeFromId(monster.swarm.sizeId, DDB_CONFIG).value;
  }

  const type = DDB_CONFIG.monsterTypes.find((c) => monster.typeId == c.id);
  if (!type) {
    result.custom = "Unknown";
    return result;
  }

  const typeName = type.name.toLowerCase();

  if (CONFIG.DND5E.creatureTypes[typeName]) result.value = typeName;

  result.subtype = DDB_CONFIG.monsterSubTypes
    .filter((c) => monster.subTypes.includes(c.id))
    .map((c) => c.name)
    .join(", ");

  return result;

}

// EXTERNAL MODULE: ./src/ddbConfig.js
var ddbConfig = __webpack_require__(31);
;// CONCATENATED MODULE: ./src/muncher/monster/templates/monster.js


function newNPC(name) {
  let npc = {
    name: name,
    type: "npc",
    data: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("npc")),
    flags: {
      dnd5e: {},
      monsterMunch: {},
      ddbimporter: {
        dndbeyond: {},
      },
    },
    img: "icons/svg/mystery-man.svg",
    items: [],
    effects: [],
    token: {
      "flags": {},
      "name": name,
      "displayName": 20,
      "img": "icons/svg/mystery-man.svg",
      "width": 1,
      "height": 1,
      "scale": 1,
      "vision": true,
      "dimSight": 0,
      "brightSight": 0,
      "dimLight": 0,
      "brightLight": 0,
      "sightAngle": 360,
      "lightAngle": 360,
      "disposition": -1,
      "displayBars": 40,
      "bar1": {
        "attribute": "attributes.hp"
      },
      "randomImg": false
    },
  };
  return npc;
};

;// CONCATENATED MODULE: ./src/muncher/monster/monster.js
























function parseMonsters(monsterData, extra = false) {

  let foundryActors = [];
  let failedMonsterNames = [];

  const setVision = game.settings.get("ddb-importer", "monster-has-vision");

  // eslint-disable-next-line complexity
  monsterData.forEach((monster) => {
    try {
      let foundryActor = JSON.parse(JSON.stringify(newNPC(monster.name)));
      // logger.info(monster);
      let items = [];

      // name
      // foundryActor.name = monster.name;
      // logger.info("********************");
      // logger.info(monster.name);
      let img = (monster.basicAvatarUrl) ? monster.basicAvatarUrl : monster.largeAvatarUrl;
      // foundry doesn't support gifs
      if (img && img.match(/.gif$/)) {
        img = null;
      }
      foundryActor.token.name = monster.name;
      foundryActor.flags.monsterMunch = {
        url: monster.url,
        img: (img) ? img : monster.avatarUrl,
        tokenImg: monster.avatarUrl,
      };
      foundryActor.flags.ddbimporter = {
        id: monster.id,
        entityTypeId: monster.entityTypeId,
        creatureGroup: monster.creatureGroup ? monster.creatureGroup : null,
        creatureFlags: monster.creatureFlags ? monster.creatureFlags : [],
        automatedEvcoationAnimation: monster.automatedEvcoationAnimation ? monster.automatedEvcoationAnimation : undefined,
      };

      const removedHitPoints = monster.removedHitPoints ? monster.removedHitPoints : 0;
      const temporaryHitPoints = monster.temporaryHitPoints ? monster.removedHitPoints : 0;

      // abilities
      foundryActor.data.abilities = (0,monster_abilities/* getAbilities */.BA)(foundryActor.data.abilities, monster, ddbConfig/* DDB_CONFIG */.U);

      // skills
      foundryActor.data.skills = (extra)
        ? (0,skills/* getSkills */.SM)(foundryActor.data.skills, monster, ddbConfig/* DDB_CONFIG */.U)
        : (0,skills/* getSkillsHTML */.Xt)(foundryActor.data.skills, monster, ddbConfig/* DDB_CONFIG */.U);

      // Senses
      foundryActor.data.attributes.senses = getSenses(monster, ddbConfig/* DDB_CONFIG */.U);
      foundryActor.token = getTokenSenses(foundryActor.token, monster, ddbConfig/* DDB_CONFIG */.U);
      foundryActor.token.vision = setVision;

      // Conditions
      foundryActor.data.traits.di = getDamageImmunities(monster, ddbConfig/* DDB_CONFIG */.U);
      foundryActor.data.traits.dr = getDamageResistances(monster, ddbConfig/* DDB_CONFIG */.U);
      foundryActor.data.traits.dv = getDamageVulnerabilities(monster, ddbConfig/* DDB_CONFIG */.U);
      foundryActor.data.traits.ci = getConditionImmunities(monster, ddbConfig/* DDB_CONFIG */.U);
      const size = getSize(monster, ddbConfig/* DDB_CONFIG */.U);
      foundryActor.data.traits.size = size.value;
      foundryActor.token.width = size.token.value;
      foundryActor.token.height = size.token.value;
      foundryActor.token.scale = size.token.scale;


      // languages
      foundryActor.data.traits.languages = getLanguages(monster, ddbConfig/* DDB_CONFIG */.U);

      // attributes
      foundryActor.data.attributes.hp = getHitPoints(monster, removedHitPoints, temporaryHitPoints);
      const movement = getSpeed(monster, ddbConfig/* DDB_CONFIG */.U);
      foundryActor.data.attributes.movement = movement['movement'];

      foundryActor.data.attributes.prof = ddbConfig/* DDB_CONFIG.challengeRatings.find */.U.challengeRatings.find((cr) => cr.id == monster.challengeRatingId).proficiencyBonus;

      // ac
      const autoAC = utils/* default.versionCompare */.Z.versionCompare(game.data.system.data.version, "1.4.0") >= 0;
      // place holder for D&D5e v1.4.0
      if (autoAC) {
        foundryActor.data.attributes.ac = {
          "flat": monster.armorClass,
          "calc": "",
          "formula": "",
          "label": monster.armorClassDescription ? monster.armorClassDescription.replace("(", "").replace(")", "") : "",
        };
        foundryActor.flags.ddbimporter.flatAC = true;
      } else {
        foundryActor.data.attributes.ac.value = monster.armorClass;
        foundryActor.flags.ddbimporter.flatAC = false;
      }

      // details
      const cr = ddbConfig/* DDB_CONFIG.challengeRatings.find */.U.challengeRatings.find((cr) => cr.id == monster.challengeRatingId);
      foundryActor.data.details.type = getType(monster, ddbConfig/* DDB_CONFIG */.U);
      const alignment = ddbConfig/* DDB_CONFIG.alignments.find */.U.alignments.find((c) => monster.alignmentId == c.id);
      foundryActor.data.details.alignment = alignment ? alignment.name : "";
      foundryActor.data.details.cr = cr.value;
      foundryActor.data.details.source = getSource(monster, ddbConfig/* DDB_CONFIG */.U);
      foundryActor.data.details.xp = {
        value: cr.xp
      };
      foundryActor.data.details.environment = getEnvironments(monster, ddbConfig/* DDB_CONFIG */.U);
      foundryActor.data.details.biography.value = monster.characteristicsDescription;

      let actions, lairActions, legendaryActions, specialTraits, reactions, bonus, mythic;
      let characterDescriptionAction, characterDescriptionReaction, unexpectedDescription;

      [actions, characterDescriptionAction] = getActions(monster, ddbConfig/* DDB_CONFIG */.U);
      items.push(...actions);

      if (monster.hasLair) {
        lairActions = getLairActions(monster, ddbConfig/* DDB_CONFIG */.U);
        items.push(...lairActions.lairActions);
        foundryActor.data.resources["lair"] = lairActions.resource;
      }

      if (monster.legendaryActionsDescription != "") {
        legendaryActions = getLegendaryActions(monster, ddbConfig/* DDB_CONFIG */.U, actions);
        items.push(...legendaryActions.legendaryActions);
        foundryActor.data.resources["legact"] = legendaryActions.actions;
        foundryActor.token.bar2 = {
          attribute: "resources.legact"
        };
      }

      if (monster.specialTraitsDescription != "") {
        specialTraits = getSpecialTraits(monster, ddbConfig/* DDB_CONFIG */.U, actions);
        items.push(...specialTraits.specialActions);
        foundryActor.data.resources["legres"] = specialTraits.resistance;
      }

      [reactions, characterDescriptionReaction] = getActions(monster, ddbConfig/* DDB_CONFIG */.U, "reaction");
      items.push(...reactions);
      [bonus, unexpectedDescription] = getActions(monster, ddbConfig/* DDB_CONFIG */.U, "bonus");
      items.push(...bonus);
      [mythic, unexpectedDescription] = getActions(monster, ddbConfig/* DDB_CONFIG */.U, "mythic");
      items.push(...mythic);

      if (unexpectedDescription) {
        logger/* default.warn */.Z.warn(`Unexpected description for ${monster.name}`);
      }
      if (characterDescriptionAction) {
        foundryActor.data.details.biography.value += characterDescriptionAction;
      }
      if (characterDescriptionReaction) {
        foundryActor.data.details.biography.value += characterDescriptionReaction;
      }
      if (specialTraits?.characterDescription) {
        foundryActor.data.details.biography.value += specialTraits.characterDescription;
      }

      // Spellcasting
      const spellcastingData = getSpells(monster, ddbConfig/* DDB_CONFIG */.U);
      foundryActor.data.attributes.spellcasting = spellcastingData.spellcasting;
      foundryActor.data.attributes.spelldc = spellcastingData.spelldc;
      foundryActor.data.attributes.spellLevel = spellcastingData.spellLevel;
      foundryActor.data.details.spellLevel = spellcastingData.spellLevel;
      foundryActor.data.spells = spellcastingData.spells;
      foundryActor.flags.monsterMunch['spellList'] = spellcastingData.spellList;

      const badItems = items.filter((i) => i.name === "" || !i.name);
      if (badItems.length > 0) {
        logger/* default.error */.Z.error(`${monster.name} - ${badItems.length} items have no name.`, badItems);
        items = items.filter((i) => i.name && i.name !== "");
      }

      foundryActor.items = items;

      // logger.info(JSON.stringify(foundryActor));
      // logger.info(foundryActor.data.resources);
      // logger.info(foundryActor.data.traits.languages);

      // logger.info(foundryActor.data.attributes);
      foundryActors.push(foundryActor);
    } catch (err) {
      logger/* default.info */.Z.info(`Failed parsing ${monster.name}`);
      logger/* default.info */.Z.info(err);
      logger/* default.info */.Z.info(err.stack);
      failedMonsterNames.push(monster.name);
    }


  });
  const result = {
    actors: foundryActors,
    failedMonsterNames: failedMonsterNames,
  };

  return result;
}



/***/ }),

/***/ 415:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HG": () => (/* binding */ SKILLS),
/* harmony export */   "SM": () => (/* binding */ getSkills),
/* harmony export */   "Xt": () => (/* binding */ getSkillsHTML)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(259);
/* harmony import */ var _abilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(184);
const SKILLS = [
  { name: "acr", label: "Acrobatics", ability: "dex", subType: "acrobatics", valueId: 3 },
  { name: "ani", label: "Animal Handling", ability: "wis", subType: "animal-handling", valueId: 11 },
  { name: "arc", label: "Arcana", ability: "int", subType: "arcana", valueId: 6 },
  { name: "ath", label: "Athletics", ability: "str", subType: "athletics", valueId: 2 },
  { name: "dec", label: "Deception", ability: "cha", subType: "deception", valueId: 16 },
  { name: "his", label: "History", ability: "int", subType: "history", valueId: 7 },
  { name: "ins", label: "Insight", ability: "wis", subType: "insight", valueId: 12 },
  { name: "itm", label: "Intimidation", ability: "cha", subType: "intimidation", valueId: 17 },
  { name: "inv", label: "Investigation", ability: "int", subType: "investigation", valueId: 8 },
  { name: "med", label: "Medicine", ability: "wis", subType: "medicine", valueId: 13 },
  { name: "nat", label: "Nature", ability: "int", subType: "nature", valueId: 9 },
  { name: "prc", label: "Perception", ability: "wis", subType: "perception", valueId: 14 },
  { name: "prf", label: "Performance", ability: "cha", subType: "performance", valueId: 18 },
  { name: "per", label: "Persuasion", ability: "cha", subType: "persuasion", valueId: 19 },
  { name: "rel", label: "Religion", ability: "int", subType: "religion", valueId: 10 },
  { name: "slt", label: "Sleight of Hand", ability: "dex", subType: "sleight-of-hand", valueId: 4 },
  { name: "ste", label: "Stealth", ability: "dex", subType: "stealth", valueId: 5 },
  { name: "sur", label: "Survival", ability: "wis", subType: "survival", valueId: 15 },
];




// skills: [
//   { skillId: 5, value: 9, additionalBonus: null },
//   { skillId: 14, value: 9, additionalBonus: null }
// ],

// "skills": [{
//   "skillId": 7, # History
//   "value": 8,
//   "additionalBonus": null
// }, {
//   "skillId": 14, # Perception
//   "value": 6,
//   "additionalBonus": null
// }],

// "ste": {
//   "value": 1,
//   "ability": "dex",
//   "bonus": 0,
//   "mod": 2,
//   "passive": 19,
//   "prof": 7,
//   "total": 9
// },
function getSkills (skills, monster, DDB_CONFIG) {
  const proficiencyBonus = DDB_CONFIG.challengeRatings.find((cr) => cr.id == monster.challengeRatingId).proficiencyBonus;

  const keys = Object.keys(skills);
  keys.forEach((key) => {
    let skill = skills[key];
    const ability = _abilities_js__WEBPACK_IMPORTED_MODULE_1__/* .ABILITIES.find */ .RS.find((ab) => ab.value === skill.ability);
    const stat = monster.stats.find((stat) => stat.statId === ability.id).value || 10;
    const mod = DDB_CONFIG.statModifiers.find((s) => s.value == stat).modifier;
    const lookupSkill = SKILLS.find((s) => s.name == key);
    const monsterSkill = monster.skills.find((s) => s.skillId == lookupSkill.valueId);

    skills[key].mod = mod;

    const calculatedScore = proficiencyBonus + mod;

    if (monsterSkill) {
      skills[key].value = 1;
      skills[key].prof = proficiencyBonus;
      skills[key].bonus = monsterSkill.additionalBonus || 0;
    }

    skills[key].total = calculatedScore;
    skills[key].passive = 10 + calculatedScore;

    if (monsterSkill && monsterSkill.value != calculatedScore) {
      if (monsterSkill.value == calculatedScore + proficiencyBonus) {
        skills[key].passive += proficiencyBonus;
        skills[key].value = 2;
        skills[key].total += proficiencyBonus;
        skills[key].prof += proficiencyBonus;
        skills[key].bonus = 0;
      } else if (monsterSkill.value > calculatedScore + proficiencyBonus) {
        skills[key].passive += proficiencyBonus;
        skills[key].value = 2;
        skills[key].total += proficiencyBonus;
        skills[key].prof += proficiencyBonus;
      }
    }

  });

  return skills;
}


function getSkillsHTML (skills, monster, DDB_CONFIG) {
  const proficiencyBonus = DDB_CONFIG.challengeRatings.find((cr) => cr.id == monster.challengeRatingId).proficiencyBonus;
  //  "skillsHtml": "History + 12, Perception + 10"
  const skillsHTML = monster.skillsHtml.split(',');
  const skillsMaps = skillsHTML.filter((str) => str != '').map((str) => {
    const skillMatch = str.match(/(\w+\s*\w*\s*\w*)(?:\s*)([+-])(?:\s*)(\d+)/);
    let result = {};
    if (skillMatch) {
      result = {
        name: skillMatch[1].trim(),
        value: skillMatch[2] + skillMatch[3],
      };
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.error */ .Z.error(`Skill Parsing failed for ${monster.name}`);
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.debug */ .Z.debug(skillsHTML);
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.debug */ .Z.debug(str);
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.debug */ .Z.debug(skillMatch);
    }
    return result;
  });

  const keys = Object.keys(skills);
  keys.forEach((key) => {
    let skill = skills[key];
    const ability = _abilities_js__WEBPACK_IMPORTED_MODULE_1__/* .ABILITIES.find */ .RS.find((ab) => ab.value === skill.ability);
    const stat = monster.stats.find((stat) => stat.statId === ability.id).value || 10;
    const mod = DDB_CONFIG.statModifiers.find((s) => s.value == stat).modifier;
    const lookupSkill = SKILLS.find((s) => s.name == key);
    const monsterSkill = monster.skills.find((s) => s.skillId == lookupSkill.valueId);

    skills[key].mod = mod;

    if (monsterSkill) {
      skills[key].value = 1;
      skills[key].prof = proficiencyBonus;
      skills[key].bonus = monsterSkill.additionalBonus || 0;
    }
    const calculatedScore = skills[key].prof + mod + skills[key].bonus;
    skills[key].total = calculatedScore;
    skills[key].passive = 10 + calculatedScore;

    const htmlSkill = skillsMaps.find((skl) => skl.name == lookupSkill.label);

    if (htmlSkill) {
      if (htmlSkill.value > calculatedScore) {
        skills[key].passive += proficiencyBonus;
        skills[key].value = 2;
        skills[key].total += proficiencyBonus;
        skills[key].prof += proficiencyBonus;
      }
    }

  });

  return skills;
}


/***/ }),

/***/ 967:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "p": () => (/* binding */ generateTable)
});

;// CONCATENATED MODULE: ./vendor/lowdash/uniq.js
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var uniq_hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(uniq_hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    Set = getNative(root, 'Set'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return uniq_hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : uniq_hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length)
    ? baseUniq(array)
    : [];
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

;// CONCATENATED MODULE: ./vendor/parseTable.js
/**
 * @license
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Nick Williams
 * Copyright (c) 2021 Jack Holloway
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



/**
 * generates factory functions to convert table rows to objects,
 * based on the titles in the table's <thead>
 * @param  {Array<String>} headings the values of the table's <thead>
 * @return {(row: HTMLTableRowElement) => Object} a function that takes a table row and spits out an object
 */
function mapRow(headings, highSplit = false) {
  return function mapRowToObject({ cells }) {
    const lowCells = [...cells];
    const highCells = lowCells.length > headings.length ? lowCells.splice(lowCells.length / 2) : [];
    const range = highSplit ? highCells : lowCells;

    return range.reduce((result, cell, i) => {
      const input = cell.querySelector("input,select");
      var value;

      if (input) {
        value = input.type === "checkbox" ? input.checked : input.value;
      } else {
        value = cell.innerHTML;
      }

      return Object.assign(result, { [headings[i]]: value });
    }, {});
  };
}

/**
 * given a table, generate an array of keys/column names
 *
 * @param  {HTMLTableElement} table the table to convert
 * @return {Array<String>}       array of strings representing each header in the table
 */
function getHeadings(table, unique = true) {
  if (!table.tHead || table.tHead.rows.length === 0) return [];
  const headings = [...table.tHead.rows[0].cells].map((heading) => {
    return heading.textContent;
  });

  if (unique) return uniq(headings);
  return headings;
}


function getRowsFromHeader(table) {
  let rows = [...table.tHead.rows];
  rows.splice(0, 1);
  return rows;
}

/**
 * given a table, generate an array of objects.
 * each object corresponds to a row in the table.
 * each object's key/value pairs correspond to a column's heading and the row's value for that column
 *
 * @param  {HTMLTableElement} table the table to convert
 * @return {Array<Object>}       array of objects representing each row in the table
 */
function parseTable(table) {
  const headings = getHeadings(table);
  const allHeadings = getHeadings(table, false);

  if (headings.length === 0) return [];
  // some tables are misformated and only have a thead and no tbody
  const rows = table.tBodies[0]
    ? [...table.tBodies[0].rows]
    : table.tHead.rows.length > 1
      ? getRowsFromHeader(table)
      : [];
  // DDB often puts d rolls alongside each other. we attempt to detect these
  const lowResults = rows.map(mapRow(headings));
  const highResults =
    allHeadings.length !== headings.length ? rows.map(mapRow(headings, true)) : [];

  return lowResults.concat(highResults);
}


// EXTERNAL MODULE: ./src/utils.js
var utils = __webpack_require__(555);
// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(259);
// EXTERNAL MODULE: ./src/muncher/import.js
var muncher_import = __webpack_require__(193);
;// CONCATENATED MODULE: ./src/muncher/table.js





function diceRollMatcher(match, p1, p2, p3, p4, p5) {
  if (p5 && p5.toLowerCase() === "damage") {
    let dmgString = `${p4} damage`;
    dmgString = dmgString[0].toUpperCase() + dmgString.substring(1);
    const diceString = utils/* default.parseDiceString */.Z.parseDiceString(p2, null, `[${p4.toLowerCase()}]`).diceString;
    return `${p1 ? p1 : ""}[[/r ${diceString} # ${dmgString}]]${p3} damage`;
  } else if (p5 && p1 && p5.toLowerCase() === "points" && p1.toLowerCase() === "regains") {
    const diceString = utils/* default.parseDiceString */.Z.parseDiceString(p2, null, "[healing]").diceString;
    return `${p1 ? p1 : ""}[[/r ${diceString} # Healing]]${p3} hit points`;
  } else {
    const diceString = utils/* default.parseDiceString */.Z.parseDiceString(p2).diceString;
    const result = `${p1 ? p1 : ""}[[/r ${diceString}]]${p3 ? p3 : ""} ${p4 ? p4 : ""} ${p5 ? p5 : ""}`.trim();
    return result;
  }
}

function replaceRollLinks(text) {
  text = text.replace(/[Â­â€“â€“âˆ’-]/gu, "-").replace(/-+/g, "-");
  const damageRegex = new RegExp(/([.>( ^]|^|regains +)?(\d*d\d+(?:\s*[+-]\s*\d*d*\d*)*)([.,<)]|$| +) *([a-z,A-Z]*) *(damage|points)?/, "g");
  text = text.replace(damageRegex, diceRollMatcher);

  // const Regex
  // to hit rolls
  const toHitRegex = new RegExp(/ ([+-]) *(\d+) to hit/, "g");
  text = text.replace(toHitRegex, " [[/r 1d20 $1 $2]] to hit");
  return text;
}

function findDiceColumns(table) {
  let result = [];
  if (table.tHead) {
    const headings = getHeadings(table);
    headings.forEach((h) => {
      const diceRegex = new RegExp(/(\d*[d|D]\d+(\s*[+-]?\s*\d*)?)/, "g");
      const match = h.replace(/[Â­â€“â€“âˆ’-]/gu, "-").replace(/-+/g, "-").match(diceRegex);
      if (match) {
        result.push(h);
      }
    });
  }
  return result;
}

function guessTableName(parentName, htmlDocument, tableNum) {
  const element = htmlDocument.querySelectorAll('table');
  let track = element[tableNum];
  let sibling = track.previousElementSibling;

  while (!sibling && track.parentElement?.nodeName === "DIV") {
    if (!track.parentElement.previousElementSibling) {
      track = track.parentElement;
    } else {
      sibling = track.parentElement.previousElementSibling;
    }
  }

  if (sibling) {
    return sibling.textContent;
  } else {
    logger/* default.warn */.Z.warn(`No table name identified for ${parentName}`);
    return "";
  }
}


function tableReplacer(htmlDocument, tableNum, compendiumTables) {
  // future enhancement - replace liks to DDB spells, monsters, items etc to munched compendium
  const element = htmlDocument.querySelectorAll('table');
  const tablePoint = element[tableNum];

  if (tablePoint) {
    const rollCompendiumLabel = game.settings.get("ddb-importer", "entity-table-compendium");
    compendiumTables.slice().reverse().forEach((table) => {
      logger/* default.debug */.Z.debug(`Updating table reference for: ${table.name}`);
      tablePoint.insertAdjacentHTML("afterend", `<div id="table-link">@Compendium[${rollCompendiumLabel}.${table.name}]{Open RollTable ${table.name}}</div>`);
    });
   }

  return htmlDocument;
}


function diceInt(text) {
  if (text === "0") return 10;
  if (text === "00") return 100;
  return parseInt(text);
}

/**
 * This could be:
 * a single value e.g. 19
 * a range of values 19-20
 * remaining values 19+
 * @param {*} value
 * @returns array of range
 */
function getDiceTableRange(value) {
  const document = utils/* default.htmlToDoc */.Z.htmlToDoc(value);
  const text = document.body.textContent.replace(/[Â­â€“â€“âˆ’-]/gu, "-").replace(/-+/g, "-").replace(/\s/g, "").trim();
  // eslint-disable-next-line no-useless-escape
  const valueRegex = new RegExp(/^(\d+)\-(\d+)|^(\d+)(\+?)$/);
  const valueMatch = text.match(valueRegex);

  if (valueMatch) {
    if (valueMatch[1] !== undefined && valueMatch[2] !== undefined) {
      const low = diceInt(valueMatch[1]);
      const high = diceInt(valueMatch[2]);
      return [low, high];
    }

    if (valueMatch[3]) {
      if (valueMatch[4] !== undefined && valueMatch[4] === "+") {
        const low = diceInt(valueMatch[3]);
        return [low, 0];
      }
      if (valueMatch[4] !== undefined && valueMatch[4] === "") {
        const low = diceInt(valueMatch[3]);
        return [low, low];
      }
    }
  }

  // logger.debug(`Dice range: Unable to table range match '${value}' text was '${text}'`);
  return [];
}


function buildTable(parsedTable, keys, diceKeys, tableName, parentName) {
  let generatedTables = [];

  diceKeys.forEach((diceKey) => {
    const nameExtension = diceKeys > 1 ? ` [${diceKeys}]` : "";
    const realName = ((tableName && tableName !== "") ? tableName : "Unnamed Table") + nameExtension;
    logger/* default.debug */.Z.debug(`Generating table ${realName}`);

    const diceRegex = new RegExp(/(\d*d\d+(\s*[+-]?\s*\d*d*\d*)?)/, "g");
    const formulaMatch = diceKey.match(diceRegex);

    let table = {
      "name": realName,
      "sort": 100000,
      "flags": {
        "ddbimporter": {
          "parentName": parentName,
          "keys": keys,
          "diceKeys": diceKeys
        }
      },
      "img": "icons/svg/d20-grey.svg",
      "description": "",
      "results": [],
      "formula": formulaMatch ? formulaMatch[0].trim() : "",
      "replacement": true,
      "displayRoll": true,
    };

    const concatKeys = (keys.length - diceKeys.length) > 1;
    // loop through rows and build result entry.
    // if more than one result key then we will concat the results.
    parsedTable.forEach((entry) => {
      const result = {
        flags: {},
        type: 0,
        text: "",
        img: "icons/svg/d20-black.svg",
        resultId: "",
        weight: 1,
        range: [],
        drawn: false
      };
      Object.entries(entry).forEach(([key, value]) => {
        if (key === diceKey) {
          result.range = getDiceTableRange(value);
        } else if (diceKeys.includes(key)) return;
        if (concatKeys) {
          if (result.text != "") result.text += "\n\n";
          result.text += `<b>${key}</b>${value}`;
        } else {
          result.text = value;
        }
      });
      result.text = replaceRollLinks(result.text);
      const diceRollerRegexp = new RegExp(/\[\[\/r\s*([0-9d+-\s]*)(:?#.*)?\]\]/);
      result.text = result.text.replace(diceRollerRegexp, "[[$1]] ($&)");
      table.results.push(result);
    });

    generatedTables.push(table);

  });

  return generatedTables;
}

var tables = {};

function generateTable(parentName, html, updateExisting) {
  const document = utils/* default.htmlToDoc */.Z.htmlToDoc(html);
  const tableNodes = document.querySelectorAll("table");
  let tablesMatched = [];
  let updatedDocument = utils/* default.htmlToDoc */.Z.htmlToDoc(html);
  if (parentName.startsWith("Background:")) {
    const parentNamesArray = parentName.split(":");
    parentNamesArray.pop();
    parentName = parentNamesArray.join(":");
  }

  let tableNum = 0;
  tableNodes.forEach((node) => {
  // for (let i = 0; i < tableNodes.length; i++) {
    // const node = tableNodes[i];
    const parsedTable = parseTable(node);
    const keys = getHeadings(node);
    const diceKeys = findDiceColumns(node);
    let nameGuess = guessTableName(parentName, document, tableNum);
    if (nameGuess.split(" ").length > 5 && diceKeys.length === 1 && keys.length === 2) {
      nameGuess = keys[1];
    }
    const finalName = `${parentName}: ${nameGuess}`;
    const tableGenerated = (finalName in tables);

    logger/* default.debug */.Z.debug(`Table detection triggered for ${parentName}!`);
    logger/* default.debug */.Z.debug(`Table: "${finalName}"`);
    logger/* default.debug */.Z.debug(`Dice Keys: ${diceKeys.join(", ")}`);
    logger/* default.debug */.Z.debug(`Keys: ${keys.join(", ")}`);

    const builtTables = tableGenerated
      ? tables[finalName]
      : buildTable(parsedTable, keys, diceKeys, finalName, parentName);

    if (builtTables.length > 0) {
      // these updates are done async, and we continue. this is fine as we actually use the table name for linking
      if (!tableGenerated) {
        tables[finalName] = builtTables;
        (0,muncher_import/* updateCompendium */.X)("tables", { tables: builtTables }, updateExisting);
      }

      let tableData = {
        nameGuess,
        finalName,
        parentName,
        tableNum,
        length: parsedTable.length,
        keys: keys,
        diceKeys: diceKeys,
        diceTable: diceKeys.length > 0,
        multiDiceKeys: diceKeys.length > 1,
        diceKeysNumber: diceKeys.length,
        totalKeys: keys.length,
        builtTables: tables[finalName],
      };
      tablesMatched.push(tableData);
      updatedDocument = tableReplacer(updatedDocument, tableNum, tableData.builtTables);

    }
    tableNum++;
  // }
  });

  return updatedDocument.body.innerHTML;

}


/***/ }),

/***/ 192:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "qd": () => (/* binding */ BAD_DIRS),
/* harmony export */   "LR": () => (/* binding */ download),
/* harmony export */   "ep": () => (/* binding */ munchNote),
/* harmony export */   "F9": () => (/* binding */ getCampaignId),
/* harmony export */   "X": () => (/* binding */ getPatreonTier),
/* harmony export */   "my": () => (/* binding */ getPatreonValidity),
/* harmony export */   "A1": () => (/* binding */ getPatreonTiers),
/* harmony export */   "$j": () => (/* binding */ checkPatreon),
/* harmony export */   "Q1": () => (/* binding */ setPatreonTier)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(259);


const BAD_DIRS = ["[data]", "[data] ", "", null];

function download(content, fileName, contentType) {
  var a = document.createElement("a");
  var file = new Blob([content], { type: contentType });
  a.href = URL.createObjectURL(file);
  a.download = fileName;
  a.click();
}

/**
 * Display information when Munching
 * @param {*} note
 * @param {*} nameField
 */
function munchNote(note, nameField = false, monsterNote = false) {
  if (nameField) {
    $('#munching-task-name').text(note);
    $('#ddb-importer-monsters').css("height", "auto");
  } else if (monsterNote) {
    $('#munching-task-monster').text(note);
    $('#ddb-importer-monsters').css("height", "auto");
  } else {
    $('#munching-task-notes').text(note);
    $('#ddb-importer-monsters').css("height", "auto");
  }
}

function getCampaignId() {
  const campaignId = game.settings.get("ddb-importer", "campaign-id").split('/').pop();

  if (campaignId && campaignId !== "" && !Number.isInteger(parseInt(campaignId))) {
    munchNote(`Campaign Id is invalid! Set to "${campaignId}", using empty string`, true);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.error */ .Z.error(`Campaign Id is invalid! Set to "${campaignId}", using empty string`);
    return "";
  } else if (campaignId.includes("join")) {
    munchNote(`Campaign URL is a join campaign link, using empty string! Set to "${campaignId}"`, true);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .default.error */ .Z.error(`Campaign URL is a join campaign link, using empty string! Set to "${campaignId}"`);
    return "";
  }
  return campaignId;
}

async function getPatreonTier() {
  const customProxy = game.settings.get("ddb-importer", "custom-proxy");
  if (customProxy) return { success: true, message: "custom proxy", data: "CUSTOM" };
  const key = game.settings.get("ddb-importer", "beta-key");
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const body = { betaKey: key };

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/patreon/tier`, {
      method: "POST",
      mode: "cors",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (!data.success) {
          munchNote(`API Failure: ${data.message}`);
          reject(data.message);
        }
        resolve(data.data);
      })
      .catch((error) => reject(error));
  });
}

async function getPatreonValidity(betaKey) {
  const customProxy = game.settings.get("ddb-importer", "custom-proxy");
  if (customProxy) return { success: true, message: "custom proxy", data: true };
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const body = { betaKey: betaKey };

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/patreon/valid`, {
      method: "POST",
      mode: "cors",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        resolve(data);
      })
      .catch((error) => reject(error));
  });
}

function getPatreonTiers(tier) {
  const godTier = tier === "GOD";
  const undyingTier = tier === "UNDYING";
  const coffeeTier = tier === "COFFEE";
  const customProxy = game.settings.get("ddb-importer", "custom-proxy");
  const custom = tier === "CUSTOM" || customProxy;

  const tiers = {
    god: godTier,
    undying: undyingTier,
    custom: custom,
    coffee: coffeeTier,
    source: godTier || undyingTier || coffeeTier || custom,
    experimentalMid: godTier || undyingTier,
    homebrew: godTier || undyingTier || coffeeTier || custom,
    all: godTier || undyingTier || coffeeTier || custom,
    supporter: godTier || undyingTier || coffeeTier,
    not: !godTier && !undyingTier && !coffeeTier && !custom,
  };

  return tiers;
}

async function checkPatreon() {
  const tier = await getPatreonTier();
  const tiers = getPatreonTiers(tier);
  return tiers;
}

async function setPatreonTier() {
  const tier = await getPatreonTier();
  game.settings.set("ddb-importer", "patreon-tier", tier);
}


/***/ }),

/***/ 248:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "xg": () => (/* binding */ getProficiencies),
/* harmony export */   "jZ": () => (/* binding */ getArmorProficiencies),
/* harmony export */   "bX": () => (/* binding */ getToolProficiencies),
/* harmony export */   "JN": () => (/* binding */ getWeaponProficiencies),
/* harmony export */   "PR": () => (/* binding */ getLanguagesFromModifiers),
/* harmony export */   "Vb": () => (/* binding */ getLanguages)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(555);
/* harmony import */ var _ddbConfig_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);





function getCustomProficiencies(data, type) {
  const profGroup = _ddbConfig_js__WEBPACK_IMPORTED_MODULE_2__/* .DDB_CONFIG.proficiencyGroups.find */ .U.proficiencyGroups.find((group) => group.label == type);
  const profCharacterValues = data.character.characterValues.filter(
    (value) =>
      profGroup.customAdjustments.includes(parseInt(value.typeId)) &&
      profGroup.entityTypeIds.includes(parseInt(value.valueTypeId)) &&
      value.value == 3
  );
  const customProfs = _ddbConfig_js__WEBPACK_IMPORTED_MODULE_2__/* .DDB_CONFIG */ .U[type.toLowerCase()]
    .filter((prof) => profCharacterValues.some((value) => value.valueId == prof.id))
    .map((prof) => prof.name);

  return customProfs;
}

function getProficiencies(data, includeItemEffects = false) {
  const coreProficiencies = _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.filterBaseModifiers */ .Z.filterBaseModifiers(data, "proficiency", null, null, includeItemEffects)
   .map((proficiency) => {
    return { name: proficiency.friendlySubtypeName };
  });

  const customProficiencies = [
    ...getCustomProficiencies(data, "Armor"),
    ...getCustomProficiencies(data, "Tools"),
    ...getCustomProficiencies(data, "Weapons"),
    ...getCustomProficiencies(data, "Languages"),
  ].map((proficiency) => {
    return { name: proficiency };
  });
  const proficiencies = coreProficiencies.concat(customProficiencies);

  return proficiencies;
}

function getArmorProficiencies(data, proficiencyArray) {
  let values = [];
  let custom = [];

  // lookup the characters's proficiencies in the DICT
  let allProficiencies = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* .default.character.proficiencies.filter */ .Z.character.proficiencies.filter((prof) => prof.type === "Armor");
  proficiencyArray.forEach((prof) => {
    if (prof.name === "Light Armor" && !values.includes("lgt")) {
      values.push("lgt");
    }
    if (prof.name === "Medium Armor" && !values.includes("med")) {
      values.push("med");
    }
    if (prof.name === "Heavy Armor" && !values.includes("hvy")) {
      values.push("hvy");
    }
    if (prof.name === "Shields" && !values.includes("shl")) {
      values.push("shl");
    }
    if (allProficiencies.find((p) => p.name === prof.name) !== undefined && !custom.includes(prof.name)) {
      custom.push(prof.name);
    }
  });

  if (data) {
    // load custom proficiencies in characterValues
    const customProfs = getCustomProficiencies(data, "Armor");
    custom = custom.concat(customProfs);
  }
  return {
    value: [...new Set(values)],
    custom: [...new Set(custom)].join(";"),
  };
}

//
// DND5E.toolProficiencies = {
// "art": "Artisan's Tools",
// "disg": "Disguise Kit",
// "forg": "Forgery Kit",
// "game": "Gaming Set",
// "herb": "Herbalism Kit",
// "music": "Musical Instrument",
// "navg": "Navigator's Tools",
// "pois": "Poisoner's Kit",
// "thief": "Thieves' Tools",
// "vehicle": "Vehicle (Land or Water)"
// };
//
function getToolProficiencies(data, proficiencyArray) {
  let values = [];
  let custom = [];

  // lookup the characters's proficiencies in the DICT
  let allToolProficiencies = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* .default.character.proficiencies.filter */ .Z.character.proficiencies.filter((prof) => prof.type === "Tool")
    .map((prof) => {
      return prof.name;
    });

    proficiencyArray.forEach((prof) => {
    // Some have values we can match too in foundry, others have to be custom imported
    switch (prof.name) {
      case "Artisan's Tools":
        values.push("art");
        break;
      case "Disguise Kit":
        values.push("disg");
        break;
      case "Forgery Kit":
        values.push("forg");
        break;
      case "Gaming Set":
        values.push("game");
        break;
      case "Musical Instrument":
        values.push("music");
        break;
      case "Thieves' Tools":
        values.push("thief");
        break;
      case "Navigator's Tools":
        values.push("navg");
        break;
      case "Poisoner's Kit":
        values.push("pois");
        break;
      case "Vehicle (Land or Water)":
      case "Vehicle (Land)":
      case "Vehicle (Water)":
        values.push("vehicle");
        break;
      default:
        if (allToolProficiencies.includes(prof.name)) custom.push(prof.name);
    }
  });

  if (data) {
    // Custom proficiencies!
    data.character.customProficiencies.forEach((proficiency) => {
      if (proficiency.type === 2) {
        // type 2 is TOOL, 1 is SKILL, 3 is LANGUAGE
        custom.push(proficiency.name);
      }
    });

    // load custom proficiencies in characterValues
    const customProfs = getCustomProficiencies(data, "Tools");
    custom = custom.concat(customProfs);
  }

  return {
    value: [...new Set(values)],
    custom: [...new Set(custom)].join(";"),
  };
}

function getWeaponProficiencies(data, proficiencyArray) {
  let values = [];
  let custom = [];

  // lookup the characters's proficiencies in the DICT
  let allProficiencies = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* .default.character.proficiencies.filter */ .Z.character.proficiencies.filter((prof) => prof.type === "Weapon");
  proficiencyArray.forEach((prof) => {
    if (prof.name === "Simple Weapons" && !values.includes("sim")) {
      values.push("sim");
    }
    if (prof.name === "Martial Weapons" && !values.includes("mar")) {
      values.push("mar");
    }
    if (allProficiencies.find((p) => p.name === prof.name) !== undefined && !custom.includes(prof.name)) {
      custom.push(prof.name);
    }
  });

  if (data) {
    // load custom proficiencies in characterValues
    const customProfs = getCustomProficiencies(data, "Weapons");
    custom = custom.concat(customProfs);
  }

  return {
    value: [...new Set(values)],
    custom: [...new Set(custom)].join("; "),
  };
}

function getLanguagesFromModifiers(data, modifiers) {
  let languages = [];
  let custom = [];

  modifiers
  .filter((mod) => mod.type === "language")
  .forEach((language) => {
    let result = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* .default.character.languages.find */ .Z.character.languages.find((lang) => lang.name === language.friendlySubtypeName);
    if (result) {
      languages.push(result.value);
    } else {
      custom.push(language.friendlySubtypeName);
    }
  });

  if (data) {
    data.character.customProficiencies.forEach((proficiency) => {
      if (proficiency.type === 3) {
        // type 3 is LANGUAGE, 1 is SKILL, 2 is TOOL
        custom.push(proficiency.name);
      }
    });

    // load custom proficiencies in characterValues
    const customProfs = getCustomProficiencies(data, "Languages");
    custom = custom.concat(customProfs);
  }

  return {
    value: languages,
    custom: custom.map((entry) => _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.capitalize */ .Z.capitalize(entry)).join(";"),
  };
}

function getLanguages(data) {
  const modifiers = _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.filterBaseModifiers */ .Z.filterBaseModifiers(data, "language");

  return getLanguagesFromModifiers(data, modifiers);
}


/***/ }),

/***/ 597:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M": () => (/* binding */ getSkillProficiency),
/* harmony export */   "S": () => (/* binding */ getSkills)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(555);
/* harmony import */ var _effects_effects_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(908);




let isHalfProficiencyRoundedUp = (data, skill, modifiers = null) => {
  const longAbility = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* .default.character.abilities.filter */ .Z.character.abilities.filter((ability) => skill.ability === ability.value)
    .map((ability) => ability.long)[0];

  const roundUp = (modifiers)
    ? _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.filterModifiers */ .Z.filterModifiers(modifiers, "half-proficiency-round-up", `${longAbility}-ability-checks`)
    : _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.filterBaseModifiers */ .Z.filterBaseModifiers(data, "half-proficiency-round-up", `${longAbility}-ability-checks`, ["", null], true);
  return Array.isArray(roundUp) && roundUp.length;
};

function getSkillProficiency (data, skill, modifiers = null) {
  if (!modifiers) {
    modifiers = [
      _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.getChosenClassModifiers */ .Z.getChosenClassModifiers(data, true),
      _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.getModifiers */ .Z.getModifiers(data, "race", true),
      _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.getModifiers */ .Z.getModifiers(data, "background", true),
      _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.getModifiers */ .Z.getModifiers(data, "feat", true),
      _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.getActiveItemModifiers */ .Z.getActiveItemModifiers(data, true),
    ].flat();
  }

  const skillMatches = modifiers
    .filter((modifier) => modifier.friendlySubtypeName === skill.label)
    .map((mod) => mod.type);

  const halfProficiency = modifiers.find(
      (modifier) =>
        // Jack of All trades/half-rounded down
        (modifier.type === "half-proficiency" && modifier.subType === "ability-checks") ||
        // e.g. champion for specific ability checks
        isHalfProficiencyRoundedUp(data, skill, modifiers)
    ) !== undefined
      ? 0.5
      : 0;

  const proficient = skillMatches.includes("expertise") ? 2 : skillMatches.includes("proficiency") ? 1 : halfProficiency;

  return proficient;
}

let getCustomSkillProficiency = (data, skill) => {
  // Overwrite the proficient value with any custom set over rides
  if (data.character.characterValues) {
    const customProficiency = data.character.characterValues.find(
      (value) => value.typeId === 26 && value.valueId == skill.valueId && value.value
    );
    if (customProficiency) {
      return _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* .default.character.customSkillProficiencies.find */ .Z.character.customSkillProficiencies.find((prof) => prof.value === customProficiency.value)
        .proficient;
    }
  }
  return undefined;
};

let getCustomSkillAbility = (data, skill) => {
  // Overwrite the proficient value with any custom set over rides
  let mod;
  if (data.character.characterValues) {
    const customAbility = data.character.characterValues.find(
      (value) => value.typeId === 27 && value.valueId == skill.valueId
    );
    if (customAbility) {
      const ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* .default.character.abilities.find */ .Z.character.abilities.find((ability) => ability.id == customAbility.value);
      if (ability) mod = ability.value;
    }
  }
  return mod;
};

let getCustomSkillBonus = (data, skill) => {
  // Get any custom skill bonuses
  if (data.character.characterValues) {
    const customBonus = data.character.characterValues.filter(
      (value) => (value.typeId == 24 || value.typeId == 25) && value.valueId == skill.valueId
    ).reduce((total, bonus) => {
      return total + bonus.value;
    }, 0);

    if (customBonus) {
      return customBonus;
    }
  }
  return 0;
};


function getSkills(data, character) {
  let result = {};

  const addEffects = _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.isModuleInstalledAndActive */ .Z.isModuleInstalledAndActive("dae");

  if (!addEffects) character.flags['skill-customization-5e'] = {};
  _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* .default.character.skills.forEach */ .Z.character.skills.forEach((skill) => {
    const customProficient = getCustomSkillProficiency(data, skill);
    // we use !== undefined because the return value could be 0, which is falsey
    const proficient = customProficient !== undefined ? customProficient : getSkillProficiency(data, skill);

    // some abilities round half prof up, some down
    const proficiencyBonus = isHalfProficiencyRoundedUp(data, skill)
      ? Math.ceil(2 * character.data.attributes.prof * proficient)
      : Math.floor(2 * character.data.attributes.prof * proficient);

    // Skill bonuses e.g. items
    // These no longer seems to be picked up in recent versions of the DND5e module
    const skillModifierBonus = _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.filterBaseModifiers */ .Z.filterBaseModifiers(data, "bonus", skill.subType)
      .map((skl) => skl.value)
      .reduce((a, b) => a + b, 0) || 0;
    const customSkillBonus = getCustomSkillBonus(data, skill);
    const skillBonus = skillModifierBonus + customSkillBonus;

    if (addEffects && skillBonus && skillBonus > 0) {
      const label = "Misc Skill Bonuses";
      const change = {
        key: `data.skills.${skill.name}.mod`,
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        value: skillBonus,
        priority: 20
      };

      const changeIndex = character.effects.findIndex((effect) => effect.label === label);
      if (changeIndex >= 0) {
        character.effects[changeIndex].changes.push(change);
      } else {
        let skillEffect = (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_2__/* .generateBaseSkillEffect */ .Tb)(data.character.id, label);
        skillEffect.changes.push(change);
        character.effects.push(skillEffect);
      }

    } else if (skillBonus && skillBonus > 0) {
      character.flags['skill-customization-5e'][skill.name] = {
        "skill-bonus": skillBonus
      };
    }

    const value = character.data.abilities[skill.ability].value + proficiencyBonus + skillBonus;

    const customAbility = getCustomSkillAbility(data, skill);
    const ability = customAbility !== undefined ? customAbility : skill.ability;

    // custom skill ability over ride effects
    if (customAbility) {
      const label = "Skill Ability Changes";
      const change = {
        key: `data.skills.${skill.name}.ability`,
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: `${customAbility}`,
        priority: "20"
      };

      const changeIndex = character.effects.findIndex((effect) => effect.label === label);
      if (changeIndex >= 0) {
        character.effects[changeIndex].changes.push(change);
      } else {
        let skillEffect = (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_2__/* .generateBaseSkillEffect */ .Tb)(data.character.id, label);
        skillEffect.changes.push(change);
        character.effects.push(skillEffect);
      }
    }

    result[skill.name] = {
      type: "Number",
      label: skill.label,
      ability: ability,
      value: proficient,
      mod: _utils_js__WEBPACK_IMPORTED_MODULE_1__/* .default.calculateModifier */ .Z.calculateModifier(value),
      bonus: skillBonus,
    };
  });

  return result;
}




/***/ }),

/***/ 419:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LY": () => (/* binding */ generateFixedACEffect),
/* harmony export */   "qI": () => (/* binding */ generateACEffectChangesForItem),
/* harmony export */   "se": () => (/* binding */ generateBaseACItemEffect)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(555);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(259);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _effects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(908);





  // // ac -
  // { type: "bonus", subType: "armor-class" },
  // // e.g. robe of the archm
  // { type: "set", subType: "unarmored-armor-class" },
  // // bracers of defence
  // { type: "bonus", subType: "unarmored-armor-class" },

/**
 *
 * @param {*} label
 */
function buildBaseACEffect(label) {
  let effect = {
    changes: [],
    duration: {
      seconds: null,
      startTime: null,
      rounds: null,
      turns: null,
      startRound: null,
      startTurn: null,
    },
    origin: null,
    label,
    tint: "",
    disabled: true,
    transfer: true,
    selectedKey: [],
    icon: "icons/svg/shield.svg",
  };
  return effect;
}

/**
 *
 * Generate an effect given inputs for AC
 * This is a high priority set effect that will typically override all other AE.
 * @param {*} formula
 * @param {*} label
 * @param {*} alwaysActive
 * @param {*} priority
 * @param {*} mode
 */
function generateFixedACEffect(formula, label, alwaysActive = false, priority = 30, mode = CONST.ACTIVE_EFFECT_MODES.OVERRIDE) {
  let effect = buildBaseACEffect(label);

  effect.flags = {
    dae: { transfer: true, armorEffect: true },
    ddbimporter: { disabled: !alwaysActive, itemId: null, entityTypeId: null, characterEffect: true },
  };
  // effect.disabled = !alwaysActive;
  effect.disabled = false;
  effect.origin = "AC";

  const change = {
    key: "data.attributes.ac.value",
    value: formula,
    mode,
    priority,
  };

  effect.changes.push(change);

  return effect;
}

/**
 * Generate stat sets
 *
 * @param {*} modifiers
 * @param {*} name
 * @param {*} subType
 */
function addACSetEffect(modifiers, name, subType) {
  let bonuses;

  if (modifiers.some((mod) => mod.statId !== null && mod.type === "set" && mod.subType === subType)) {
    modifiers.filter((mod) => mod.statId !== null && mod.type === "set" && mod.subType === subType)
      .forEach((mod) => {
        const ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* .default.character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === mod.statId);
        if (bonuses) {
          bonuses += " ";
        } else {
          bonuses = "";
        }
        bonuses += `@abilities.${ability.value}.mod`;
      });
  } else {
    // others are picked up here e.g. Draconic Resilience
    const fixedValues = modifiers.filter((mod) => mod.type === "set" && mod.subType === subType).map((mod) => mod.value);
    bonuses = Math.max(fixedValues);
  }

  let effects = [];
  const maxDexTypes = ["ac-max-dex-unarmored-modifier", "ac-max-dex-modifier"];

  if (bonuses && bonuses != 0) {
    let effectString = "";
    switch (subType) {
      case "unarmored-armor-class": {
        let maxDexMod = 99;
        const ignoreDexMod = modifiers.some((mod) => mod.type === "ignore" && mod.subType === "unarmored-dex-ac-bonus");
        const maxDexArray = modifiers
          .filter((mod) => mod.type === "set" && maxDexTypes.includes(mod.subType))
          .map((mod) => mod.value);
        if (maxDexArray.length > 0) maxDexMod = Math.min(maxDexArray);
        if (ignoreDexMod) {
          effectString = `10 + ${bonuses}`;
        } else {
          effectString = `@abilities.dex.mod > ${maxDexMod} ? 10 + ${bonuses} + ${maxDexMod} : 10 + ${bonuses} + @abilities.dex.mod`;
        }
        break;
      }
      default: {
        effectString = `10 + ${bonuses} + @abilities.dex.mod`;
      }
    }

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Generating ${subType} AC set for ${name}: ${effectString}`);
    effects.push(
      (0,_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .generateUpgradeChange */ .OY)(
        effectString,
        15,
        "data.attributes.ac.value"
      )
    );
  }
  return effects;
}

/**
 *
 * @param {*} modifiers
 * @param {*} name
 */
function addACSets(modifiers, name) {
  let changes = [];
  const stats = ["unarmored-armor-class"];
  stats.forEach((set) => {
    const result = addACSetEffect(modifiers, name, set);
    changes = changes.concat(result);
  });

  return changes;
}

/**
 * Generates an AC bonus for an item
 *
 * @param {*} modifiers
 * @param {*} name
 * @param {*} type
 */
function addACBonusEffect(modifiers, name, type) {
  let changes = [];
  const restrictions = [
    "while wearing heavy armor",
    "",
    null,
  ];
  const bonus = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.filterModifiers */ .Z.filterModifiers(modifiers, "bonus", type, restrictions).reduce((a, b) => a + b.value, 0);
  if (bonus !== 0) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Generating ${type} bonus for ${name}`);
    const AUTO_AC = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.versionCompare */ .Z.versionCompare(game.data.system.data.version, "1.4.0") >= 0;
    if (AUTO_AC) {
      const daeInstalled = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.isModuleInstalledAndActive */ .Z.isModuleInstalledAndActive("dae");
      // using bonus here adds them to the bonus field, but then items that add a bonsu don't get applied
      // (e.g. bracers of defense) if wearing something like robi of archmage.
      // this is set to value, and show up as separate line in ac calculation.
      // we set this to bonus if dae is not installed as itherwise it is not applied.
      if (daeInstalled) {
        changes.push((0,_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .generateAddChange */ .R5)(bonus, 18, "data.attributes.ac.value"));
      } else {
        changes.push((0,_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .generateAddChange */ .R5)(bonus, 18, "data.attributes.ac.bonus"));
      }
    } else {
      changes.push((0,_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .generateAddChange */ .R5)(bonus, 18, "data.attributes.ac.value"));
    }
  }
  return changes;
}


function addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem) {
  if (
    isCompendiumItem ||
    foundryItem.type === "feat" ||
    (ddbItem.isAttuned && ddbItem.equipped) || // if it is attuned and equipped
    (ddbItem.isAttuned && !ddbItem.definition.canEquip) || // if it is attuned but can't equip
    (!ddbItem.definition.canAttune && ddbItem.equipped) // can't attune but is equipped
  ) {
    setProperty(foundryItem, "flags.dae.alwaysActive", false);
    setProperty(effect, "flags.ddbimporter.disabled", false);
    effect.disabled = false;
  } else {
    effect.disabled = true;
    setProperty(effect, "flags.ddbimporter.disabled", true);
    setProperty(foundryItem, "flags.dae.alwaysActive", false);
  }

  setProperty(effect, "flags.ddbimporter.itemId", ddbItem.id);
  setProperty(effect, "flags.ddbimporter.itemEntityTypeId", ddbItem.entityTypeId);
  // set dae flag for active equipped
  if (ddbItem.definition?.canEquip || ddbItem.definition?.canAttune) {
    setProperty(foundryItem, "flags.dae.activeEquipped", true);
  } else {
    setProperty(foundryItem, "flags.dae.activeEquipped", false);
  }

  return [foundryItem, effect];
}

function generateBaseACEffectChanges(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect) {
  const noModifiers = !ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0;
  const noACValue = !foundryItem.data?.armor?.value;
  const daeInstalled = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.isModuleInstalledAndActive */ .Z.isModuleInstalledAndActive("dae");
  const daeBonusField = daeInstalled ? "data.attributes.ac.value" : "data.attributes.ac.bonus";

  if (noModifiers && noACValue) return [];
  // console.error(`Item: ${foundryItem.name}`, ddbItem);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Generating supported AC changes for ${foundryItem.name} for effect ${effect.label}`);

  // base ac from modifiers
  const acSets = daeInstalled ? addACSets(ddbItem.definition.grantedModifiers, foundryItem.name) : [];

  // ac bonus effects
  const acBonus = addACBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "armor-class",
    daeBonusField
  );
  const unarmoredACBonus = addACBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "unarmored-armor-class",
    daeBonusField
  );
  const armoredACBonus = addACBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "armored-armor-class",
    daeBonusField
  );
  const dualWieldACBonus = addACBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "dual-wield-armor-class",
    daeBonusField
  );

  const acChanges = [
    ...acSets,
    ...acBonus,
    ...unarmoredACBonus,
    ...armoredACBonus,
    ...dualWieldACBonus,
  ];

  return acChanges;

}

// generates changes and adds to effect for item
function generateACEffectChangesForItem(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect) {
  const noModifiers = !ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0;

  if (noModifiers) return [foundryItem, effect];

  const acChanges = generateBaseACEffectChanges(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect);

  if (acChanges.length === 0) return [foundryItem, effect]; ;

  effect.changes = effect.changes.concat(acChanges);

  // generate flags for effect (e.g. checking attunement and equipped status)
  [foundryItem, effect] = addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem);

  return [foundryItem, effect];

}

/**
 *
 * @param {*} ddb
 * @param {*} character
 * @param {*} ddbItem
 * @param {*} foundryItem
 * @param {*} isCompendiumItem
 */
function generateBaseACItemEffect(ddb, character, ddbItem, foundryItem, isCompendiumItem) {
  const noModifiers = !ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0;
  const noACValue = !foundryItem.data?.armor?.value;

  if (noModifiers && noACValue) return foundryItem;
  // console.error(`Item: ${foundryItem.name}`, ddbItem);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Generating supported AC effects for ${foundryItem.name}`);

  let effect = (0,_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .baseItemEffect */ .uT)(foundryItem, `AC: ${foundryItem.name}`);

  // generate flags for effect (e.g. checking attunement and equipped status)
  [foundryItem, effect] = generateACEffectChangesForItem(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect);

  if (effect.changes?.length > 0) {
    if (!foundryItem.effects) foundryItem.effects = [];
    foundryItem.effects.push(effect);
  }
  return foundryItem;
}


/***/ }),

/***/ 908:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "uT": () => (/* binding */ baseItemEffect),
  "R5": () => (/* binding */ generateAddChange),
  "Tb": () => (/* binding */ generateBaseSkillEffect),
  "wv": () => (/* binding */ generateCustomChange),
  "K7": () => (/* binding */ generateEffects),
  "zs": () => (/* binding */ generateMultiplyChange),
  "Pk": () => (/* binding */ generateOverrideChange),
  "OY": () => (/* binding */ generateUpgradeChange),
  "qk": () => (/* binding */ getEffectExcludedModifiers)
});

// UNUSED EXPORTS: generateChange, generateCustomBonusChange, generateDowngradeChange

// EXTERNAL MODULE: ./src/utils.js
var utils = __webpack_require__(555);
// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(259);
// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
// EXTERNAL MODULE: ./src/parser/character/proficiencies.js
var character_proficiencies = __webpack_require__(248);
// EXTERNAL MODULE: ./src/parser/character/skills.js
var skills = __webpack_require__(597);
;// CONCATENATED MODULE: ./src/parser/effects/specialEquipment.js


/**
 * This function is mainly for effects that can't be dynamically generated
 * @param {*} document
 */
function equipmentEffectAdjustment(document) {
  switch (document.name) {
    case "Armor of Invulnerability": {
      // this effect is 1/day, we have to add it
      let effect = baseItemEffect(document, `${document.name} - Invulnerability`);
      effect.changes.push(generateAddChange("physical", 20, "data.traits.di.value"));
      effect.duration = {
        startTime: null,
        seconds: 600,
        rounds: null,
        turns: null,
        startRound: null,
        startTurn: null,
      };
      effect.transfer = false;
      effect.disabled = false;
      effect.flags.dae.transfer = false;
      effect.flags.dae.stackable = false;
      effect.flags.dae.specialDuration = "None";
      document.data.uses = {
        value: 1,
        max: "1",
        per: "day",
      };
      document.data.target = {
        value: null,
        width: null,
        units: "",
        type: "self",
      };
      document.data.range = {
        value: null,
        long: null,
        units: "self",
      };
      document.effects.push(effect);
      break;
    }
    case "Bracers of Archery": {
      // +2 damage to longbows/shortbows translates to +2 ranged weapon damage
      document.effects[0].changes.push({
        key: "data.bonuses.rwak.damage",
        value: "+2",
        mode: 0,
        priority: 20,
      });
      break;
    }
    case "Demon Armor": {
      // Unarmed strikes bonus/weapons
      document.effects[0].changes.push(
        {
          key: "items.Unarmed Strike.data.attackBonus",
          value: "1",
          mode: 2,
          priority: 20,
        },
        {
          key: "items.Unarmed Strike.data.damage.parts.0.0",
          value: "1d8+@mod+1",
          mode: 5,
          priority: 20,
        },
        {
          key: "items.Unarmed Strike.data.properties.mgc",
          value: "true",
          mode: 5,
          priority: 20,
        }
      );
      break;
    }
    case "Belashyrraâ€™s Beholder Crown": {
      let effect = baseItemEffect(document, `${document.name} - Constant Effects`);
      effect.changes.push(generateUpgradeChange(120, 10, "data.attributes.senses.darkvision"));
      document.effects.push(effect);
      break;
    }
    case "Boots of Speed": {
      let effect = baseItemEffect(document, `${document.name} - Invulnerability`);
      effect.changes.push(generateMultiplyChange(2, 20, "data.attributes.movement.walk"));
      effect.duration = {
        startTime: null,
        seconds: 600,
        rounds: null,
        turns: null,
        startRound: null,
        startTurn: null,
      };
      effect.transfer = true;
      effect.disabled = true;
      effect.flags.dae.transfer = true;
      effect.flags.dae.stackable = true;
      effect.flags.dae.specialDuration = "None";
      document.data.target = {
        value: null,
        width: null,
        units: "",
        type: "self",
      };
      document.data.range = {
        value: null,
        long: null,
        units: "self",
      };
      document.data.activation.type = "bonus";
      document.effects.push(effect);
      break;
    }
    case "Cloak of Displacement": {
      let effect = baseItemEffect(document, `${document.name} - Constant Effects`);
      effect.flags.dae.specialDuration = ["isDamaged"];
      break;
    }
    case "Spellguard Shield": {
      document.effects[0].changes.push(
        generateCustomChange(1, 20, "flags.midi-qol.grants.disadvantage.attack.msak"),
        generateCustomChange(1, 20, "flags.midi-qol.grants.disadvantage.attack.rsak")
      );
      break;
    }
    // no default
  }

  return document;
}

;// CONCATENATED MODULE: ./src/parser/effects/specialSpells.js


/**
 * This function is mainly for effects that can't be dynamically generated
 * @param {*} document
 */
function spellEffectAdjustment(document) {
  switch (document.name) {
    case "Absorb Elements": {
      const effect = baseItemEffect(document, `${document.name} - Extra Damage`);
      effect.changes.push({
        key: "data.bonuses.mwak.damage",
        value: `(@item.level)d6`,
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        priority: 0,
      });
      effect.transfer = false;
      effect.disabled = false;
      effect.flags.dae.transfer = false;
      effect.flags.dae.stackable = false;
      effect.flags.dae.specialDuration = "1Hit";
      effect.duration = {
        startTime: null,
        seconds: null,
        rounds: 1,
        turns: null,
        startRound: null,
        startTurn: null,
      };
      document.data.damage = {
        parts: [["", ""]],
        versatile: "",
        value: "",
      };
      document.data.target = {
        value: null,
        width: null,
        units: "",
        type: "self",
      };
      document.data.range = {
        value: null,
        long: null,
        units: "self",
      };
      document.effects.push(effect);
      break;
    }
    // no default
  }
  return document;
}

;// CONCATENATED MODULE: ./src/parser/effects/specialFeats.js


/**
 * This function is mainly for effects that can't be dynamically generated
 * @param {*} document
 */
function featureEffectAdjustment(document) {
  switch (document.name) {
    // if using active auras add the aura effect
    case "Aura of Courage":
    case "Aura of Protection": {
      document.effects.forEach((effect) => {
        if (effect.label.includes("Constant Effects")) {
          effect.flags.ActiveAuras = {
            aura: "Allies",
            radius: 10,
            isAura: true,
            inactive: false,
            hidden: false,
          };
        }
      });
      break;
    }
    case "Unarmored Movement": {
      document.effects.forEach((effect) => {
        if (effect.label.includes("Constant Effects")) {
          effect.changes = [{
            key: "data.attributes.movement.walk",
            value: "max(10+(ceil(((@classes.monk.levels)-5)/4))*5,10)",
            mode: CONST.ACTIVE_EFFECT_MODES.ADD,
            priority: 20,
          }];
        }
      });
      break;
    }
    case "Rage": {
      let effect = baseItemEffect(document, `${document.name}`);

      const extraDamage = document.flags?.ddbimporter?.dndbeyond?.levelScale?.fixedValue
        ? document.flags.ddbimporter.dndbeyond.levelScale.fixedValue
        : 2;
      effect.changes.push(
        {
          key: "data.bonuses.mwak.damage",
          value: `${extraDamage}`,
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          priority: 0,
        },
        {
          key: "data.traits.dr.value",
          value: "piercing",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          priority: 0,
        },
        {
          key: "data.traits.dr.value",
          value: "slashing",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          priority: 20,
        },
        {
          key: "data.traits.dr.value",
          value: "bludgeoning",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          priority: 20,
        },
        {
          key: "flags.midi-qol.advantage.ability.save.str",
          value: "1",
          mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
          priority: 20,
        },
        {
          key: "flags.midi-qol.advantage.ability.check.str",
          value: "1",
          mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
          priority: 20,
        }
      );
      effect.duration = {
        startTime: null,
        seconds: 60,
        rounds: null,
        turns: null,
        startRound: null,
        startTurn: null,
      };
      effect.transfer = false;
      effect.disabled = false;
      effect.flags.dae.transfer = false;
      effect.flags.dae.stackable = false;
      document.effects.push(effect);
      break;
    }
    // no default
  }

  return document;
}

;// CONCATENATED MODULE: ./src/parser/effects/specialInfusions.js
// import {
//   baseItemEffect,
//   generateUpgradeChange,
//   generateAddChange,
//   generateMultiplyChange,
//   generateCustomChange,
// } from "./effects.js";

/**
 * This function is mainly for effects that can't be dynamically generated
 * @param {*} document
 */
function infusionEffectAdjustment(document) {

  return document;
}

// EXTERNAL MODULE: ./src/parser/effects/acEffects.js
var acEffects = __webpack_require__(419);
;// CONCATENATED MODULE: ./src/parser/effects/effects.js











/**
 * Add supported effects here to exclude them from calculations.
 */
const EFFECT_EXCLUDED_COMMON_MODIFIERS = [
  { type: "bonus", subType: "saving-throws" },
  { type: "bonus", subType: "ability-checks" },
  { type: "bonus", subType: "skill-checks" },
  { type: "bonus", subType: "proficiency-bonus" },

  { type: "set", subType: "strength-score" },
  { type: "set", subType: "dexterity-score" },
  { type: "set", subType: "constitution-score" },
  { type: "set", subType: "wisdom-score" },
  { type: "set", subType: "intelligence-score" },
  { type: "set", subType: "charisma-score" },

  // skills
  { type: "bonus", subType: "acrobatics" },
  { type: "bonus", subType: "animal-handling" },
  { type: "bonus", subType: "arcana" },
  { type: "bonus", subType: "athletics" },
  { type: "bonus", subType: "deception" },
  { type: "bonus", subType: "history" },
  { type: "bonus", subType: "insight" },
  { type: "bonus", subType: "intimidation" },
  { type: "bonus", subType: "investigation" },
  { type: "bonus", subType: "medicine" },
  { type: "bonus", subType: "nature" },
  { type: "bonus", subType: "perception" },
  { type: "bonus", subType: "performance" },
  { type: "bonus", subType: "persuasion" },
  { type: "bonus", subType: "religion" },
  { type: "bonus", subType: "sleight-of-hand" },
  { type: "bonus", subType: "stealth" },
  { type: "bonus", subType: "survival" },
  // advantage on skills - not added here as not used elsewhere in importer.
  // { type: "advantage", subType: "acrobatics" },

  // initiative
  { type: "advantage", subType: "initiative" },

  // { type: "bonus", subType: "strength-ability-checks" },
  // { type: "bonus", subType: "dexterity-ability-checks" },
  // { type: "bonus", subType: "constitution-ability-checks" },
  // { type: "bonus", subType: "wisdom-ability-checks" },
  // { type: "bonus", subType: "intelligence-ability-checks" },
  // { type: "bonus", subType: "charisma-ability-checks" },

  // { type: "bonus", subType: "strength-saving-throws" },
  // { type: "bonus", subType: "dexterity-saving-throws" },
  // { type: "bonus", subType: "constitution-saving-throws" },
  // { type: "bonus", subType: "wisdom-saving-throws" },
  // { type: "bonus", subType: "intelligence-saving-throws" },
  // { type: "bonus", subType: "charisma-saving-throws" },

  // attack modifiers
  { type: "bonus", subType: "weapon-attacks" },
  { type: "bonus", subType: "melee-attacks" },
  { type: "bonus", subType: "ranged-attacks" },
  { type: "bonus", subType: "melee-weapon-attacks" },
  { type: "bonus", subType: "ranged-weapon-attacks" },
  { type: "damage", subType: null },
];

const EFFECT_EXCLUDED_SPELL_MODIFIERS = [
  { type: "bonus", subType: "spell-save-dc" },
  { type: "bonus", subType: "spell-attacks" },
  { type: "bonus", subType: "warlock-spell-save-dc" },
  { type: "bonus", subType: "warlock-spell-attacks" },
  { type: "bonus", subType: "spell-group-healing" } // data.bonuses.heal.damage
];

const EFFECT_EXCLUDED_HP_MODIFIERS = [
  { type: "bonus", subType: "hit-points-per-level" },
  { type: "bonus", subType: "hit-points" },
];

const EFFECT_EXCLUDED_SENSE_MODIFIERS = [
  // senses
  { type: "set-base", subType: "darkvision" },
  { type: "sense", subType: "darkvision" },
  { type: "set-base", subType: "blindsight" },
  { type: "sense", subType: "blindsight" },
  { type: "set-base", subType: "tremorsense" },
  { type: "sense", subType: "tremorsense" },
  { type: "set-base", subType: "truesight" },
  { type: "sense", subType: "truesight" },
];

const EFFECT_EXCLUDED_SPEED_SET_MODIFIERS = [
  // speeds
  { type: "set", subType: "innate-speed-walking" },
  { type: "set", subType: "innate-speed-climbing" },
  { type: "set", subType: "innate-speed-swimming" },
  { type: "set", subType: "innate-speed-flying" },
];

const EFFECT_EXCLUDED_SPEED_BONUS_MODIFIERS = [
  { type: "bonus", subType: "speed" },
  { type: "bonus", subType: "speed-walking" },
  { type: "bonus", subType: "speed-climbing" },
  { type: "bonus", subType: "speed-swimming" },
  { type: "bonus", subType: "speed-flying" },
];

const EFFECT_EXCLUDED_GENERAL_SPEED_MODIFIERS = EFFECT_EXCLUDED_SPEED_SET_MODIFIERS.concat(EFFECT_EXCLUDED_SPEED_BONUS_MODIFIERS);

const EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS = [
  { type: "bonus", subType: "unarmored-movement" },
];

const EFFECT_EXCLUDED_ALL_SPEED_MODIFIERS = EFFECT_EXCLUDED_GENERAL_SPEED_MODIFIERS.concat(EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS);

const EFFECT_EXCLUDED_ABILITY_BONUSES = [
  { type: "bonus", subType: "strength-score" },
  { type: "bonus", subType: "dexterity-score" },
  { type: "bonus", subType: "constitution-score" },
  { type: "bonus", subType: "wisdom-score" },
  { type: "bonus", subType: "intelligence-score" },
  { type: "bonus", subType: "charisma-score" },
];

const EFFECT_EXCLUDED_PROFICIENCY_BONUSES = [
  // profs
  { type: "proficiency", subType: null },
];

const EFFECT_EXCLUDED_LANGUAGES_MODIFIERS = [
  // languages - e.g. dwarvish -- lookup from DICTIONARY
  { type: "language", subType: null },
];

const EFFECT_EXCLUDED_DAMAGE_CONDITION_MODIFIERS = [
  // resistances - subType - e.g. poison - lookup from DICTIONARY
  { type: "resistance", subType: null },
  { type: "immunity", subType: null },
  { type: "vulnerability", subType: null },
];

const AC_BONUS_MODIFIERS = [
  { type: "bonus", subType: "unarmored-armor-class" },
  { type: "bonus", subType: "armor-class" },
  { type: "bonus", subType: "armored-armor-class" },
  { type: "bonus", subType: "dual-wield-armor-class" },
];

const AC_EFFECTS = [
  { type: "set", subType: "unarmored-armor-class" },
  { type: "ignore", subType: "unarmored-dex-ac-bonus" },
  { type: "set", subType: "ac-max-dex-modifier" },
];

function getEffectExcludedModifiers(type, features, ac) {
  let modifiers = [];

  if (type !== "item") {
    // these are the effect tweaks, and mostly excessive
    const speedEffect = game.settings.get("ddb-importer", `character-update-policy-effect-${type}-speed`);
    const senseEffect = game.settings.get("ddb-importer", `character-update-policy-effect-${type}-senses`);
    const hpEffect = game.settings.get("ddb-importer", `character-update-policy-effect-${type}-hp`);
    const spellBonusEffect = game.settings.get("ddb-importer", `character-update-policy-effect-${type}-spell-bonus`);
    const damageEffect = game.settings.get("ddb-importer", `character-update-policy-effect-${type}-damages`);

    // features represent core non ac features
    if (features) {
      modifiers = modifiers.concat(EFFECT_EXCLUDED_COMMON_MODIFIERS);
      if (["feat", "background", "race", "class"].includes(type)) {
        if (speedEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_GENERAL_SPEED_MODIFIERS);
        if (senseEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_SENSE_MODIFIERS);
        if (hpEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_HP_MODIFIERS);
        if (spellBonusEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_SPELL_MODIFIERS);
        if (damageEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_DAMAGE_CONDITION_MODIFIERS);
      }
      if (["class"].includes(type)) {
        modifiers = modifiers.concat(EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS);
      } else if (["feat", "background", "race"].includes(type)) {
        if (speedEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS);
      }
    }
    // here ac represents the more exotic ac effects that set limits and change base
    const AUTO_AC = utils/* default.versionCompare */.Z.versionCompare(game.data.system.data.version, "1.4.0") >= 0;
    // if using D&D 1.4.* then we need to add in some ac bonuses off the bat regardless
    if (AUTO_AC || ac) modifiers = modifiers.concat(AC_BONUS_MODIFIERS);
    if (ac) {
      modifiers = modifiers.concat(AC_EFFECTS);
    }
  }

  // items are basically their own thing, all or nuffin
  if (type === "item") {
    modifiers = modifiers.concat(
      EFFECT_EXCLUDED_COMMON_MODIFIERS,
      EFFECT_EXCLUDED_ABILITY_BONUSES,
      EFFECT_EXCLUDED_DAMAGE_CONDITION_MODIFIERS,
      EFFECT_EXCLUDED_LANGUAGES_MODIFIERS,
      EFFECT_EXCLUDED_PROFICIENCY_BONUSES,
      EFFECT_EXCLUDED_ALL_SPEED_MODIFIERS,
      EFFECT_EXCLUDED_SENSE_MODIFIERS,
      EFFECT_EXCLUDED_HP_MODIFIERS,
      EFFECT_EXCLUDED_SPELL_MODIFIERS,
      AC_EFFECTS,
      AC_BONUS_MODIFIERS,
    );
  }
  return modifiers;
}

/**
 *
 * Generate a base effect for an Item
 *
 * @param {*} formula
 * @param {*} mode
 * @param {*} itemData
 * @param {*} label
 * @param {*} origin
 */

function baseItemEffect(foundryItem, label) {
  return {
    label,
    icon: foundryItem.img,
    changes: [],
    duration: {},
    // duration: {
    //   seconds: null,
    //   startTime: null,
    //   rounds: null,
    //   turns: null,
    //   startRound: null,
    //   startTurn: null,
    // },
    tint: "",
    transfer: true,
    disabled: false,
    // origin: origin,
    flags: {
      dae: {
        transfer: true,
        stackable: false,
        // armorEffect: true
      },
      ddbimporter: {
        disabled: false,
      },
    },
  };
}

// *
// CONST.ACTIVE_EFFECT_MODES.
// ADD: 2
// CUSTOM: 0
// DOWNGRADE: 3
// MULTIPLY: 1
// OVERRIDE: 5
// UPGRADE: 4
//

function generateBaseSkillEffect(id, label) {
  const mockItem = {
    img: "icons/svg/up.svg",
  };
  let skillEffect = baseItemEffect(mockItem, label);
  skillEffect.flags.dae = {};
  skillEffect.flags.ddbimporter.characterEffect = true;
  skillEffect.origin = `Actor.${id}`;
  delete skillEffect.transfer;
  return skillEffect;
}

function generateChange(bonus, priority, key, mode) {
  return {
    key: key,
    value: bonus,
    mode: mode,
    priority: priority,
  };
}

function generateAddChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.ADD);
}

function generateCustomChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.CUSTOM);
}

function generateCustomBonusChange(bonus, priority, key) {
  return generateChange(`+${bonus}`, priority, key, CONST.ACTIVE_EFFECT_MODES.CUSTOM);
}

function generateUpgradeChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.UPGRADE);
}

function generateOverrideChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.OVERRIDE);
}

function generateMultiplyChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.MULTIPLY);
}

function generateDowngradeChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.DOWNGRADE);
}


// special effect functions
function attunedItemsBonus(actor, change) {
  // actor is the actor being processed and change a key/value pair
  if (change.key === "data.bonuses.abilities.save" && change.value === "ATTUNED_ITEM_BONUS") {
    // If your active effect spec was
    const bonus = actor.data.items.filter((item) => item.data.data.attunement == 2).length;
    // actor.data.data.bonuses.abilities.save += bonus;
    logger/* default.debug */.Z.debug(`Setting attuned items saving throw bonus for ${actor.name} to ${bonus}`);
    // setProperty(actor, "data.flags.ddbimporter.attundedItems", bonus);
    // this updates the effect value
    change.value = bonus;
    // console.warn(actor);
    // console.warn(change);
    // console.warn(bonus);
  }
}

Hooks.on("applyActiveEffect", attunedItemsBonus);


//
function extractModifierValue(modifier) {
  let value = "";
  let modBonus = "";

  let statBonus = (modifier.statId)
    ? modifier.statId
    : modifier.abilityModifierStatId
      ? modifier.abilityModifierStatId
      : null;

  if (statBonus) {
    const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === modifier.statId).value;
    modBonus = modBonus === "" ? `@abilities.${ability}.mod` : `+ @abilities.${ability}.mod`;
  }

  const fixedBonus = modifier.dice?.fixedValue ? ` + ${modifier.dice.fixedValue}` : "";

  if (modifier.dice) {
    if (modifier.dice.diceString) {
      value = modifier.dice.diceString + modBonus + fixedBonus;
    } else if (fixedBonus) {
      value = fixedBonus + modBonus;
    }
  } else if (modifier.fixedValue) {
    value = modifier.fixedValue;
  } else if (modifier.value) {
    value = modifier.value;
  } else if (modBonus) {
    value = modBonus;
  }

  if (value === "" && modifier.subType == "saving-throws" && modifier.bonusTypes.includes(2)) {
    // we set the value to zero and when the saving throw is calculated it will
    // be updated by the attunedItemsBonus function above
    value = "ATTUNED_ITEM_BONUS";
  }

  return value;
}


function getValueFromModifiers(modifiers, name, modifierSubType, modifierType = "bonus") {
  let bonuses;
  const bonusEffects = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, modifierType, modifierSubType);

  if (bonusEffects.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${modifierSubType} ${modifierType} for ${name}`);
    bonuses = "";
    bonusEffects.forEach((modifier) => {
      let bonusParse = extractModifierValue(modifier);
      if (bonuses !== "") bonuses += " + ";
      bonuses += bonusParse;
    });
    if (bonuses === "") {
      bonuses = undefined;
      logger/* default.debug */.Z.debug(`Modifier value 0 for ${modifierSubType} ${modifierType} for ${name}. Reset to undefined`);
    } else {
      logger/* default.debug */.Z.debug(`Modifier value string for ${modifierSubType} ${modifierType} for ${name}`, bonuses);
    }
  }

  return bonuses;
}

/**
 * Generates a global custom bonus for an item with a +
 */
function addCustomBonusEffect(modifiers, name, type, key) {
  let changes = [];
  const bonuses = getValueFromModifiers(modifiers, name, type, "bonus");

  if (bonuses) {
    changes.push(generateCustomChange(`${bonuses}`, 18, key));
    logger/* default.debug */.Z.debug(`Changes for ${type} bonus for ${name}`, changes);
  }

  return changes;
}

//
// Generate saving throw bonuses
//
function addGlobalSavingBonusEffect(modifiers, name) {
  const type = "saving-throws";
  const key = "data.bonuses.abilities.save";
  let changes = [];
  const regularBonuses = modifiers.filter((mod) => !mod.bonusTypes?.includes(2));
  const customBonuses = modifiers.filter((mod) => mod.bonusTypes?.includes(2));

  if (customBonuses.length > 0) {
    let customEffects = addCustomBonusEffect(customBonuses, name, type, key);
    changes = changes.concat(customEffects);
  }

  const regularModifiers = utils/* default.filterModifiers */.Z.filterModifiers(regularBonuses, "bonus", type);

  if (regularModifiers.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${type} bonus for ${name}`);
    let bonuses = "";
    regularModifiers.forEach((modifier) => {
      let bonusParse = extractModifierValue(modifier);
      if (bonuses !== "") bonuses += " + ";
      bonuses += bonusParse;
    });
    if (bonuses === "") bonuses = 0;
    changes.push(generateAddChange(`+ ${bonuses}`, 20, key));
    logger/* default.debug */.Z.debug(`Changes for ${type} bonus for ${name}`, changes);
  }

  return changes;
}

/**
 * Generates a global custom bonus for an item
 */
function addCustomEffect(modifiers, name, type, key, extra = "") {
  let changes = [];
  const bonus = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "bonus", type).reduce((a, b) => a + b.value, 0);
  if (bonus !== 0) {
    logger/* default.debug */.Z.debug(`Generating ${type} bonus for ${name}`);
    changes.push(generateCustomChange(`${bonus}${(extra) ? extra : ""}`, 18, key));
  }
  return changes;
}

/**
 * Generates a global add for an item
 */
function addAddEffect(modifiers, name, type, key) {
  let changes = [];
  // const bonus = utils.filterModifiers(modifiers, "bonus", type).reduce((a, b) => a + b.value, 0);
  const bonus = getValueFromModifiers(modifiers, name, type, "bonus");
  if (bonus) {
    logger/* default.debug */.Z.debug(`Generating ${type} bonus for ${name}`, bonus);
    changes.push(generateAddChange(bonus, 18, key));
  }
  return changes;
}

/**
 * Adds languages, can't handle custom languages
 */
function addLanguages(modifiers, name) {
  let changes = [];

  const languages = (0,character_proficiencies/* getLanguagesFromModifiers */.PR)(null, modifiers);

  languages.value.forEach((prof) => {
    logger/* default.debug */.Z.debug(`Generating language ${prof} for ${name}`);
    changes.push(generateCustomChange(prof, 0, "data.traits.languages.value"));
  });
  if (languages?.custom != "") {
    logger/* default.debug */.Z.debug(`Generating language ${languages.custom} for ${name}`);
    changes.push(generateCustomChange(languages.custom, 0, "data.traits.languages.custom"));
  }

  return changes;
}


/**
 * Generate global damage bonuses
*/
function addGlobalDamageBonus(modifiers, name) {
  const meleeRestrictions = ["Melee Weapon Attacks"];
  let changes = [];
  const meleeBonus = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "damage", null, meleeRestrictions)
    .filter((mod) => mod.dice || mod.value)
    .map((mod) => {
      if (mod.dice) {
        return utils/* default.parseDiceString */.Z.parseDiceString(mod.dice.diceString, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      } else {
        return utils/* default.parseDiceString */.Z.parseDiceString(mod.value, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      }
    });
  if (meleeBonus && meleeBonus.length > 0) {
    logger/* default.debug */.Z.debug(`Generating melee damage for ${name}`);
    changes.push(generateCustomChange(`${meleeBonus.join(" + ")}`, 18, "data.bonuses.mwak.damage"));
  }
  const rangedRestrictions = ["Ranged Weapon Attacks"];
  const rangedBonus = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "damage", null, rangedRestrictions)
    .filter((mod) => mod.dice || mod.value)
    .map((mod) => {
      if (mod.dice) {
        return utils/* default.parseDiceString */.Z.parseDiceString(mod.dice.diceString, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      } else {
        return utils/* default.parseDiceString */.Z.parseDiceString(mod.value, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      }
    });
  if (rangedBonus && rangedBonus.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ranged damage for ${name}`);
    changes.push(generateCustomChange(`${rangedBonus.join(" + ")}`, 18, "data.bonuses.rwak.damage"));
  }
  const bonus = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "damage", null)
    .filter((mod) => mod.dice || mod.value)
    .map((mod) => {
      if (mod.dice) {
        return utils/* default.parseDiceString */.Z.parseDiceString(mod.dice.diceString, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      } else {
        return utils/* default.parseDiceString */.Z.parseDiceString(mod.value, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      }
    });
  if (bonus && bonus.length > 0) {
    logger/* default.debug */.Z.debug(`Generating all damage for ${name}`);
    changes.push(generateCustomChange(`${bonus.join(" + ")}`, 18, "data.bonuses.mwak.damage"));
    changes.push(generateCustomChange(`${bonus.join(" + ")}`, 18, "data.bonuses.rwak.damage"));
  }
  return changes;
}

// *
// Get list of generic conditions/damages
//
function getGenericConditionAffect(modifiers, condition, typeId) {
  const damageTypes = dictionary/* default.character.damageTypes.filter */.Z.character.damageTypes.filter((type) => type.kind === condition && type.type === typeId)
    .map((type) => type.value);

  let restrictions = [
    "",
    null,
    "While within 20 feet",
    "Dwarf Only",
    "While Not Incapacitated",
    // "As an Action", this is a timed/limited effect, dealt with elsewhere
    "While Staff is Held",
    "Helm has at least one ruby remaining",
    "while holding",
    "While Held",
  ];
  let result = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, condition, null, restrictions)
    .filter((modifier) => modifier.isGranted && damageTypes.includes(modifier.subType))
    .map((modifier) => {
      const entry = dictionary/* default.character.damageTypes.find */.Z.character.damageTypes.find(
        (type) => type.type === typeId && type.kind === modifier.type && type.value === modifier.subType
      );
      return entry ? entry.foundryValue || entry.value : undefined;
    });

  return result;
}

/**
 * Get  Damage Conditions, and Condition Immunities
 * @param {*} ddbItem
 */
function addDamageConditions(modifiers) {
  let charges = [];

  const damageImmunities = getGenericConditionAffect(modifiers, "immunity", 2);
  const damageResistances = getGenericConditionAffect(modifiers, "resistance", 2);
  const damageVulnerability = getGenericConditionAffect(modifiers, "vulnerability", 2);

  damageImmunities.forEach((type) => {
    charges.push(generateCustomChange(type, 1, "data.traits.di.value"));
  });
  damageResistances.forEach((type) => {
    charges.push(generateCustomChange(type, 1, "data.traits.dr.value"));
  });
  damageVulnerability.forEach((type) => {
    charges.push(generateCustomChange(type, 1, "data.traits.dv.value"));
  });

  const conditionImmunities = getGenericConditionAffect(modifiers, "immunity", 1);

  conditionImmunities.forEach((type) => {
    charges.push(generateCustomChange(type, 1, "data.traits.ci.value"));
  });

  // data.traits.di.all
  const allDamageImmunity = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "immunity", "all");
  if (allDamageImmunity?.length > 0) {
    charges.push(generateCustomChange(1, 1, "data.traits.di.all"));
  }

  return charges;
}

// *
// Generate stat bonuses
//
function addStatBonusEffect(modifiers, name, subType) {
  const bonuses = modifiers.filter((modifier) => modifier.type === "bonus" && modifier.subType === subType);

  let effects = [];
  if (bonuses.length > 0) {
    bonuses.forEach((bonus) => {
      const maxMatch = /Maximum of (\d*)/;
      const match = bonus.restriction ? bonus.restriction.match(maxMatch) : false;
      logger/* default.debug */.Z.debug(`Generating ${subType} stat bonus for ${name}`);
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.long === subType.split("-")[0]);
      const abilityScoreMaxBonus = modifiers
        .filter((modifier) => modifier.type === "bonus" && modifier.subType === "ability-score-maximum")
        .filter((mod) => mod.statId === ability.id)
        .reduce((prev, cur) => prev + cur.value, 0);
      const max = match ? match[1] : 20 + abilityScoreMaxBonus;

      const bonusString = `@abilities.${ability.value}.value + ${bonus.value} > ${max} ? ${max} : @abilities.${ability.value}.value + ${bonus.value}`;
      effects.push(generateOverrideChange(bonusString, 5, `data.abilities.${ability.value}.value`));
    });
  }
  return effects;
}

function addStatBonuses(modifiers, name) {
  let changes = [];
  const stats = [
    "strength-score",
    "dexterity-score",
    "constitution-score",
    "wisdom-score",
    "intelligence-score",
    "charisma-score",
  ];
  stats.forEach((stat) => {
    const result = addStatBonusEffect(modifiers, name, stat);
    changes = changes.concat(result);
  });

  return changes;
}

// *
// Generate stat sets
//
function addStatSetEffect(modifiers, name, subType) {
  const bonuses = modifiers.filter((modifier) => modifier.type === "set" && modifier.subType === subType);

  let effects = [];
  // dwarfen "Maximum of 20"
  if (bonuses.length > 0) {
    bonuses.forEach((bonus) => {
      logger/* default.debug */.Z.debug(`Generating ${subType} stat set for ${name}`);
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.long === subType.split("-")[0]).value;
      effects.push(generateUpgradeChange(bonus.value, 3, `data.abilities.${ability}.value`));
    });
  }
  return effects;
}

// requires midi
// does not add advantages with restrictions - which is most of them
function addAbilityAdvantageEffect(modifiers, name, subType, type) {
  const bonuses = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "advantage", subType);

  let effects = [];
  if (bonuses.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${subType} saving throw advantage for ${name}`);
    const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.long === subType.split("-")[0]).value;
    effects.push(generateCustomChange(1, 4, `flags.midi-qol.advantage.ability.${type}.${ability}`));
  }
  return effects;
}

function addStatChanges(modifiers, name) {
  let changes = [];
  const stats = ["strength", "dexterity", "constitution", "wisdom", "intelligence", "charisma"];
  stats.forEach((stat) => {
    const statEffect = addStatSetEffect(modifiers, name, `${stat}-score`);
    const savingThrowAdvantage = addAbilityAdvantageEffect(modifiers, name, `${stat}-saving-throw`, "save");
    const abilityCheckAdvantage = addAbilityAdvantageEffect(modifiers, name, `${stat}-ability-checks`, "check");
    changes = changes.concat(statEffect, savingThrowAdvantage, abilityCheckAdvantage);
  });

  return changes;
}

// *
// Senses
//
function addSenseBonus(modifiers, name) {
  let changes = [];

  const senses = ["darkvision", "blindsight", "tremorsense", "truesight"];

  senses.forEach((sense) => {
    const base = modifiers
      .filter((modifier) => modifier.type === "set-base" && modifier.subType === sense)
      .map((mod) => mod.value);
    if (base.length > 0) {
      logger/* default.debug */.Z.debug(`Generating ${sense} base for ${name}`);
      changes.push(generateUpgradeChange(Math.max(base), 10, `data.attributes.senses.${sense}`));
    }
    const bonus = modifiers
      .filter((modifier) => modifier.type === "sense" && modifier.subType === sense)
      .reduce((a, b) => a + b.value, 0);
    if (bonus > 0) {
      logger/* default.debug */.Z.debug(`Generating ${sense} bonus for ${name}`);
      changes.push(generateAddChange(Math.max(bonus), 15, `data.attributes.senses.${sense}`));
    }
  });
  return changes;
}

/**
 * Proficiency bonus
 */

function addProficiencyBonus(modifiers, name) {
  let changes = [];
  const bonus = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "bonus", "proficiency-bonus").reduce((a, b) => a + b.value, 0);
  if (bonus) {
    logger/* default.debug */.Z.debug(`Generating proficiency bonus for ${name}`);
    changes.push(generateAddChange(bonus, 0, "data.attributes.prof"));
  }
  return changes;
}

// *
// Generate set speeds
//
function addSetSpeedEffect(modifiers, name, subType) {
  const bonuses = modifiers.filter((modifier) => modifier.type === "set" && modifier.subType === subType);

  let effects = [];
  // "Equal to Walking Speed"
  if (bonuses.length > 0) {
    bonuses.forEach((bonus) => {
      logger/* default.debug */.Z.debug(`Generating ${subType} speed set for ${name}`);
      const innate = subType.split("-").slice(-1)[0];
      const speedType = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.innate === innate).type;
      // current assumption if no speed provided, set to walking speed
      const speed = bonus.value ? bonus.value : "@attributes.movement.walk";
      effects.push(generateUpgradeChange(speed, 5, `data.attributes.movement.${speedType}`));
    });
  }
  return effects;
}

/**
 * Innate Speeds
 */
function addSetSpeeds(modifiers, name) {
  let changes = [];
  const speedSets = [
    "innate-speed-walking",
    "innate-speed-climbing",
    "innate-speed-swimming",
    "innate-speed-flying",
    "innate-speed-burrowing",
  ];
  speedSets.forEach((speedSet) => {
    const result = addSetSpeedEffect(modifiers, name, speedSet);
    changes = changes.concat(result);
  });

  return changes;
}

// *
// Generate speed bonus speeds
//
function addBonusSpeedEffect(modifiers, name, subType, speedType = null) {
  const bonuses = modifiers.filter((modifier) => modifier.type === "bonus" && modifier.subType === subType);

  let effects = [];
  // "Equal to Walking Speed"
  // max(10+(ceil(((@classes.monk.levels)-5)/4))*5,10)
  if (bonuses.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${subType} speed bonus for ${name}`);
    if (!speedType) {
      const innate = subType.split("-").slice(-1)[0];
      speedType = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.innate === innate).type;
    }
    const bonusValue = bonuses.reduce((speed, mod) => speed + mod.value, 0);
    if (speedType === "all") {
      effects.push(generateCustomChange(`+ ${bonusValue}`, 9, `data.attributes.movement.${speedType}`));
    } else {
      effects.push(generateAddChange(bonusValue, 9, `data.attributes.movement.${speedType}`));
    }
  }
  return effects;
}

/**
 * Bonus Speeds
 */
function addBonusSpeeds(modifiers, name) {
  let changes = [];
  const speedBonuses = ["speed-walking", "speed-climbing", "speed-swimming", "speed-flying", "speed-burrowing"];
  speedBonuses.forEach((speed) => {
    const result = addBonusSpeedEffect(modifiers, name, speed);
    changes = changes.concat(result);
  });

  changes = changes.concat(addBonusSpeedEffect(modifiers, name, "unarmored-movement", "walk"));
  changes = changes.concat(addBonusSpeedEffect(modifiers, name, "speed", "walk")); // probably all, but doesn't handle cases of where no base speed set, so say fly gets set to 10.

  return changes;
}

function addSkillProficiencies(modifiers) {
  let changes = [];
  dictionary/* default.character.skills.forEach */.Z.character.skills.forEach((skill) => {
    const prof = (0,skills/* getSkillProficiency */.M)(null, skill, modifiers);
    if (prof != 0) {
      changes.push(generateUpgradeChange(prof, 9, `data.skills.${skill.name}.value`));
    }
  });
  return changes;
}

function addProficiencies(modifiers, name) {
  let changes = [];

  const proficiencies = modifiers
    .filter((mod) => mod.type === "proficiency")
    .map((mod) => {
      return { name: mod.friendlySubtypeName };
    });

  changes = changes.concat(addSkillProficiencies(modifiers));
  const toolProf = (0,character_proficiencies/* getToolProficiencies */.bX)(null, proficiencies);
  const weaponProf = (0,character_proficiencies/* getWeaponProficiencies */.JN)(null, proficiencies);
  const armorProf = (0,character_proficiencies/* getArmorProficiencies */.jZ)(null, proficiencies);

  toolProf.value.forEach((prof) => {
    logger/* default.debug */.Z.debug(`Generating tool proficiencies for ${name}`);
    changes.push(generateCustomChange(prof, 8, "data.traits.toolProf.value"));
  });
  weaponProf.value.forEach((prof) => {
    logger/* default.debug */.Z.debug(`Generating weapon proficiencies for ${name}`);
    changes.push(generateCustomChange(prof, 8, "data.traits.weaponProf.value"));
  });
  armorProf.value.forEach((prof) => {
    logger/* default.debug */.Z.debug(`Generating armor proficiencies for ${name}`);
    changes.push(generateCustomChange(prof, 8, "data.traits.armorProf.value"));
  });
  if (toolProf?.custom != "") changes.push(generateCustomChange(toolProf.custom, 8, "data.traits.toolProf.custom"));
  if (weaponProf?.custom != "")
    changes.push(generateCustomChange(weaponProf.custom, 8, "data.traits.weaponProf.custom"));
  if (armorProf?.custom != "") changes.push(generateCustomChange(armorProf.custom, 8, "data.traits.armorProf.custom"));

  return changes;
}

/**
 * Add HP effects
 * @param {*} modifiers
 * @param {*} name
 */
function addHPEffect(modifiers, name, consumable) {
  let changes = [];

  // HP per level
  const hpPerLevel = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "bonus", "hit-points-per-level").reduce((a, b) => a + b.value, 0);
  if (hpPerLevel && hpPerLevel > 0) {
    logger/* default.debug */.Z.debug(`Generating HP Per Level effects for ${name}`);
    changes.push(generateAddChange(`${hpPerLevel} * @details.level`, 14, "data.attributes.hp.max"));
  }

  const hpBonusModifiers = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "bonus", "hit-points");
  if (hpBonusModifiers.length > 0 && !consumable) {
    let hpBonus = "";
    hpBonusModifiers.forEach((modifier) => {
      let hpParse = extractModifierValue(modifier);
      if (hpBonus !== "") hpBonus += " + ";
      hpBonus += hpParse;
    });
    changes.push(generateCustomChange(`${hpBonus}`, 14, "data.attributes.hp.max"));
  }

  return changes;
}

//
// Generate skill bonuses
//
function addSkillBonusEffect(modifiers, name, skill) {
  const bonus = getValueFromModifiers(modifiers, name, skill.subType, "bonus");

  let changes = [];
  if (bonus) {
    logger/* default.debug */.Z.debug(`Generating ${skill.subType} skill bonus for ${name}`, bonus);
    changes.push(generateAddChange(bonus, 12, `data.skills.${skill.name}.mod`));
  }
  return changes;
}

//
// generate skill advantages
// requires midi
//
function addSkillMidiEffect(modifiers, name, skill, midiEffect = "advantage") {
  const allowedRestrictions = [
    "",
    null,
    "Sound Only",
    "Sight Only",
    "that rely on smell",
    "While the hood is up, checks made to Hide ",
  ];
  const advantage = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, midiEffect, skill.subType, allowedRestrictions);

  let effects = [];
  if (advantage.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${skill.subType} skill ${midiEffect} for ${name}`);
    effects.push(generateCustomChange(1, 5, `flags.midi-qol.${midiEffect}.skill.${skill.name}`));
  }
  return effects;
}

function addSkillBonuses(modifiers, name) {
  let changes = [];
  dictionary/* default.character.skills.forEach */.Z.character.skills.forEach((skill) => {
    const skillBonuses = addSkillBonusEffect(modifiers, name, skill);
    const skillAdvantages = addSkillMidiEffect(modifiers, name, skill, "advantage");
    changes = changes.concat(skillBonuses, skillAdvantages);
  });

  return changes;
}

//
// initiative
//
function addInitiativeBonuses(modifiers, name) {
  let changes = [];
  const advantage = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "advantage", "initiative");
  if (advantage.length > 0) {
    logger/* default.debug */.Z.debug(`Generating Intiative advantage for ${name}`);
    changes.push(generateCustomChange(1, 20, "flags.dnd5e.initiativeAdv"));
  }
  return changes;
}

//
// attack rolls against you
// midi only
//
function addAttackRollDisadvantage(modifiers, name) {
  let changes = [];
  const disadvantage = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "disadvantage", "attack-rolls-against-you", false);
  if (disadvantage.length > 0) {
    logger/* default.debug */.Z.debug(`Generating disadvantage for ${name}`);
    changes.push(generateCustomChange(1, 5, "flags.midi-qol.grants.disadvantage.attack.all"));
  }
  return changes;
}

// midi advantages on saving throws against spells and magical effects
function addMagicalAdvantage(modifiers, name) {
  let changes = [];
  const restrictions = [
    "against spells and magical effects",
    "Against Spells and Magical Effects",
    "Against Spells",
    "against spells",
    "Against spells",
    "Against spells and magical effects within 10 ft. (or 30 ft. at level 17+) while holding the Holy Avenger",
  ];
  const advantage = utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "advantage", "saving-throws", restrictions);
  if (advantage.length > 0) {
    logger/* default.debug */.Z.debug(`Generating magical advantage on saving throws for ${name}`);
    changes.push(generateCustomChange("magic-resistant", 5, "data.traits.dr.custom"));
  }
  return changes;
}

function generateEffectDuration(foundryItem) {
  let duration = {
    seconds: null,
    startTime: null,
    rounds: null,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  switch (foundryItem.data.duration.units) {
    case "turn":
      duration.turns = foundryItem.data.duration.value;
      break;
    case "round":
      duration.rounds = foundryItem.data.duration.value;
      break;
    case "hour":
      duration.seconds = foundryItem.data.duration.value * 60 * 60;
      break;
    case "minute":
      duration.rounds = foundryItem.data.duration.value * 10;
      break;
    // no default
  }
  return duration;
}

function consumableEffect(effect, ddbItem, foundryItem) {
  effect.label = `${foundryItem.name} - Consumable Effects`;
  effect.disabled = false;
  effect.transfer = false;
  setProperty(effect, "flags.ddbimporter.disabled", false);
  setProperty(foundryItem, "flags.dae.transfer", false);
  effect.duration = generateEffectDuration(foundryItem);
  if (!foundryItem.data.target?.value) {
    foundryItem.data.target = {
      value: 1,
      width: null,
      units: "",
      type: "creature",
    };
  }
  if (!foundryItem.data.range?.units) {
    foundryItem.data.range = {
      value: null,
      long: null,
      units: "touch",
    };
  }
  if (foundryItem.data.uses) {
    foundryItem.data.uses.autoDestroy = true;
    foundryItem.data.uses.autoUse = true;
  }

  return effect;
}

/**
 * This checks attunement status and similar to determine effect state
 * set disabled flags etc
 * @param {*} foundryItem
 * @param {*} effect
 * @param {*} ddbItem
 * @param {*} isCompendiumItem
 */
function addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem) {
  // check attunement status etc

  if (
    !ddbItem.definition?.canEquip &&
    !ddbItem.definition?.canAttune &&
    !ddbItem.definition?.isConsumable &&
    dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(foundryItem.type)
  ) {
    // if item just gives a thing and not potion/scroll
    effect.disabled = false;
    setProperty(effect, "flags.ddbimporter.disabled", false);
    setProperty(foundryItem, "flags.dae.alwaysActive", true);
  } else if (
    isCompendiumItem ||
    foundryItem.type === "feat" ||
    (ddbItem.isAttuned && ddbItem.equipped) || // if it is attuned and equipped
    (ddbItem.isAttuned && !ddbItem.definition?.canEquip) || // if it is attuned but can't equip
    (!ddbItem.definition?.canAttune && ddbItem.equipped) // can't attune but is equipped
  ) {
    setProperty(foundryItem, "flags.dae.alwaysActive", false);
    setProperty(effect, "flags.ddbimporter.disabled", false);
    effect.disabled = false;
  } else {
    effect.disabled = true;
    setProperty(effect, "flags.ddbimporter.disabled", true);
    setProperty(foundryItem, "flags.dae.alwaysActive", false);
  }

  setProperty(effect, "flags.ddbimporter.itemId", ddbItem.id);
  setProperty(effect, "flags.ddbimporter.itemEntityTypeId", ddbItem.entityTypeId);
  // set dae flag for active equipped
  if (ddbItem.definition?.canEquip || ddbItem.definitio?.canAttune) {
    setProperty(foundryItem, "flags.dae.activeEquipped", true);
  } else {
    setProperty(foundryItem, "flags.dae.activeEquipped", false);
  }

  if (ddbItem.definition?.filterType === "Potion") {
    effect = consumableEffect(effect, ddbItem, foundryItem);
  }

  return [foundryItem, effect];
}

/**
 * Generate supported effects for items
 * @param {*} ddb
 * @param {*} character
 * @param {*} ddbItem
 * @param {*} foundryItem
 */
function generateGenericEffects(ddb, character, ddbItem, foundryItem, isCompendiumItem, labelOverride) {
  if (!foundryItem.effects) foundryItem.effects = [];

  const label = labelOverride
    ? labelOverride
    : `${foundryItem.name} - Constant Effects`;

  let effect = baseItemEffect(foundryItem, label);

  if (!ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0) return [foundryItem, effect];
  logger/* default.debug */.Z.debug(`Generating Effects for ${foundryItem.name}`, ddbItem);

  const globalSaveBonus = addGlobalSavingBonusEffect(ddbItem.definition.grantedModifiers, foundryItem.name);
  const globalAbilityBonus = addCustomBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "ability-checks",
    "data.bonuses.abilities.check",
  );
  const globalSkillBonus = addCustomBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "skill-checks",
    "data.bonuses.abilities.skill",
  );
  const languages = addLanguages(ddbItem.definition.grantedModifiers, foundryItem.name);
  const conditions = addDamageConditions(ddbItem.definition.grantedModifiers, foundryItem.name);
  const statSets = addStatChanges(ddbItem.definition.grantedModifiers, foundryItem.name);
  const statBonuses = addStatBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);
  const senses = addSenseBonus(ddbItem.definition.grantedModifiers, foundryItem.name);
  const proficiencyBonus = addProficiencyBonus(ddbItem.definition.grantedModifiers, foundryItem.name);
  const speedSets = addSetSpeeds(ddbItem.definition.grantedModifiers, foundryItem.name);
  const spellAttackBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "spell-attacks",
    "data.bonuses.spell.attack"
  );
  const spellDCBonus = addAddEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "spell-save-dc",
    "data.bonuses.spell.dc"
  );
  const warlockSpellAttackBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "warlock-spell-attacks",
    "data.bonuses.spell.attack"
  );
  const warlockSpellDCBonus = addAddEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "warlock-spell-save-dc",
    "data.bonuses.spell.dc"
  );
  const healingSpellBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "spell-group-healing",
    "data.bonuses.heal.damage",
    " + @item.level"
  );

  const profs = addProficiencies(ddbItem.definition.grantedModifiers, foundryItem.name);
  const hp = addHPEffect(ddbItem.definition.grantedModifiers, foundryItem.name, ddbItem.definition.isConsumable);
  const skillBonus = addSkillBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);
  const initiative = addInitiativeBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);
  const disadvantageAgainst = addAttackRollDisadvantage(ddbItem.definition.grantedModifiers, foundryItem.name);
  const magicalAdvantage = addMagicalAdvantage(ddbItem.definition.grantedModifiers, foundryItem.name);
  const bonusSpeeds = addBonusSpeeds(ddbItem.definition.grantedModifiers, foundryItem.name);

  const meleeAttackBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "melee-attacks",
    "data.bonuses.mwak.attack"
  );
  const rangedAttackBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "ranged-attacks",
    "data.bonuses.rwak.attack"
  );
  const meleeWeaponAttackBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "melee-weapon-attacks",
    "data.bonuses.mwak.attack"
  );
  const rangedWeaponAttackBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "ranged-weapon-attacks",
    "data.bonuses.rwak.attack"
  );
  const weaponAttackMeleeBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "weapon-attacks",
    "data.bonuses.mwak.attack"
  );
  const weaponAttackRangedBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "weapon-attacks",
    "data.bonuses.rwak.attack"
  );

  const globalDamageBonus = addGlobalDamageBonus(ddbItem.definition.grantedModifiers, foundryItem.name);

  effect.changes = [
    ...globalSaveBonus,
    ...globalAbilityBonus,
    ...globalSkillBonus,
    ...languages,
    ...conditions,
    ...statSets,
    ...statBonuses,
    ...senses,
    ...proficiencyBonus,
    ...speedSets,
    ...spellAttackBonus,
    ...warlockSpellAttackBonus,
    ...spellDCBonus,
    ...warlockSpellDCBonus,
    ...profs,
    ...hp,
    ...skillBonus,
    ...initiative,
    ...disadvantageAgainst,
    ...magicalAdvantage,
    ...bonusSpeeds,
    ...healingSpellBonus,
    ...meleeAttackBonus,
    ...rangedAttackBonus,
    ...meleeWeaponAttackBonus,
    ...rangedWeaponAttackBonus,
    ...weaponAttackMeleeBonus,
    ...weaponAttackRangedBonus,
    ...globalDamageBonus,
  ];

  // if we don't have effects, lets return the item
  if (effect.changes?.length === 0) {
    return [foundryItem, effect];
  }

  // generate flags for effect (e.g. checking attunement and equipped status)
  [foundryItem, effect] = addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem);

  return [foundryItem, effect];
}

function generateEffects(ddb, character, ddbItem, foundryItem, isCompendiumItem, type) {
  let label;

  if (type == "infusion") {
    label = `${foundryItem.name} - Infusion Effects`;
  }
  let effect;
  [foundryItem, effect] = generateGenericEffects(ddb, character, ddbItem, foundryItem, isCompendiumItem, label);
  if (type == "infusion") {
    [foundryItem, effect] = (0,acEffects/* generateACEffectChangesForItem */.qI)(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect);
  }
  if (effect.changes?.length > 0) {
    foundryItem.effects.push(effect);
  }
  switch (type) {
    case "infusion": {
      foundryItem = infusionEffectAdjustment(foundryItem);
      break;
    }
    case "equipment":
    case "item": {
      foundryItem = equipmentEffectAdjustment(foundryItem);
      break;
    }
    case "spell": {
      foundryItem = spellEffectAdjustment(foundryItem);
      break;
    }
    case "feature":
    case "feat": {
      foundryItem = featureEffectAdjustment(foundryItem);
      break;
    }
    // no default
  }

  if (foundryItem.effects?.length > 0)
    logger/* default.debug */.Z.debug(`${type} effect ${foundryItem.name}:`, JSON.parse(JSON.stringify(foundryItem)));
  return foundryItem;

}


/***/ }),

/***/ 959:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x": () => (/* binding */ loadSRDRules),
/* harmony export */   "Z": () => (/* binding */ parseTemplateString)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(555);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(259);



var srdRules;

async function loadSRDRules() {
  if (srdRules) return;
  try {
    // eslint-disable-next-line require-atomic-updates
    srdRules = await game.packs.get("dnd5e.rules").getIndex();
  } catch (err) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.error */ .Z.error("5e SRD Rules compendium failed to load");
    // eslint-disable-next-line require-atomic-updates
    srdRules = [];
  }
}

/**
 * Gets the levelscaling value for a feature
 * @param {*} feature
 */
const getScalingValue = (feature) => {
  if (feature && feature.levelScale && feature.levelScale.fixedValue) {
    return feature.levelScale.fixedValue;
  } else if (feature && feature.levelScale && feature.levelScale.dice) {
    return feature.levelScale.dice.diceString;
  } else {
    return "{{scalevalue-unknown}}";
  }
};

/**
 * Parse a match and replace template values ready for evaluation
 * @param {*} ddb
 * @param {*} character
 * @param {*} match
 * @param {*} feature
 */
let parseMatch = (ddb, character, match, feature) => {
  const splitMatchAt = match.split("@");
  let result = splitMatchAt[0];
  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;

  // scalevalue
  if (result.includes("scalevalue")) {
    const feat = feature.levelScale ? feature : _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.findComponentByComponentId */ .Z.findComponentByComponentId(ddb, feature.componentId);
    const scaleValue = getScalingValue(feat);
    result = result.replace("scalevalue", scaleValue);
  }

  // savedc:int
  // savedc:str,dex
  if (result.includes("savedc")) {
    const regexp = /savedc:([a-z]{3})(?:,)?([a-z]{3})?/g;
    const matches = [...result.matchAll(regexp)];

    matches.forEach((match) => {
      const saves = match.slice(1);
      const saveDCs = saves
        .filter((save) => save)
        .map((save) => {
          const abilityModifier = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.calculateModifier */ .Z.calculateModifier(characterAbilities[save].value);
          // not sure if we should add this, probably not.
          // const bonus = utils.getModifierSum(utils.filterBaseModifiers(ddb, "bonus", "spell-save-dc"), character);
          const dc = 8 + character.data.attributes.prof + abilityModifier;
          return dc;
        });
      const saveRegexp = RegExp(match[0], "g");
      result = result.replace(saveRegexp, Math.max(...saveDCs));
    });
  }

  // modifier:int@min:1
  // (modifier:cha)+1
  if (result.includes("modifier")) {
    const regexp = /modifier:([a-z]{3})/g;
    // creates array from match groups and dedups
    const ability = [...new Set(Array.from(result.matchAll(regexp), (m) => m[1]))];

    ability.forEach((ab) => {
      const abilityModifier = characterAbilities[ab].mod;
      const abRegexp = RegExp(`modifier:${ab}`, "g");
      result = result.replace(abRegexp, abilityModifier);
    });
  }

  // classlevel*5
  // (classlevel/2)@roundup
  if (result.includes("classlevel")) {
    const cls = feature.classId
      ? ddb.character.classes.find((cls) => cls.definition.id == feature.classId)
      : _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.findClassByFeatureId */ .Z.findClassByFeatureId(ddb, feature.componentId);
    if (cls) {
      result = result.replace("classlevel", cls.level);
    } else {
      // still not found a cls? could be an option
      const classOption = [ddb.character.options.race, ddb.character.options.class, ddb.character.options.feat]
        .flat()
        .find((option) => option.definition.id === feature.componentId);
      if (!classOption) {
        if (!feature.componentId) {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug("Feature failed componentID parse", feature);
        }
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.error */ .Z.error(`Unable to parse option class info. ComponentId is ${feature.componentId}`);
      } else {
        const optionCls = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* .default.findClassByFeatureId */ .Z.findClassByFeatureId(ddb, classOption.componentId);
        if (optionCls) {
          result = result.replace("classlevel", optionCls.level);
        } else {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.error */ .Z.error(`Unable to parse option class info. classOption ComponentId is: ${classOption.componentId}.  ComponentId is ${feature.componentId}`);
        }
      }
    }
  }

  if (result.includes("characterlevel")) {
    result = result.replace("characterlevel", character.flags.ddbimporter.dndbeyond.totalLevels);
  }

  if (result.includes("proficiency")) {
    const profBonus = character.data.attributes.prof;
    result = result.replace("proficiency", profBonus);
  }

  // abilityscore:int
  if (result.includes("abilityscore")) {
    const regexp = /abilityscore:([a-z]{3})/g;
    // creates array from match groups and dedups
    const ability = [...new Set(Array.from(result.matchAll(regexp), (m) => m[1]))];

    ability.forEach((ab) => {
      const abilityModifier = characterAbilities[ab].value;
      const abRegexp = RegExp(`abilityscore:${ab}`, "g");
      result = result.replace(abRegexp, abilityModifier);
    });
  }

  // limiteduse
  if (result.includes("limiteduse")) {
    const limitedUse = feature.limitedUse?.maxUses || "";
    result = result.replace("limiteduse", limitedUse);
  }

  return result;
};

/**
 * Apply the expression constraint
 * @param {*} value
 * @param {*} constraint
 */
const applyConstraint = (value, constraint) => {
  // {{(classlevel/2)@rounddown#unsigned}}
  // @ features
  // @roundup
  // @roundown
  // min:1
  // max:3
  const splitConstraint = constraint.split(":");
  const multiConstraint = splitConstraint[0].split("*");
  const match = multiConstraint[0];

  let result = value;

  switch (match) {
    case "max": {
      if (splitConstraint[1] < result) result = splitConstraint[1];
      break;
    }
    case "min": {
      if (splitConstraint[1] > result) result = splitConstraint[1];
      break;
    }
    case "roundup": {
      result = Math.ceil(result);
      break;
    }
    case "rounddown":
    case "roundown": {
      result = Math.floor(result);
      break;
    }
    default: {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.debug */ .Z.debug(`Missed match is ${match}`);
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.warn */ .Z.warn(`ddb-importer does not know about template constraint {{@${constraint}}}. Please log a bug.`); // eslint-disable-line no-console
    }
  }

  if (multiConstraint.length > 1) {
    const evalStatement = `${result}*${multiConstraint[1]}`;
    /* eslint-disable no-eval */
    result = eval(evalStatement);
    /* eslint-enable no-eval */
  }

  return result;
};

const escapeRegExp = (string) => {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
};

const getNumber = (theNumber) => {
  if (theNumber >= 0) {
    return "+" + theNumber;
  } else {
    return theNumber.toString();
  }
};

// eslint-disable-next-line no-unused-vars
function replaceTag(match, p1, p2, p3, offset, string) {
  if (!p2) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.warn */ .Z.warn(`Unable to tag parse ${match}`);
    return match;
  }
  const srdMatch = srdRules.find((rule) => rule.name.toLowerCase() === p2.toLowerCase());
  if (srdMatch) {
    return `@Compendium[dnd5e.rules.${srdMatch._id}]{${p2}}`;
  } else {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.info */ .Z.info(`Unable to find tag parse compendium match for ${match}`);
  }
  return p2;
}

function parseTags(text) {
  if (!srdRules) return text;
  // older chrome/chromium and electron app do not support replaceAll
  if (typeof text.replaceAll !== "function") {
    return text;
  }
  const tagRegEx = /\[(.*)](.*)\[\/(.*)]/g;
  const matches = text.match(tagRegEx);
  if (matches) {
    return text.replaceAll(tagRegEx, replaceTag);
  }
  return text;
}

/**
 * This will parse a snippet/description with template boilerplate in from DDB.
 * e.g. Each creature in the area must make a DC {{savedc:con}} saving throw.
 * @param {*} ddb
 * @param {*} text
 */
function parseTemplateString(ddb, character, text, feature) {
  if (!text) return text;
  let result = {
    id: feature.id,
    entityTypeId: feature.entityTypeId,
    componentId: (feature.componentId) ? feature.componentId : null,
    componentTypeId: (feature.componentTypeId) ? feature.componentTypeId : null,
    damageTypeId: (feature.damageTypeId) ? feature.damageTypeId : null,
    text: text,
    resultString: "",
    definitions: [],
  };

  const regexp = /{{(.*?)}}/g;
  // creates array from match groups and dedups
  const matches = [...new Set(Array.from(result.text.matchAll(regexp), (m) => m[1]))];

  matches.forEach((match) => {
    let entry = {
      parsed: null,
      match: match,
      replacePattern: new RegExp(`{{${escapeRegExp(match)}}}`, "g"),
      type: null,
      subType: null,
    };

    const splitRemoveUnsigned = match.split("#")[0];
    const splitMatchAt = splitRemoveUnsigned.split("@");
    const parsedMatch = parseMatch(ddb, character, splitRemoveUnsigned, feature);
    const dicePattern = /\d*d\d\d*/;
    const typeSplit = splitMatchAt[0].split(':');
    entry.type = typeSplit[0];
    if (typeSplit.length > 1) entry.subType = typeSplit[1];
    // do we have a dice string, e.g. sneak attack?
    if (parsedMatch.match(dicePattern)) {
      entry.type = "dice";
      entry.parsed = parsedMatch;
      result.text = result.text.replace(entry.replacePattern, entry.parsed);
    } else {
      // we try and eval the expression!
      try {
        /* eslint-disable no-eval */
        // eval is bad, it's quite slow and risky, however it avoids having to write a string parsing engine
        const evalMatch = eval(parsedMatch);
        /* eslint-enable no-eval */
        if (splitMatchAt.length > 1) {
          const constraintAdjusted = applyConstraint(evalMatch, splitMatchAt[1]);
          entry.parsed = getNumber(constraintAdjusted);
        } else {
          entry.parsed = getNumber(evalMatch);
        }
        entry.parsed = entry.parsed.replace("+ +", "+");
        result.text = result.text.replace(entry.replacePattern, entry.parsed);
      } catch (err) {
        result.text = result.text.replace(entry.replacePattern, `{{${match}}}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.warn */ .Z.warn(`ddb-importer does not know about template value {{${match}}}. Please log a bug.`, err);
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .default.warn */ .Z.warn(err.stack);
      }
    }
    if (entry.parsed) result.resultString += entry.parsed;
    result.definitions.push(entry);
  });

  result.text = result.text.replace("+ +", "+");
  // result.text = await parseTags(result.text);
  result.text = parseTags(result.text);
  character.flags.ddbimporter.dndbeyond.templateStrings.push(result);
  return result;
}


/***/ }),

/***/ 555:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(222);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(259);
/* harmony import */ var _ddbConfig_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31);
/* harmony import */ var _parser_effects_effects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(908);






const existingFiles = new Set();

const utils = {
  debug: () => {
    return true;
  },

  findByProperty: (arr, property, searchString) => {
    function levenshtein(a, b) {
      let tmp;
      if (a.length === 0) {
        return b.length;
      }
      if (b.length === 0) {
        return a.length;
      }
      if (a.length > b.length) {
        tmp = a;
        a = b;
        b = tmp;
      }

      let i,
        j,
        res,
        alen = a.length,
        blen = b.length,
        row = Array(alen);
      for (i = 0; i <= alen; i++) {
        row[i] = i;
      }

      for (i = 1; i <= blen; i++) {
        res = i;
        for (j = 1; j <= alen; j++) {
          tmp = row[j - 1];
          row[j - 1] = res;
          res = b[i - 1] === a[j - 1] ? tmp : Math.min(tmp + 1, Math.min(res + 1, row[j] + 1));
        }
      }
      return res;
    }

    const maxDistance = 3;
    let minDistance = 100;
    let nearestHit = undefined;
    let nearestDistance = minDistance;

    if (!Array.isArray(arr)) return undefined;
    arr
      .filter((entry) => Object.prototype.hasOwnProperty.call(entry, property))
      .forEach((entry) => {
        let distance = levenshtein(searchString, entry[property]);
        if (distance < nearestDistance && distance <= maxDistance && distance < minDistance) {
          nearestHit = entry;
          nearestDistance = distance;
        }
      });

    return nearestHit;
  },

  hasChosenCharacterOption: (data, optionName) => {
    const hasClassOptions = [data.character.options.race, data.character.options.class, data.character.options.feat]
      .flat()
      .some((option) => option.definition.name === optionName);
    return hasClassOptions;
  },

  getClassFromOptionID: (data, optionId) => {
    // Use case class spell - which class?
    // componentId on spells.class[0].componentId = options.class[0].definition.id
    // options.class[0].definition.componentId = classes[0].classFeatures[0].definition.id
    const option = data.character.options.class.find((option) => option.definition.id === optionId);

    if (option) {
      const klass = data.character.classes.find((klass) =>
        klass.classFeatures.some((feature) => feature.definition.id === option.componentId)
      );
      return klass;
    }
    return undefined;
  },

  /**
   * Look up a component by id
   * For now we assume that most features we are going to want to get a scaling value
   * from are character options
   * @param {*} ddb
   * @param {*} featureId
   */

  findComponentByComponentId: (ddb, componentId) => {
    let result;

    ddb.character.classes.forEach((cls) => {
      const feature = cls.classFeatures.find((component) => component.definition.id === componentId);
      if (feature) result = feature;
    });

    const optionalClassFeature = ddb.classOptions.find((option) => option.id == componentId);
    if (optionalClassFeature && !result) {
      result = optionalClassFeature;
      const optionalLevelScales = optionalClassFeature.levelScales && optionalClassFeature.levelScales.length > 0;
      if (result && !result.levelScale && optionalLevelScales) {
        const klass = ddb.character.classes.find((cls) => cls.definition.id === optionalClassFeature.classId);
        const klassLevel = klass ? klass.level : undefined;
        if (klassLevel) {
          const levelFilteredScales = optionalClassFeature.levelScales.filter((scale) => scale.level <= klassLevel);
          if (levelFilteredScales.length > 0) {
            result.levelScale = levelFilteredScales
              .reduce((previous, current) => {
                if (previous.level > current.level) return previous;
                return current;
              });
          }
        }
      }
    }

    return result;
  },

  /**
   *
   * Gets the sourcebook for a subset of dndbeyond sources
   * @param {obj} definition item definition
   */
  getSourceData: (definition) => {
    const fullSource = game.settings.get("ddb-importer", "use-full-source");
    const result = {
      name: null,
      page: null,
    };
    if (definition.sources?.length > 0) {
      result.name = _ddbConfig_js__WEBPACK_IMPORTED_MODULE_4__/* .DDB_CONFIG.sources.filter */ .U.sources.filter((source) => definition.sources.some((ds) => source.id === ds.sourceId))
        .map((source) => {
          const dSource = definition.sources.find((ds) => source.id === ds.sourceId);
          const page = dSource.pageNumber ? ` pg ${dSource.pageNumber}` : "";
          const sourceBook = dSource ? (fullSource ? source.description : source.name) : "Homebrew";
          return `${sourceBook}${page}`;
        })
        .join(", ");
    } else {
      if (definition.sourceIds) {
        result.name = _ddbConfig_js__WEBPACK_IMPORTED_MODULE_4__/* .DDB_CONFIG.sources.filter */ .U.sources.filter((source) => definition.sourceIds.includes(source.id))
          .map((source) => source.description)
          .join();
      } else if (definition.sourceId) {
        result.name = _ddbConfig_js__WEBPACK_IMPORTED_MODULE_4__/* .DDB_CONFIG.sources.filter */ .U.sources.filter((source) => source.id === definition.sourceId)
          .map(
            fullSource
              ? ({ description }) => description
              : ({ name }) => name
          );
      }

      // add a page num if available
      if (definition.sourcePageNumber) result.page = definition.sourcePageNumber;
    }
    return result;
  },

  /**
   * Fetches the sources and pages for a definition
   * @param {obj} data item
   */
  parseSource: (definition) => {
    const sourceData = utils.getSourceData(definition);

    let source = sourceData.name;
    if (sourceData.page) source += ` (pg. ${sourceData.page})`;

    return source;
  },

  getActiveItemModifiers: (data, includeExcludedEffects = false) => {
    // are we adding effects to items?
    const addEffects = game.settings.get("ddb-importer", "character-update-policy-add-item-effects");
    const daeInstalled = utils.isModuleInstalledAndActive("dae");
    const excludedModifiers = (addEffects && daeInstalled && !includeExcludedEffects) ? (0,_parser_effects_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .getEffectExcludedModifiers */ .qk)("item", true, true) : [];
    // get items we are going to interact on
    const modifiers = data.character.inventory
      .filter(
        (item) =>
          ((!item.definition.canEquip && !item.definition.canAttune && !item.definition.isConsumable) || // if item just gives a thing and not potion/scroll
          (item.isAttuned && item.equipped) || // if it is attuned and equipped
          (item.isAttuned && !item.definition.canEquip) || // if it is attuned but can't equip
            (!item.definition.canAttune && item.equipped)) && // can't attune but is equipped
          item.definition.grantedModifiers.length > 0
      )
      .flatMap((item) => item.definition.grantedModifiers)
      .filter((mod) => !excludedModifiers.some((exMod) =>
        mod.type === exMod.type &&
        (mod.subType === exMod.subType || !exMod.subType))
      );

    return modifiers;
  },

  getActiveItemEffectModifiers: (data) => {
    return utils.getActiveItemModifiers(data, true).filter((mod) =>
    (0,_parser_effects_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .getEffectExcludedModifiers */ .qk)("item", true, true).some((exMod) => mod.type === exMod.type &&
      (mod.subType === exMod.subType || !exMod.subType))
    );
  },

  getModifiers: (data, type, includeExcludedEffects = false, effectOnly = false) => {
    // are we adding effects to items?
    const featureEffects = game.settings.get("ddb-importer", "character-update-policy-add-character-effects");
    const acEffects = game.settings.get("ddb-importer", "character-update-policy-generate-ac-feature-effects");
    const daeInstalled = utils.isModuleInstalledAndActive("dae");
    const excludedModifiers = ((featureEffects || acEffects) && daeInstalled &&
      (!includeExcludedEffects || (includeExcludedEffects && effectOnly)))
        ? (0,_parser_effects_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .getEffectExcludedModifiers */ .qk)(type, featureEffects, acEffects)
        : (0,_parser_effects_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .getEffectExcludedModifiers */ .qk)(type, false, false);
    // get items we are going to interact on
    let modifiers = [];
    if (effectOnly) {
      modifiers = data.character.modifiers[type]
      .filter((mod) => excludedModifiers.some((exMod) =>
        mod.type === exMod.type &&
        (mod.subType === exMod.subType || !exMod.subType))
      );
    } else {
      modifiers = data.character.modifiers[type]
      .filter((mod) => !excludedModifiers.some((exMod) =>
        mod.type === exMod.type &&
        (mod.subType === exMod.subType || !exMod.subType))
      );
    }

    return modifiers;
  },

  filterModifiers: (modifiers, type, subType = null, restriction = ["", null]) => {
    return modifiers
      .flat()
      .filter(
        (modifier) =>
          modifier.type === type &&
          (subType !== null ? modifier.subType === subType : true) &&
          (!restriction ? true : restriction.includes(modifier.restriction))
      );
  },

  getChosenClassModifiers: (data, includeExcludedEffects = false, effectOnly = false) => {
    // get items we are going to interact on
    const modifiers = utils.getModifiers(data, 'class', includeExcludedEffects, effectOnly).filter((mod) => {
      const isClassFeature = data.character.classes.some((klass) => klass.classFeatures.some((feat) =>
        feat.definition.id == mod.componentId && feat.definition.entityTypeId == mod.componentTypeId &&
        // make sure this class feature is not replaced
        !data.character.optionalClassFeatures.some((f) => f.affectedClassFeatureId == feat.definition.id)
      ));
      // generate a list to check in option check
      const classFeatureIds = data.character.classes.map((klass) => klass.classFeatures.map((feat) => feat.definition.id)).flat();
      const isClassOption = data.character.options.class.some((option) =>
        // does this class option match a modifier?
        ((option.componentTypeId == mod.componentTypeId && option.componentId == mod.componentId) ||
        (option.definition.entityTypeId == mod.componentTypeId && option.definition.id == mod.componentId)) &&
        // has this feature set been replacd by an optional class feature?
        !data.character.optionalClassFeatures.some((f) => f.affectedClassFeatureId == option.componentId) &&
        // has it been chosen?
        data.character.choices.class.some((choice) =>
          choice.componentId == option.componentId && choice.componentTypeId == option.componentTypeId && choice.optionValue
        ) &&
        // is this option actually part of the class list?
        classFeatureIds.includes(option.componentId)
      );
      // if it's been replaced by a class feature lets check that
      const isOptionalClassOption = data.character.options.class.some((option) =>
        ((option.componentTypeId == mod.componentTypeId && option.componentId == mod.componentId) ||
        (option.definition.entityTypeId == mod.componentTypeId && option.definition.id == mod.componentId)) &&
        // !data.character.optionalClassFeatures.some((f) => f.affectedClassFeatureId == option.definition.id) &&
        (
          data.character.choices.class.some((choice) =>
            choice.componentId == option.componentId && choice.componentTypeId == option.componentTypeId && choice.optionValue
          ) ||
          data.classOptions?.some((classOption) =>
            classOption.id == option.componentId && classOption.entityTypeId == option.componentTypeId
          )
        ) &&
        data.character.optionalClassFeatures?.some((f) => f.classFeatureId == option.componentId)
      );

      // new class feature choice
      const isOptionalClassChoice = data.character.choices.class.some((choice) =>
        choice.componentTypeId == mod.componentTypeId &&
        choice.componentId == mod.componentId &&
        data.character.optionalClassFeatures?.some((f) => f.classFeatureId == choice.componentId)
      );

      return isClassFeature || isClassOption || isOptionalClassOption || isOptionalClassChoice;
    });

    return modifiers;
  },

  // I need to getChosenOriginFeatures from data.optionalOriginFeatures

  filterBaseModifiers: (data, type, subType = null, restriction = ["", null], includeExcludedEffects = false, effectOnly = false) => {
    const modifiers = [
      utils.getChosenClassModifiers(data, includeExcludedEffects, effectOnly),
      utils.getModifiers(data, "race", includeExcludedEffects, effectOnly),
      utils.getModifiers(data, "background", includeExcludedEffects, effectOnly),
      utils.getModifiers(data, "feat", includeExcludedEffects, effectOnly),
      utils.getActiveItemModifiers(data, includeExcludedEffects),
    ];

    return utils.filterModifiers(modifiers, type, subType, restriction);
  },

  /**
   * Checks the list of modifiers provided for a matching bonus type
   * and returns a sum of it's value. May include a dice string.
   * @param {*} modifiers
   * @param {*} character
   * @param {*} bonusSubType
   */
  getModifierSum: (modifiers, character) => {
    let sum = 0;
    let diceString = "";
    let modBonus = 0;
    modifiers.forEach((modifier) => {
      const fixedBonus = modifier.dice?.fixedValue ? modifier.dice.fixedValue : 0;
      const statBonus = (modifier.statId)
        ? modifier.statId
        : modifier.abilityModifierStatId
          ? modifier.abilityModifierStatId
          : null;
      if (statBonus) {
        const ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_1__/* .default.character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === modifier.statId);
        modBonus += character.data.abilities[ability.value].mod;
      }
      if (modifier.dice) {
        const mod = modifier.dice.diceString;
        diceString += diceString === "" ? mod : " + " + mod;
        if (modifier.dice.diceString) {
          const mod = modifier.dice.diceString + modBonus + fixedBonus;
          diceString += diceString === "" ? mod : " + " + mod;
        } else if (fixedBonus) {
          sum += fixedBonus + modBonus;
        }
      } else if (modifier.fixedValue) {
        sum += modifier.fixedValue;
      } else if (modifier.value) {
        sum += modifier.value;
      } else if (modifier.modifierTypeId === 1 && modifier.modifierSubTypeId === 218) {
        // prof bonus
        sum += character.data.attributes.prof;
      } else if (modBonus !== 0) {
        sum += modBonus;
      }
    });
    if (diceString !== "") {
      sum = diceString + " + " + sum;
    }

    return sum;
  },

  /**
   * Searches for selected options if a given feature provides choices to the user
   * @param {string} type character property: "class", "race" etc.
   * @param {object} feat options to search for
   */
  getChoices: (ddb, type, feat) => {
    const id = feat.id ? feat.id : feat.definition.id ? feat.definition.id : null;

    if (ddb.character.choices[type] && Array.isArray(ddb.character.choices[type])) {
      // find a choice in the related choices-array
      const choices = ddb.character.choices[type].filter(
        (characterChoice) => characterChoice.componentId && characterChoice.componentId === id
      );

      if (choices) {
        const choiceDefinitions = ddb.character.choices.choiceDefinitions;

        const options = choices
          .filter(
            (choice) => {
              const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);
              const validOption = optionChoice && optionChoice.options.find((option) => option.id === choice.optionValue);
              return validOption;
            })
          .map((choice) => {
            // console.warn(choice);
            const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);
            let result = optionChoice.options.find((option) => option.id === choice.optionValue);
            result.componentId = choice.componentId;
            result.componentTypeId = choice.componentTypeId;
            result.choiceId = choice.id;
            result.parentChoiceId = choice.parentChoiceId;
            // console.log(result);
            return result;
          });
        return options;
      }
    }
    // we could not determine if there are any choices left
    return undefined;
  },

  getComponentIdFromOptionValue: (ddb, type, optionId) => {
    if (ddb.character.choices[type] && Array.isArray(ddb.character.choices[type])) {
      // find a choice in the related choices-array
      const choice = ddb.character.choices[type].find(
        (characterChoice) => characterChoice.optionValue && characterChoice.optionValue === optionId
      );
      if (choice) return choice.componentId;
    }
    // we could not determine if there are any choices left
    return undefined;
  },

  determineActualFeatureId: (data, featureId, type = "class") => {
    const optionalFeatureReplacement = data.character.optionalClassFeatures
      .filter((f) => f.classFeatureId === featureId)
      .map((f) => f.affectedClassFeatureId);
    // are we dealing with an optional class feature?
    const choiceFeature = utils.getComponentIdFromOptionValue(data, type, featureId);

    if (choiceFeature) {
      const choiceOptionalFeature = data.character.optionalClassFeatures
        .filter((f) => f.classFeatureId === choiceFeature)
        .map((f) => f.affectedClassFeatureId);
      if (choiceOptionalFeature && choiceOptionalFeature.length > 0) {
        return choiceOptionalFeature[0];
      }
    } else if (optionalFeatureReplacement && optionalFeatureReplacement.length > 0) {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* .default.debug */ .Z.debug(`Feature ${featureId} is replacing ${optionalFeatureReplacement[0]}`);
      return optionalFeatureReplacement[0];
    }
    return featureId;
  },

  findClassByFeatureId: (data, featureId) => {
    // optional class features need this filter, as they replace existing features
    const featId = utils.determineActualFeatureId(data, featureId);
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* .default.debug */ .Z.debug(`Finding featureId ${featureId}`);

    let cls = data.character.classes.find((cls) => {
      let classFeatures = cls.classFeatures;
      let featureMatch = classFeatures.find((feature) => feature.definition.id === featId);

      if (featureMatch) {
        return true;
      } else {
        // if not in global class feature list lets dig down
        classFeatures = cls.definition.classFeatures;
        if (cls.subclassDefinition && cls.subclassDefinition.classFeatures) {
          classFeatures = classFeatures.concat(cls.subclassDefinition.classFeatures);
        }
        return classFeatures.some((feature) => feature.id === featId);
      }
    });
    // try class option lookup
    if (!cls) {
      const option = data.character.options.class.find((option) => option.definition.id == featureId);
      if (option) {
        cls = data.character.classes.find((cls) => cls.classFeatures.find((feature) => feature.definition.id == option.componentId));
      }
    }
    // class option lookups
    if (!cls && data.classOptions) {
      const classOption = data.classOptions.find((option) => option.id == featureId);
      if (classOption) {
        cls = data.character.classes.find((cls) => cls.definition.id == classOption.classId);
      }
    }
    if (!cls) {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* .default.debug */ .Z.debug(`Class not found for ${featureId}`);
    }
    return cls;
  },

  calculateModifier: (val) => {
    return Math.floor((val - 10) / 2);
  },

  diceStringResultBuild: (diceMap, dice, bonus = "", mods = "", diceHint = "", specialFlags = "") => {
    const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
    const resultBonus = bonus === 0 ? "" : `${bonus > 0 ? ' +' : ' '} ${bonus}`;
    const diceHintAdd = globalDamageHints && diceHint && diceMap;
    const hintString = diceHintAdd ? diceHint : "";
    const diceHintString = diceMap.map(({ sign, count, die }, index) =>
      `${index ? `${sign} ` : ''}${count}d${die}${specialFlags}${hintString}`
    ).join(' ');

    const result = {
      dice,
      diceMap,
      diceHintString,
      bonus,
      diceString: [
        diceHintString,
        mods,
        resultBonus
      ].join('').trim(),
    };
    return result;
  },

  parseDiceString: (inStr, mods = "", diceHint = "", specialFlags = "") => {
    // sanitizing possible inputs a bit
    const str = `${inStr}`.toLowerCase().replace(/[â€“-â€“âˆ’]/gu, "-").replace(/\s+/gu, "");

    // all found dice strings, e.g. 1d8, 4d6
    let dice = [];
    // all bonuses, e.g. -1+8
    let bonuses = [];

    const diceRegex = /(?<rawSign>[+-]*)(?<count>\d+)(?:d(?<die>\d+))?/gu;

    for (const { groups } of str.matchAll(diceRegex)) {
      const {
        rawSign = '+',
        count,
        die
      } = groups;

      // sign. We only take the sign standing exactly in front of the dice string
      // so +-1d8 => -1d8. Just as a failsave
      const sign = rawSign === "" ? "+" : rawSign.slice(-1);

      if (die) {
        dice.push({
          sign,
          count: parseInt(sign + count),
          die: parseInt(die)
        });
      } else {
        bonuses.push({
          sign,
          count: parseInt(sign + count)
        });
      }
    }

    // sum up the bonus
    const bonus = bonuses.reduce((prev, cur) => prev + cur.count, 0);

    // group the dice, so that all the same dice are summed up if they have the same sign
    // e.g.
    // +1d8+2d8 => 3d8
    // +1d8-2d8 => +1d8 -2d8 will remain as-is
    const diceMap = [];

    const groupBySign = utils.groupBy(dice, 'sign');
    for (const group of groupBySign.values()) {
      const groupByDie = utils.groupBy(group, 'die');

      for (const dieGroup of groupByDie.values()) {
        diceMap.push(
          dieGroup.reduce((acc, item) => ({
            ...acc,
            count: acc.count + item.count
          }))
        );
      }
    }

    diceMap.sort((a, b) => {
      if (a.die < b.die) return -1;
      if (a.die > b.die) return 1;
      if (a.sign === b.sign) {
        if (a.count < b.count) return -1;
        if (a.count > b.count) return 1;
        return 0;
      } else {
        return a.sign === "+" ? -1 : 1;
      }
    });

    const result = utils.diceStringResultBuild(diceMap, dice, bonus, mods, diceHint, specialFlags);
    return result;
  },

  capitalize: (s) => {
    if (typeof s !== "string") return "";
    return s.charAt(0).toUpperCase() + s.slice(1);
  },

  htmlToDoc: (text) => {
    const parser = new DOMParser();
    return parser.parseFromString(text, "text/html");
  },

  // DEVELOPMENT FUNCTION
  // loads a character.json from a file in the file system
  // loadFromFile: (filename) => {
  //   return require(`./input/${filename}.json`);
  // },

  // checks for a given file
  serverFileExists: (path) => {
    return new Promise((resolve, reject) => {
      let http = new XMLHttpRequest();
      http.open("HEAD", path);
      http.onreadystatechange = function () {
        if (this.readyState == this.DONE) {
          if (this.status >= 200 && this.status <= 399) {
            // Assume any 2xx or 3xx responses mean the image is there.
            resolve(path);
          } else {
            reject(path);
          }
        }
      };

      http.send();
    });
  },

  fileExistsUpdate: (fileList) => {
    const targetFiles = fileList.filter((f) => !existingFiles.has(f));
    for (const file of targetFiles) {
      existingFiles.add(file);
    }
  },

  generateCurrentFiles: async (directoryPath) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* .default.debug */ .Z.debug(`Checking for files in ${directoryPath}...`);
    const dir = _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.parse */ .B.parse(directoryPath);
    const fileList = await _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.browse */ .B.browse(dir.activeSource, dir.current, { bucket: dir.bucket });
    utils.fileExistsUpdate(fileList.files);
  },

  fileExists: async (directoryPath, filename) => {
    const fileUrl = await utils.getFileUrl(directoryPath, filename);
    let existingFile = existingFiles.has(fileUrl);
    if (existingFile) return true;

    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* .default.debug */ .Z.debug(`Checking for ${filename} at ${fileUrl}...`);
    const dir = _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.parse */ .B.parse(directoryPath);
    const fileList = await _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.browse */ .B.browse(dir.activeSource, dir.current, { bucket: dir.bucket });

    if (fileList.files.includes(fileUrl)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* .default.debug */ .Z.debug(`Found ${fileUrl}`);
      existingFiles.add(fileUrl);
      return true;
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* .default.debug */ .Z.debug(`Could not find ${fileUrl}`);
      return false;
    }
  },

  getTemplate: (type) => {
    let isObject = (item) => {
      return item && typeof item === "object" && !Array.isArray(item);
    };

    let mergeDeep = (target, source) => {
      let output = Object.assign({}, target);
      if (isObject(target) && isObject(source)) {
        Object.keys(source).forEach((key) => {
          if (isObject(source[key])) {
            if (!(key in target)) Object.assign(output, { [key]: source[key] });
            else output[key] = mergeDeep(target[key], source[key]);
          } else {
            Object.assign(output, { [key]: source[key] });
          }
        });
      }
      return output;
    };
    let filterDeprecated = (data) => {
      for (let prop in data) {
        if (
          data[prop] &&
          Object.prototype.hasOwnProperty.call(data[prop], "_deprecated") &&
          data[prop]["_deprecated"] === true
        ) {
          delete data[prop];
        }
        if (prop === "_deprecated" && data[prop] === true) {
          delete data[prop];
        }
      }
      return data;
    };

    let templates = game.data.system.template;
    for (let entityType in templates) {
      if (
        templates[entityType].types &&
        Array.isArray(templates[entityType].types) &&
        templates[entityType].types.includes(type)
      ) {
        let obj = mergeDeep({}, filterDeprecated(templates[entityType][type]));
        if (obj.templates) {
          obj.templates.forEach((tpl) => {
            obj = mergeDeep(obj, filterDeprecated(templates[entityType].templates[tpl]));
          });
          delete obj.templates;
        }
        // store the result as JSON for easy cloning
        return JSON.stringify(obj);
      }
    }
    return undefined;
  },

  uploadImage: async function (url, targetDirectory, baseFilename, useProxy = true) {
    async function downloadImage(url) {
      return new Promise((resolve, reject) => {
        fetch(url, {
          method: "GET",
          headers: {
            "x-requested-with": "foundry"
          },
        })
          .then((response) => {
            if (!response.ok) {
              reject("Could not retrieve image");
            }
            return response.blob();
          })
          .then((blob) => resolve(blob))
          .catch((error) => reject(error.message));
      });
    }

    async function upload(data, path, filename) {
      return new Promise((resolve, reject) => {
        // create new file from the response

        const uploadFile = async (data, path, filename) => {
          const file = new File([data], filename, { type: data.type });
          const result = await _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.uploadToPath */ .B.uploadToPath(path, file);
          return result;
        };

        uploadFile(data, path, filename)
          .then((result) => {
            resolve(result.path);
          })
          .catch((error) => {
            _logger_js__WEBPACK_IMPORTED_MODULE_2__/* .default.error */ .Z.error("error uploading file: ", error);
            reject(error);
          });
      });
    }

    async function process(url, path, filename) {
      // let data = await download(url);
      let data = await downloadImage(url);
      // hack as proxy returns ddb access denied as application/xml
      if (data.type === "application/xml") return null;
      let result = await upload(data, path, filename);
      return result;
    }

    // prepare filenames
    let filename = baseFilename;
    let ext = url
      .split(".")
      .pop()
      .split(/#|\?|&/)[0];

    // uploading the character avatar and token
    try {
      const proxyEndpoint = game.settings.get("ddb-importer", "cors-endpoint");
      const urlEncode = game.settings.get("ddb-importer", "cors-encode");
      const target = urlEncode ? encodeURIComponent(url) : url;
      url = useProxy ? proxyEndpoint + target : url;
      // console.error(`URL: ${url}`);
      let result = await process(url, targetDirectory, filename + "." + ext);
      return result;
    } catch (error) {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* .default.error */ .Z.error("Image upload error", error);
      ui.notifications.warn(`Image upload failed. Please check your ddb-importer upload folder setting. ${url}`);
      return null;
    }
  },

  getOrCreateFolder: async (root, entityType, folderName, folderColor = "") => {
    let folder = game.folders.contents.find((f) =>
      f.data.type === entityType && f.data.name === folderName &&
      f.data.parent === (root ? root.id : null)
    );
    // console.warn(`Looking for ${root} ${entityType} ${folderName}`);
    // console.warn(folder);
    if (folder) return folder;
    folder = await Folder.create(
      {
        name: folderName,
        type: entityType,
        color: folderColor,
        parent: (root) ? root.id : null,
      },
      { displaySheet: false }
    );
    return folder;
  },

  // eslint-disable-next-line no-unused-vars
  getFolder: async (kind, subFolder = "", baseFolderName = "D&D Beyond Import", baseColor = "#6f0006", subColor = "#98020a", typeFolder = true) => {
    let entityTypes = new Map();
    entityTypes.set("spell", "Item");
    entityTypes.set("equipment", "Item");
    entityTypes.set("consumable", "Item");
    entityTypes.set("tool", "Item");
    entityTypes.set("loot", "Item");
    entityTypes.set("class", "Item");
    entityTypes.set("backpack", "Item");
    entityTypes.set("magic-items", "Item");
    entityTypes.set("magic-item-spells", "Item");
    entityTypes.set("npc", "Actor");
    entityTypes.set("character", "Actor");
    entityTypes.set("extras", "Actor");
    entityTypes.set("scene", "Scene");
    entityTypes.set("page", "JournalEntry");
    entityTypes.set("journal", "JournalEntry");
    entityTypes.set("journalEntry", "JournalEntry");

    const folderName = game.i18n.localize(`ddb-importer.item-type.${kind}`);
    const entityType = entityTypes.get(kind);
    const baseFolder = await utils.getOrCreateFolder(null, entityType, baseFolderName, baseColor);
    const entityFolder = typeFolder ? await utils.getOrCreateFolder(baseFolder, entityType, folderName, subColor) : baseFolder;
    if (subFolder !== "") {
      const subFolderName = subFolder.charAt(0).toUpperCase() + subFolder.slice(1);
      const typeFolder = await utils.getOrCreateFolder(entityFolder, entityType, subFolderName, subColor);
      return typeFolder;
    } else {
      return entityFolder;
    }
  },

  normalizeString: (str) => {
    return str.toLowerCase().replace(/\W/g, "");
  },

  /**
   * Queries a compendium for a single document
   * Returns either the entry from the index, or the complete document from the compendium
   */
  queryCompendiumEntry: async (compendiumName, documentName, getDocument = false) => {
    // normalize the entity name for comparison
    documentName = utils.normalizeString(documentName);

    // get the compendium
    const compendium = game.packs.get(compendiumName);
    if (!compendium) return null;

    // retrieve the compendium index
    const index = await compendium.getIndex();

    let id = index.find((entity) => utils.normalizeString(entity.name) === documentName);
    if (id && getDocument) {
      let entity = await compendium.getDocument(id._id);
      return entity;
    }
    return id ? id : null;
  },

  /**
   * Queries a compendium for a single document
   * Returns either the entry from the index, or the complete document from the compendium
   */
  queryCompendiumEntries: async (compendiumName, documentNames, getDocuments = false) => {
    // get the compendium
    let compendium = game.packs.get(compendiumName);
    if (!compendium) return null;

    // retrieve the compendium index
    let index = await compendium.getIndex();
    index = index.map((entry) => {
      entry.normalizedName = utils.normalizeString(entry.name);
      return entry;
    });

    // get the indices of all the entitynames, filter un
    let indices = documentNames
      .map((entityName) => {
        // sometimes spells do have restricted use in paranthesis after the name. Let's try to find those restrictions and add them later
        if (entityName.search(/(.+)\(([^()]+)\)*/) !== -1) {
          const match = entityName.match(/(.+)\(([^()]+)\)*/);
          return {
            name: utils.normalizeString(match[1].trim()),
            restriction: match[2].trim(),
          };
        } else {
          return {
            name: utils.normalizeString(entityName),
            restriction: null,
          };
        }
      })
      .map((data) => {
        let entry = index.find((entity) => entity.normalizedName === data.name);
        if (entry) {
          return {
            _id: entry._id,
            name: data.restriction ? `${entry.name} (${data.restriction})` : entry.name,
          };
        } else {
          return null;
        }
      });

    if (getDocuments) {
      // replace non-null values with the complete entity from the compendium
      let entities = await Promise.all(
        indices.map((entry) => {
          return new Promise((resolve) => {
            if (entry) {
              compendium.getDocument(entry._id).then((entity) => {
                entity.data.name = entry.name; // transfer restrictions over, if any
                // remove redudant info
                delete entity.data.id;
                delete entity.data.permission;
                resolve(entity.data);
              });
            } else {
              resolve(null);
            }
          });
        })
      );
      return entities;
    }
    return indices;
  },

  /**
   * Queries a compendium for a given document name
   * @returns the index entries of all matches, otherwise an empty array
   */
  queryCompendium: async (compendiumName, documentName, getDocument = false) => {
    documentName = utils.normalizeString(documentName);

    let compendium = game.packs.get(compendiumName);
    if (!compendium) return null;
    let index = await compendium.getIndex();
    let id = index.find((entity) => utils.normalizeString(entity.name) === documentName);
    if (id && getDocument) {
      let entity = await compendium.getEntity(id._id);
      return entity;
    }
    return id ? id : null;
  },

  getFileUrl: async (directoryPath, filename) => {
    let uri;
    try {
      let dir = _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.parse */ .B.parse(directoryPath);
      if (dir.activeSource == "data") {
        // Local on-server file system
        uri = dir.current + "/" + filename;
      } else if (dir.activeSource == "forgevtt") {
        const status = ForgeAPI.lastStatus || await ForgeAPI.status();
        const userId = status.user;
        uri = "https://assets.forge-vtt.com/" + userId + "/" + dir.current + "/" + filename;
      } else {
        // S3 Bucket
        uri =
          game.data.files.s3.endpoint.protocol +
          "//" +
          dir.bucket +
          "." +
          game.data.files.s3.endpoint.hostname +
          "/" +
          dir.current +
          "/" +
          filename;
      }
    } catch (exception) {
      throw new Error(
        'Unable to determine file URL for directoryPath"' + directoryPath + '" and filename"' + filename + '"'
      );
    }
    return encodeURI(uri);
  },

  versionCompare: (v1, v2, options) => {
    var lexicographical = options && options.lexicographical,
      zeroExtend = options && options.zeroExtend,
      v1parts = v1.split("."),
      v2parts = v2.split(".");

    function isValidPart(x) {
      return (lexicographical ? /^\d+[A-Za-z]*$/ : /^\d+$/).test(x);
    }

    if (!v1parts.every(isValidPart) || !v2parts.every(isValidPart)) {
      return NaN;
    }

    if (zeroExtend) {
      while (v1parts.length < v2parts.length) v1parts.push("0");
      while (v2parts.length < v1parts.length) v2parts.push("0");
    }

    if (!lexicographical) {
      v1parts = v1parts.map(Number);
      v2parts = v2parts.map(Number);
    }

    for (var i = 0; i < v1parts.length; ++i) {
      if (v2parts.length == i) {
        return 1;
      }

      if (v1parts[i] > v2parts[i]) {
        return 1;
      }
      if (v1parts[i] < v2parts[i]) {
        return -1;
      }
    }

    if (v1parts.length != v2parts.length) {
      return -1;
    }

    return 0;
  },

  isModuleInstalledAndActive: (moduleName) => {
    return game.modules.has(moduleName) && game.modules.get(moduleName).active;
  },

  groupBy(arr, property) {
    const map = new Map();

    for (const item of arr) {
      const prop = item[property];
      const group = map.get(prop) ?? [];

      group.push(item);
      map.set(prop, group);
    }

    return map;
  },

  getCustomValue(data, character, type) {
    if (!character) return null;
    const characterValues = character.flags.ddbimporter.dndbeyond.characterValues;
    const customValue = characterValues.filter((value) => value.valueId == data.id && value.valueTypeId == data.entityTypeId);

    if (customValue) {
      const value = customValue.find((value) => value.typeId == type);
      if (value) return value.value;
    }
    return null;
  },

  getName(data, character) {
    // spell name
    const customName = utils.getCustomValue(data, character, 8);
    if (customName) {
      return customName;
    } else if (data.definition?.name) {
      return data.definition.name;
    } else if (data.name) {
      return data.name;
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* .default.error */ .Z.error("Unable to determine name for:", data);
      return "Unknown thing.";
    }
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utils);


/***/ }),

/***/ 846:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": () => (/* binding */ isEqual)
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

// EXTERNAL MODULE: ./src/logger.js
var src_logger = __webpack_require__(259);
;// CONCATENATED MODULE: ./src/hooks/init/setupLogging.js
/* harmony default export */ function setupLogging() {
  let enabledDebugLogging = false;

  let defaults = {
    general: enabledDebugLogging,
    messaging: enabledDebugLogging,
    character: enabledDebugLogging,
    extension: enabledDebugLogging,
  };

  if (!CONFIG.debug.ddbimporter) {
    CONFIG.debug.ddbimporter = { dndbeyond: defaults };
  } else {
    CONFIG.debug.ddbimporter.dndbeyond = defaults;
  }
}

// EXTERNAL MODULE: ./src/muncher/monster/monster.js + 18 modules
var monster = __webpack_require__(519);
// EXTERNAL MODULE: ./src/muncher/import.js
var muncher_import = __webpack_require__(193);
// EXTERNAL MODULE: ./src/muncher/utils.js
var utils = __webpack_require__(192);
// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
// EXTERNAL MODULE: ./src/utils.js
var src_utils = __webpack_require__(555);
;// CONCATENATED MODULE: ./src/parser/spells/special.js




let getEldritchInvocations = (data) => {
  let damage = "";
  let range = 0;

  const eldritchBlastMods = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "eldritch-blast").filter(
    (modifier) => modifier.isGranted
  );

  eldritchBlastMods.forEach((mod) => {
    switch (mod.subType) {
      case "bonus-damage": {
        // almost certainly CHA :D
        const abilityModifierLookup = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === mod.statId);
        if (abilityModifierLookup) {
          if (damage !== "") damage += " + ";
          damage += `@abilities.${abilityModifierLookup.value}.mod`;
        } else if (mod.fixedValue) {
          if (damage !== "") damage += " + ";
          damage += `${mod.fixedValue}`;
        }
        break;
      }
      case "bonus-range":
        range = mod.value;
        break;
      default:
        src_logger/* default.warn */.Z.warn(`Not yet able to process ${mod.subType}, please raise an issue.`);
    }
  });

  return {
    damage: damage,
    range: range,
  };
};

function getCustomValue(data, ddb, type) {
  if (!ddb) return null;
  const characterValues = ddb.character.characterValues;
  const customValue = characterValues.filter((value) => value.valueId == data.flags.ddbimporter.dndbeyond.id && value.valueTypeId == data.flags.ddbimporter.dndbeyond.entityTypeId);

  if (customValue) {
    const customName = customValue.find((value) => value.typeId == type);
    if (customName) return customName.value;
  }
  return null;
}

function addCustomValues(item, ddb) {
  // to hit override requires a lot of crunching
  // const toHitOverride = getCustomValue(item, character, 13);
  const toHitBonus = getCustomValue(item, ddb, 12);
  const damageBonus = getCustomValue(item, ddb, 10);
  const dcOverride = getCustomValue(item, ddb, 15);
  const dcBonus = getCustomValue(item, ddb, 14);

  if (toHitBonus) item.data.attackBonus += toHitBonus;
  if (damageBonus && item.data.damage.parts.length !== 0) {
    item.data.damage.parts[0][0] = item.data.damage.parts[0][0].concat(` +${damageBonus}`);
  } else if (damageBonus) {
    const part = [`+${damageBonus}`, ""];
    item.data.damage.parts.push(part);
  }
  // if (damageBonus) item.data.damage.parts[0] = item.data.damage.parts[0].concat(` +${damageBonus}`);
  if (dcBonus) {
    if (item.flags.ddbimporter.dndbeyond.dc) {
      item.data.save.dc = parseInt(item.flags.ddbimporter.dndbeyond.dc) + dcBonus;
      item.data.save.scaling = "flat";
    }
  }
  if (dcOverride) {
    item.data.save.dc = dcOverride;
    item.data.save.scaling = "flat";
  }
}

/**
 * Some spells we need to fix up or massage because they are modified
 * in interesting ways
 * @param {*} ddb
 * @param {*} items
 */
/* eslint-disable complexity */
function fixSpells(ddb, items) {
  items.forEach((spell) => {
    switch (spell.name) {
      // Eldritch Blast is a special little kitten and has some fun Eldritch
      // Invocations which can adjust it.
      case "Eldritch Blast": {
        if (!ddb) break;
        const eldritchBlastMods = getEldritchInvocations(ddb);
        spell.data.damage.parts[0][0] += " + " + eldritchBlastMods["damage"];
        spell.data.range.value += eldritchBlastMods["range"];
        break;
      }
      // The target/range input data are incorrect on some AOE spells centred
      // on self.
      // Range is self with an AoE target of 15 ft cube
      // i.e. affects all creatures within 5 ft of caster
      case "Thunderclap":
      case "Word of Radiance":
        spell.data.range = { value: null, units: "self", long: null };
        spell.data.target = { value: 15, units: "ft", type: "cube" };
        break;
      case "Sleep": {
        spell.data.damage = { parts: [["5d8", ""]], versatile: "", value: "" };
        spell.data.scaling = { mode: "level", formula: "2d8" };
        break;
      }
      case "Ray of Enfeeblement":
        spell.data.actionType = "rsak";
        break;
      case "Color Spray": {
        spell.data.damage = { parts: [["6d10", ""]], versatile: "", value: "" };
        spell.data.scaling = { mode: "level", formula: "2d10" };
        break;
      }
      case "Gust of Wind":
        spell.data.target = { value: 60, units: "ft", type: "line", width: 10 };
        break;
      case "Produce Flame":
        spell.data.range = { value: 30, units: "ft", long: null };
        break;
      case "Hex":
      case "Shadow of Moil":
      case "Cloud of Daggers":
      case "Magic Missile":
        spell.data.actionType = "other";
        break;
      // dnd beyond lists a damage for each type
      case "Chaos Bolt":
        spell.data.damage = { parts: [["2d8", ""], ["1d6", ""]], versatile: "", value: "" };
        break;
      // dnd beyond lists a damage for each type
      case "Chromatic Orb":
        spell.data.damage = { parts: [["3d8", ""]], versatile: "", value: "" };
        spell.data.chatFlavor = "Choose from Acid, Cold, Fire, Lightning, Poison, Thunder, or Acid";
        break;
      case "Dragon's Breath":
        spell.data.damage = { parts: [["3d6", ""]], versatile: "", value: "" };
        spell.data.chatFlavor = "Choose one of Acid, Cold, Fire, Lightning, or Poison.";
        break;
      case "Hunter's Mark":
      case "Hunterâ€™s Mark":
        spell.data.damage = { parts: [["1d6", ""]], versatile: "", value: "" };
        spell.data.actionType = "other";
        break;
      case "Pyrotechnics":
        spell.data['target']['value'] = 15;
        break;
      case "Absorb Elements":
        spell.data.damage = { parts: [["1d6", ""]], versatile: "", value: "" };
        spell.data.chatFlavor = "Uses the damage type of the triggered attack: Acid, Cold, Fire, Lightning, or Poison.";
        spell.data['target']['value'] = 1;
        break;
      case "Booming Blade":
        spell.data.damage = { parts: [["0", "thunder"]], versatile: "1d8", value: "" };
        spell.data.scaling = { mode: "cantrip", formula: "1d8" };
        spell.data.actionType = "other";
        break;
      case "Green-Flame Blade":
        spell.data.damage = { parts: [["0", "fire"]], versatile: "@mod", value: "" };
        spell.data.scaling = { mode: "cantrip", formula: "1d8" };
        spell.data.actionType = "other";
        break;
      case "Toll the Dead":
        spell.data.scaling = { mode: "cantrip", formula: "" };
        break;
      case "Goodberry":
        spell.data.damage = { parts: [["1", "healing"]], versatile: "", value: "" };
        break;
      case "Flaming Sphere":
        spell.data.target['value'] = 2.5;
        break;
      case "Heat Metal":
        spell.data.actionType = "save";
        break;
      case "Searing Smite": {
        if (spell.data.damage.parts.length > 1) {
          spell.data.formula = spell.data.damage.parts[1][0];
          spell.data.damage.parts = [spell.data.damage.parts[0]];
        }
        spell.data.scaling = { mode: "level", formula: "1d6" };
        break;
      }
      case "Spirit Guardians": {
        if (!ddb) break;
        const radiantAlignments = [1, 2, 3, 4, 5, 6, 10, 14];
        const necroticAlignments = [7, 8, 9, 11];
        if (radiantAlignments.includes(ddb.character.alignmentId)) {
          spell.data.damage = { parts: [["3d8", "radiant"]], versatile: "", value: "" };
        } else if (necroticAlignments.includes(ddb.character.alignmentId)) {
          spell.data.damage = { parts: [["3d8", "necrotic"]], versatile: "", value: "" };
        }
        break;
      }
      case "Armor of Agathys": {
        spell.data.actionType = "heal";
        spell.data['target']['type'] = "self";
        spell.data.damage.parts[0] = ["5d1", "temphp"];
        spell.data.scaling = { mode: "level", formula: "5d1" };
        break;
      }
      case "Divine Favor": {
        spell.data.actionType = "util";
        spell.data['target']['type'] = "self";
        break;
      }
      // no default
    }

  if (ddb) addCustomValues(spell, ddb);
  });
}
/* eslint-enable complexity */



;// CONCATENATED MODULE: ./src/parser/spells/components.js
function getComponents (data) {
  return {
    value: data.definition.componentsDescription,
    vocal: data.definition.components.includes(1),
    somatic: data.definition.components.includes(2),
    material: data.definition.components.includes(3),
    ritual: data.definition.ritual,
    concentration: data.definition.concentration,
  };
}

function getMaterials(data) {
  // this is mainly guessing
  if (data.definition.componentsDescription && data.definition.componentsDescription.length > 0) {
    let cost = 0;
    let matches = data.definition.componentsDescription.toLowerCase().match(/([\d.,]+)\s*gp/);
    if (matches) {
      cost = parseInt(matches[1].replace(/,|\./g, ""));
    }

    return {
      value: data.definition.componentsDescription,
      consumed: data.definition.componentsDescription.toLowerCase().indexOf("consume") !== -1,
      cost: cost,
      supply: 0,
    };
  } else {
    return {
      value: "",
      consumed: false,
      cost: 0,
      supply: 0,
    };
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/prepartion.js




function classSpell(data, result) {
  const classPrepMode = src_utils/* default.findByProperty */.Z.findByProperty(
    dictionary/* default.spell.preparationModes */.Z.spell.preparationModes,
    "name",
    data.flags.ddbimporter.dndbeyond.class
  );
  if (data.restriction === "As Ritual Only") {
    result.mode = "prepared";
    result.prepared = false;
  } else if (!data.usesSpellSlot && data.definition.level !== 0) {
    // some class features such as druid circle of stars grants x uses of a spell
    // at the lowest level. for these we add as an innate.
    result.mode = "innate";
  } else if (data.alwaysPrepared) {
    result.mode = "always";
  } else if (result.mode && classPrepMode) {
    result.mode = classPrepMode.value;
  }
  // Warlocks should use Pact spells
  // but lets mark level 0 as regular spells so they show up as cantrips
  if (result.mode === "pact" && data.definition.level === 0) {
    result.mode = "prepared";
    result.prepared = true;
  }
  return result;
}

/**
 * Retrieves the spell preparation mode, depending on the location this spell came from
 *
 */
function getSpellPreparationMode(data) {
  // default values
  let result = {
    mode: "prepared",
    // If always prepared mark as such, if not then check to see if prepared
    prepared: data.alwaysPrepared || data.prepared,
  };

  // handle classSpells
  const featureClass = data.flags.ddbimporter.dndbeyond.lookup === "classFeature" &&
    data.flags.ddbimporter.dndbeyond.class;

  if (data.flags.ddbimporter.dndbeyond.lookup === "classSpell" || featureClass) {
    result = classSpell(data, result);
  } else if (data.flags.ddbimporter.dndbeyond.lookup === "race" && data.definition.level !== 0) {
    // set race spells as innate
    result.mode = "innate";
    if (data.usesSpellSlot) {
      // some racial spells allow the spell to also be added to spell lists
      result.mode = "always";
    }
  } else if (
    // Warlock Mystic Arcanum are passed in as Features
    data.flags.ddbimporter.dndbeyond.lookupName.startsWith("Mystic Arcanum")
  ) {
    // these have limited uses (set with getUses())
    result.mode = "pact";
    result.prepared = false;
  } else if (data.flags.ddbimporter.dndbeyond.lookup === "item " && data.definition.level !== 0) {
    result.mode = "prepared";
    result.prepared = false;
  } else {
    // If spell doesn't use a spell slot and is not a cantrip, mark as always preped
    let always = !data.usesSpellSlot && data.definition.level !== 0;
    let ritaulOnly = data.ritualCastingType !== null || data.castOnlyAsRitual; // e.g. Book of ancient secrets & totem barb
    if (always && ritaulOnly) {
      // in this case we want the spell to appear in the spell list unprepared
      result.prepared = false;
    } else if (always) {
      // these spells are always prepared, and have a limited use that's
      // picked up by getUses() later
      // this was changed to "atwill"
      result.mode = "atwill";
    }
    if (data.flags.ddbimporter.dndbeyond.lookup === "classFeature") {
      if (data.alwaysPrepared) {
        result.mode = "always";
      }
    }
  }

  return result;
}

;// CONCATENATED MODULE: ./src/parser/spells/uses.js


/**
 * Get the reset condition of the spell, if uses restricted
 * @param {*} data Spell data
 */
function getUses(data) {
  let resetType = null;
  let limitedUse = null;
  // we check this, as things like items have useage attached to the item, not spell
  if (data.flags.ddbimporter.dndbeyond.limitedUse !== undefined && data.flags.ddbimporter.dndbeyond.limitedUse !== null) {
    limitedUse = data.flags.ddbimporter.dndbeyond.limitedUse;
    resetType = dictionary/* default.resets.find */.Z.resets.find((reset) => reset.id == limitedUse.resetType);
  } else if (data.limitedUse !== undefined && data.limitedUse !== null) {
    limitedUse = data.limitedUse;
    resetType = dictionary/* default.resets.find */.Z.resets.find((reset) => reset.id == limitedUse.resetType);
  }

  if (resetType !== null && resetType !== undefined) {
    return {
      value: limitedUse.numberUsed ? limitedUse.maxUses - limitedUse.numberUsed : parseInt(limitedUse.maxUses),
      max: parseInt(limitedUse.maxUses),
      per: resetType.value,
    };
  } else {
    return {};
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/activation.js


/**
 * Gets the activation information of this spell
 */
function getActivation(data) {
  let activationType = dictionary/* default.spell.activationTypes.find */.Z.spell.activationTypes.find(
    (type) => type.activationType === data.definition.activation.activationType
  );
  if (activationType && data.definition.activation.activationTime) {
    return {
      type: activationType.value,
      cost: data.definition.activation.activationTime,
      condition: "",
    };
  } else {
    return {
      type: "action",
      cost: 1,
      condition: "",
    };
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/duration.js
/**
 * Retrieves the spell duration
 */
function getDuration(data) {
  if (data.definition.duration) {
    let units = "";
    if (data.definition.duration.durationUnit !== null) {
      units = data.definition.duration.durationUnit.toLowerCase();
    } else {
      units = data.definition.duration.durationType.toLowerCase().substring(0, 4);
    }
    return {
      value: data.definition.duration.durationInterval || "",
      units: units,
    };
  } else {
    return {};
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/target.js


/**
 * Does the spell target creatures?
 * @param {*} data
 */
let doesTargetCreature = (data) => {
  const creature = /a creature you|creature( that)? you can see|interrupt a creature|would strike a creature|creature of your choice|creature or object within range|cause a creature|creature must be within range/gi;
  const creaturesRange = /(humanoid|monster|creature|target)(s)? (or loose object )?(of your choice )?(that )?(you can see )?within range/gi;
  return data.definition.description.match(creature) || data.definition.description.match(creaturesRange);
};

/**
 * Get Target Values
 * Uses regex magic to try and determine the number of creatures affected
 * @param {*} data
 */
let getTargetValues = (data) => {
  const numCreatures = /(?!At Higher Levels.*)(\w*) (falling )?(willing )?(creature|target|monster|celestial|fiend|fey|corpse(s)? of|humanoid)(?!.*you have animated)/gim;
  const targets = [...data.definition.description.matchAll(numCreatures)];
  const targetValues = targets
    .filter((target) => {
      const matches = dictionary/* default.numbers.filter */.Z.numbers.filter((n) => n.natural === target[1].toLowerCase());
      return Array.isArray(matches) && !!matches.length;
    })
    .map((target) => dictionary/* default.numbers.find */.Z.numbers.find((n) => n.natural === target[1].toLowerCase()).num);

  if (Array.isArray(targetValues) && !!targetValues.length) {
    return Math.max(...targetValues);
  } else {
    return null;
  }
};

/**
 * Spell targets
 */
// eslint-disable-next-line complexity
function getTarget(data) {
  const result = {
    value: null,
    units: null,
    type: null,
    width: null,
  };

  // if spell is an AOE effect get some details
  if (data.definition.range.aoeType && data.definition.range.aoeValue) {
    result.value = parseInt(data.definition.range.aoeValue);
    result.type = data.definition.range.aoeType.toLowerCase();
    result.units = "ft";
    return result;
  }

  // does the spell target a creature?
  const creatures = doesTargetCreature(data);

  if (creatures) {
    result.value = getTargetValues(data);
  }

  switch (data.definition.range.origin) {
    case "Touch":
      result.units = "touch";
      if (creatures) result.type = "creature";
      break;
    case "Self": {
      const dmgSpell = data.definition.modifiers.some((mod) => mod.type === "damage");
      result.type = (dmgSpell) ? "creature" : "self";
      break;
    }
    case "None":
      result.type = "none";
      break;
    case "Ranged":
      if (creatures) result.type = "creature";
      break;
    case "Feet":
      if (creatures) result.type = "creature";
      break;
    case "Miles":
      if (creatures) result.type = "creature";
      break;
    case "Sight":
    case "Special":
      result.units = "special";
      break;
    case "Any":
      result.units = "any";
      break;
    case undefined:
      result.type = null;
      break;
    // no default
  }

  // wall type spell?
  if (data.definition.name.includes("Wall")) {
    result.type = "wall";
    result.units = "ft";

    if (data.definition.description.includes("ten 10-foot-")) {
      result.value = 100;
    } else {
      const wallReg = new RegExp(/ (\d*) feet long/);
      const matches = data.definition.description.match(wallReg);
      if (matches) {
        result.value = parseInt(matches[1]);
      }
    }
    const thickReg = new RegExp(/ (\d*) foot (thick|wide)/);
    const thickMatch = data.definition.description.match(thickReg);
    if (thickMatch && thickMatch[1] > 5) {
      result.width = parseInt(thickMatch[1]);
    }
  }

  return result;
}

;// CONCATENATED MODULE: ./src/parser/spells/range.js
/** Spell range */
function getRange(data) {
  // else lets try and fill in some target details
  let value = data.definition.range.rangeValue ? data.definition.range.rangeValue : null;
  let units = "ft";
  let long = null;

  switch (data.definition.range.origin) {
    case "Touch":
      value = null;
      units = "touch";
      break;
    case "Self":
      value = null;
      units = "self";
      break;
    case "None":
      units = "none";
      break;
    case "Ranged":
      units = "ft";
      break;
    case "Feet":
      units = "ft";
      break;
    case "Miles":
      units = "ml";
      break;
    case "Sight":
    case "Special":
      units = "special";
      break;
    case "Any":
      units = "any";
      break;
    case undefined:
      units = null;
      break;
    // no default
  }

  return {
    value: value,
    long: long,
    units: units,
  };
}

;// CONCATENATED MODULE: ./src/parser/spells/action.js
function getActionType(data) {
  if (data.definition.requiresSavingThrow && !data.definition.requiresAttackRoll) {
    return "save";
  }

  if (
    data.definition.tags.includes("Damage") &&
    data.definition.range.rangeValue &&
    data.definition.range.rangeValue > 0
  ) {
    return "rsak";
  }

  if (data.definition.tags.includes("Damage")) {
    return "msak";
  }

  if (data.definition.tags.includes("Healing")) {
    return "heal";
  }

  if (data.definition.tags.includes("Buff")) {
    return "util";
  }

  return "other";
}

;// CONCATENATED MODULE: ./src/parser/spells/damage.js


let getAlternativeFormula = (data) => {
  // this might be specificially for Toll the Dead only, but it's better than nothing

  let description = data.definition.description;
  let match = description.match(/instead[\w\s]+(\d+d\d+) (\w+) damage/);
  if (match) {
    return match[1];
  } else {
    return "";
  }
};

function getDamage(data, spell) {
  let result = {
    parts: [],
    versatile: "",
  };

  const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
  const damageRestrictionHints = game.settings.get("ddb-importer", "add-damage-restrictions-to-hints");
  const hintOrRestriction = globalDamageHints || damageRestrictionHints;

  // damage
  const attacks = data.definition.modifiers.filter((mod) => mod.type === "damage");
  if (attacks.length !== 0) {
    const cantripBoost = data.definition.level === 0 && !!data.flags.ddbimporter.dndbeyond.cantripBoost;
    attacks.forEach((attack) => {
      const restriction = damageRestrictionHints && attack.restriction && attack.restriction !== "" ? attack.restriction : "";
      const hintAndRestriction = globalDamageHints && restriction !== "" ? " - " : "";
      const damageHint = globalDamageHints ? attack.subType : "";
      const damageTag = hintOrRestriction ? `[${damageHint}${hintAndRestriction}${restriction}]` : "";
      const addMod = attack.usePrimaryStat || cantripBoost ? " + @mod" : "";
      let diceString = src_utils/* default.parseDiceString */.Z.parseDiceString(attack.die.diceString, addMod, damageTag).diceString;
      result.parts.push([diceString, attack.subType]);
    });

    // This is probably just for Toll the dead.
    const alternativeFormula = getAlternativeFormula(data);
    result.versatile = cantripBoost ? `${alternativeFormula} + @mod` : alternativeFormula;
    return result;
  }

  // healing
  const heals = data.definition.modifiers.filter((mod) => mod.type === "bonus" && mod.subType === "hit-points");
  if (heals.length !== 0) {
    const healingBonus = (spell.flags.ddbimporter.dndbeyond.healingBoost) ? ` + ${spell.flags.ddbimporter.dndbeyond.healingBoost} + @item.level` : "";
    heals.forEach((heal) => {
      const restriction = damageRestrictionHints && heal.restriction && heal.restriction !== "" ? heal.restriction : "";
      const hintAndRestriction = globalDamageHints && restriction !== "" ? " - " : "";
      const damageHint = globalDamageHints ? "healing" : "";
      const damageTag = hintOrRestriction ? `[${damageHint}${hintAndRestriction}${restriction}]` : "";
      const healValue = (heal.die.diceString) ? `${heal.die.diceString}${damageTag}` : heal.die.fixedValue;
      const diceString = heal.usePrimaryStat
        ? `${healValue} + @mod${healingBonus}`
        : `${healValue}${healingBonus}`;
      result.parts.push([diceString, "healing"]);
    });
    return result;
  }
  return result;
}

;// CONCATENATED MODULE: ./src/parser/spells/save.js


function getSave(data) {
  if (data.definition.requiresSavingThrow && data.definition.saveDcAbilityId) {
    const saveAbility = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === data.definition.saveDcAbilityId)
      .value;
    if (data.overrideSaveDc) {
      return {
        ability: saveAbility,
        dc: data.overrideSaveDc,
        scaling: "flat",
      };
    } else {
      return {
        ability: saveAbility,
        dc: null,
        scaling: "spell",
      };
    }
  } else {
    return {
      ability: "",
      dc: null,
    };
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/scaling.js


/**
 * Get the scaling type for a spell mod
 * This is complex logic and is broken out to help simplify
 * @param {*} name
 * @param {*} mod
 */
let getScaleType = (name, data, mod) => {
  // scaleTypes:
  // SPELLSCALE - typical spells that scale
  // SPELLLEVEL - these spells have benefits that come in at particular levels e.g. bestow curse, hex. typically  duration changes
  // CHARACTERLEVEL - typical cantrip based levelling, some expections (eldritch blast)
  let scaleType = null;
  const modScaleType = mod.atHigherLevels.scaleType ? mod.atHigherLevels.scaleType : data.definition.scaleType;
  const isHigherLevelDefinitions =
    mod.atHigherLevels.higherLevelDefinitions &&
    Array.isArray(mod.atHigherLevels.higherLevelDefinitions) &&
    mod.atHigherLevels.higherLevelDefinitions.length >= 1;

  if (isHigherLevelDefinitions && modScaleType === "spellscale") {
    const definition = mod.atHigherLevels.higherLevelDefinitions[0];
    if (definition) {
      scaleType = modScaleType;
    } else {
      src_logger/* default.warn */.Z.warn("No spell definition found for " + name);
    }
  } else if (modScaleType === "spellscale") {
    // lets handle cases where there is a spellscale type but no damage
    // increase/ higherleveldefinitins e.g. chain lighting
    // these type of spells typically increase targets so we set the
    // scaling to null as we don't want to increase damage when upcast.
    // this also deals with cases like Ice Knife where the upscale damage
    // is in one of the two mods provided.
    // we are capturing this else because we don't want to trigger
    // an update to scaleType or a warning.
  } else if (modScaleType === "characterlevel") {
    // lets handle odd cantrips like Eldritch Blast
    // (in fact this might be the only case)
    if (mod.atHigherLevels.higherLevelDefinitions.length === 0) {
      // if this array is empty it does not contain levelling information
      // the only case found is Eldritch Blast.
      // this does have some info around multiple beams in
      // data.atHigherLevels but we ignore this. we will set the scaling
      // to null as each beam is best modelled by "casting" the cantrip again/
      // pressing the attack/damage buttons in FVTT
      scaleType = null;
    } else {
      scaleType = modScaleType;
    }
  } else if (modScaleType === "spelllevel") {
    // spells that have particular level associated benefits
    // these seem to be duration increases or target increases for
    // the most part we can't handle these in FVTT right now (we could
    // in theory create a new spell at a higher level).
    // some duration upcasting (like bestow curse) affects concentration
    // for now we will do nothing with these spells.
    // examples include: hex, shadowblade, magic weapon, bestow curse
    scaleType = modScaleType;
  } else {
    src_logger/* default.warn */.Z.warn(`${name} parse failed: `, modScaleType);
    scaleType = modScaleType; // if this is new/unknow will use default
  }

  return scaleType;
};

function getSpellScaling(data) {
  let baseDamage = "";
  let scaleDamage = "";
  let scaleType = null; // defaults to null, so will be picked up as a None scaling spell.

  // spell scaling
  if (data.definition.canCastAtHigherLevel) {
    // iterate over each spell modifier
    data.definition.modifiers
      .filter((mod) => mod.type === "damage" || (mod.type === "bonus" && mod.subType === "hit-points"))
      // eslint-disable-next-line complexity
      .forEach((mod) => {
        // if the modifier has a die for damage, lets use the string or fixed value
        // for the base damage
        if (mod && mod.die) {
          if (mod.die.diceString !== null) {
            baseDamage = mod.die.diceString;
          }

          if (mod.die.fixedValue !== null && baseDamage === "") {
            baseDamage = mod.die.fixedValue;
          }
        }

        // defines some details about higher level casting
        if (mod.atHigherLevels) {
          // scaleTypes:
          // SPELLSCALE - typical spells that scale
          // SPELLLEVEL - these spells have benefits that come in at particular levels e.g. bestow curse, hex. typically  duration changes
          // CHARACTERLEVEL - typical cantrip based levelling, some expections (eldritch blast)

          // mod.atHigherLevels.higherLevelDefinitions contains info about the
          // spells damage die at higher levels, but we can't use this for cantrips as
          // FVTT use a formula to work out the scaling (ddb has a fixed value structure)
          const isHigherLevelDefinitions =
            mod.atHigherLevels.higherLevelDefinitions &&
            Array.isArray(mod.atHigherLevels.higherLevelDefinitions) &&
            mod.atHigherLevels.higherLevelDefinitions.length >= 1;

          // lets handle normal spell leveling first
          const modScaleType = mod.atHigherLevels.scaleType ? mod.atHigherLevels.scaleType : data.definition.scaleType;
          if (isHigherLevelDefinitions && modScaleType === "spellscale") {
            const definition = mod.atHigherLevels.higherLevelDefinitions[0];
            if (definition) {
              const modScaleDamage =
                definition.dice && definition.dice.diceString // if dice string
                  ? definition.dice.diceString // use dice string
                  : definition.dice && definition.dice.fixedValue // else if fixed value
                    ? definition.dice.fixedValue // use fixed value
                    : definition.value; // else use value

              // some spells have multiple scaling damage (e.g. Wall of Ice,
              // Glyph of warding, Acid Arrow, Arcane Hand, Dragon's Breath,
              // Chromatic Orb, Absorb Elements, Storm Sphere, Spirit Guardians)
              // it's hard to model most of these in FVTT, and for some it makes
              // no difference. so...
              // lets optimistically use the highest
              // assumptions: these are going to be dice strings, and we don't care
              // about dice value, just number of dice
              const diceFormula = /(\d*)d\d*/;
              const existingMatch = diceFormula.exec(scaleDamage);
              const modMatch = diceFormula.exec(modScaleDamage);

              if (!existingMatch || modMatch[1] > existingMatch[1]) {
                scaleDamage = modScaleDamage;
              }
            } else {
              src_logger/* default.warn */.Z.warn("No definition found for " + data.definition.name);
            }
          } else if (isHigherLevelDefinitions && modScaleType === "characterlevel") {
            // cantrip support, important to set to a fixed vaue if using abilities like potent spellcasting
            scaleDamage = baseDamage;
          }

          scaleType = getScaleType(data.definition.name, data, mod);
        }
      });
  }

  switch (scaleType) {
    case "characterlevel":
      return {
        mode: "cantrip",
        formula: scaleDamage,
      };
    case "spellscale":
      return {
        mode: "level",
        formula: scaleDamage,
      };
    case "spelllevel":
    case null:
      return {
        mode: "none",
        formula: "",
      };
    default:
      return {
        mode: "level",
        formula: "",
      };
  }
}

// EXTERNAL MODULE: ./src/muncher/table.js + 2 modules
var table = __webpack_require__(967);
;// CONCATENATED MODULE: ./src/parser/spells/parseSpell.js



// Import parsing functions













function parseSpell(data, character) {
  let spell = {
    type: "spell",
    data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("spell")),
    name: data.definition.name.replace(/â€™/g, "'"),
    flags: {
      ddbimporter: {
        id: data.id,
        definitionId: data.definition.id,
        entityTypeId: data.entityTypeId,
        dndbeyond: data.flags.ddbimporter.dndbeyond,
        originalName: data.name,
        sources: data.definition.sources,
        tags: data.definition.tags,
      },
    },
  };

  // spell level
  spell.data.level = data.definition.level;

  // get the spell school
  const school = dictionary/* default.spell.schools.find */.Z.spell.schools.find((s) => s.name === data.definition.school.toLowerCase());
  spell.data.school = (school) ? school.id : null;


  /**
   * Gets the necessary spell components VSM + material
   */
  spell.data.components = getComponents(data);

  spell.data.materials = getMaterials(data);

  spell.data.preparation = getSpellPreparationMode(data);

  const updateExisting = data.flags.ddbimporter.generic
    ? game.settings.get("ddb-importer", "munching-policy-update-existing")
    : false;
  data.definition.description = (0,table/* generateTable */.p)(spell.name, data.definition.description, updateExisting);

  spell.data.description = {
    value: data.definition.description,
    chat: data.definition.description,
    unidentified: data.definition.type,
  };

  spell.data.source = src_utils/* default.parseSource */.Z.parseSource(data.definition);

  spell.data.activation = getActivation(data);

  spell.data.duration = getDuration(data);

  spell.data.target = getTarget(data);

  spell.data.range = getRange(data);

  spell.data.actionType = getActionType(data);

  spell.data.damage = getDamage(data, spell);

  spell.data.save = getSave(data);

  spell.data.scaling = getSpellScaling(data);

  spell.data.uses = getUses(data);

  // attach the spell ability id to the spell data so VTT always uses the
  // correct one, useful if multi-classing and spells have different
  // casting abilities
  if (character && character.data.attributes.spellcasting !== data.flags.ddbimporter.dndbeyond.ability) {
    spell.data.ability = data.flags.ddbimporter.dndbeyond.ability;
    if (spell.data.save.scaling == "spell") {
      spell.data.save.scaling = data.flags.ddbimporter.dndbeyond.ability;
    }
  }

  // If using better rolls we set alt to be versatile for spells like
  // Toll The Dead
  spell.flags.betterRolls5e = {
    quickVersatile: {
      altValue: true,
    },
    quickCharges: {
      value: {
        use: true,
        resource: true
      },
      altValue: {
        use: true,
        resource: true
      }
    },
  };

  return spell;
}

;// CONCATENATED MODULE: ./src/parser/spells/getGenericSpells.js
// Import parsing functions



function getSpells(spells) {
  let items = [];

  spells.filter((spell) => {
    // remove archived material
    if (spell.definition.sources && spell.definition.sources.some((source) => source.sourceId === 39)) {
      return false;
    } else {
      return true;
    }
  })
  .forEach((spell) => {
    if (!spell.definition) return;

    spell.flags = {
      ddbimporter: {
        generic: true,
        dndbeyond: {
          lookup: "generic",
          lookupName: "generic",
          level: spell.castAtLevel,
          castAtLevel: spell.castAtLevel,
        },
      },
    };

    items.push(parseSpell(spell, null));
  });

  if (items) fixSpells(null, items);

  return items;
}

;// CONCATENATED MODULE: ./src/lib/Secrets.js


function isJSON(str) {
  try {
      return (JSON.parse(str) && !!str && str !== null);
  } catch (e) {
      return false;
  }
}

function isLocalCobalt(keyPostfix) {
  return keyPostfix && keyPostfix !== "" && localStorage.getItem(`ddb-cobalt-cookie-${keyPostfix}`) !== null;
}

function getCobalt(keyPostfix = "") {
  let cobalt;
  const localCookie = game.settings.get("ddb-importer", "cobalt-cookie-local");
  const characterCookie = isLocalCobalt(keyPostfix);

  src_logger/* default.debug */.Z.debug(`Getting Cookie: Key postfix? "${keyPostfix}" -  Local? ${localCookie} - Character? ${characterCookie}`);
  if (characterCookie) {
    cobalt = localStorage.getItem(`ddb-cobalt-cookie-${keyPostfix}`);
  } else if (localCookie) {
    cobalt = localStorage.getItem("ddb-cobalt-cookie");
  } else {
    cobalt = game.settings.get("ddb-importer", "cobalt-cookie");
  }

  return cobalt;
}

async function setCobalt(value, keyPostfix = "") {
  const localCookie = game.settings.get("ddb-importer", "cobalt-cookie-local");
  const characterCookie = keyPostfix && keyPostfix !== "";

  let cobaltValue = value;
  if (isJSON(value)) {
    cobaltValue = JSON.parse(value).cbt;
  }

  src_logger/* default.debug */.Z.debug(`Setting Cookie: Key postfix? "${keyPostfix}" -  Local? ${localCookie} - Character? ${characterCookie}`);
  if (characterCookie) {
    localStorage.setItem(`ddb-cobalt-cookie-${keyPostfix}`, cobaltValue);
  } else if (localCookie) {
    localStorage.setItem("ddb-cobalt-cookie", cobaltValue);
  } else {
    await game.settings.set("ddb-importer", "cobalt-cookie", cobaltValue);
  }
}

function deleteLocalCobalt(keyPostfix) {
  const localCookie = isLocalCobalt(keyPostfix);

  if (localCookie) {
    localStorage.removeItem(`ddb-cobalt-cookie-${keyPostfix}`);
  }
}

async function moveCobaltToLocal() {
  localStorage.setItem('ddb-cobalt-cookie', game.settings.get("ddb-importer", "cobalt-cookie"));
  await game.settings.set("ddb-importer", "cobalt-cookie", "");
  game.settings.set("ddb-importer", "cobalt-cookie-local", true);
}

async function moveCobaltToSettings() {
  game.settings.set("ddb-importer", "cobalt-cookie", localStorage.getItem('ddb-cobalt-cookie'));
  game.settings.set("ddb-importer", "cobalt-cookie-local", false);
}

async function checkCobalt(keyPostfix = "", alternativeKey = null) {
  const cobaltCookie = alternativeKey ? alternativeKey : getCobalt(keyPostfix);
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const body = { cobalt: cobaltCookie, betaKey: betaKey };

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/auth`, {
      method: "POST",
      cache: "no-cache",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => resolve(data))
      .catch((error) => {
        src_logger/* default.error */.Z.error(`Cobalt cookie check error`);
        src_logger/* default.error */.Z.error(error);
        src_logger/* default.error */.Z.error(error.stack);
        reject(error);
      });
  });
}

// EXTERNAL MODULE: ./src/muncher/compendiumFolders.js
var compendiumFolders = __webpack_require__(269);
;// CONCATENATED MODULE: ./src/muncher/spells.js
// Main module class








function getSpellData(className, sourceFilter) {
  const cobaltCookie = getCobalt();
  const campaignId = (0,utils/* getCampaignId */.F9)();
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey, className: className };
  const debugJson = game.settings.get("ddb-importer", "debug-json");
  const sources = game.settings.get("ddb-importer", "munching-policy-monster-sources").flat();

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/class/spells`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          (0,utils/* download */.LR)(JSON.stringify(data), `spells-raw.json`, "application/json");
        }
        if (!data.success) {
          (0,utils/* munchNote */.ep)(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => {
        if (sources.length == 0 || !sourceFilter) return data.data;
        return data.data.filter((spell) =>
          spell.definition.sources.some((source) => sources.includes(source.sourceId))
        );
      })
      .then((data) => resolve(data))
      .catch((error) => {
        src_logger/* default.warn */.Z.warn(error);
        reject(error);
      });
    });
}

async function parseSpells(ids = null) {
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");
  const uploadDirectory = game.settings.get("ddb-importer", "other-image-upload-directory").replace(/^\/|\/$/g, "");

  // to speed up file checking we pregenerate existing files now.
  await src_utils/* default.generateCurrentFiles */.Z.generateCurrentFiles(uploadDirectory);

  const addToCompendiumFolder = game.settings.get("ddb-importer", "munching-policy-use-compendium-folders");
  const compendiumFoldersInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("compendium-folders");
  if (addToCompendiumFolder && compendiumFoldersInstalled) {
    (0,utils/* munchNote */.ep)(`Checking compendium folders..`, true);
    await (0,compendiumFolders/* createCompendiumFolderStructure */.FT)("spells");
  }

  // disable source filter if ids provided
  const sourceFilter = !(ids !== null && ids.length > 0);
  const results = await Promise.allSettled([
    getSpellData("Cleric", sourceFilter),
    getSpellData("Druid", sourceFilter),
    getSpellData("Sorcerer", sourceFilter),
    getSpellData("Warlock", sourceFilter),
    getSpellData("Wizard", sourceFilter),
    getSpellData("Paladin", sourceFilter),
    getSpellData("Ranger", sourceFilter),
    getSpellData("Bard", sourceFilter),
    getSpellData("Graviturgy", sourceFilter),
    getSpellData("Chronurgy", sourceFilter),
    getSpellData("Artificer", sourceFilter),
  ]);

  // replace smart quotes and filter out duplicates
  const filteredResults = results
    .filter((r) => r.status === "fulfilled")
    .map((r) => r.value).flat().flat();

  const rawSpells = getSpells(filteredResults);

  const spells = rawSpells
    .filter((spell) => spell?.name)
    .map((spell) => {
      spell.name = spell.name.replace(/â€™/g, "'");
      return spell;
    });

  if (results.some((r) => r.status === "rejected")) {
    (0,utils/* munchNote */.ep)("Some spell parsing failed to parse, see developer console for details.");
    src_logger/* default.error */.Z.error("Failed spell parsing", results);
  }

  let uniqueSpells = spells.filter((v, i, a) => a.findIndex((t) => t.name === v.name) === i);
  const srdSpells = await (0,muncher_import/* srdFiddling */.cC)(uniqueSpells, "spells");
  const filteredSpells = (ids !== null && ids.length > 0)
    ? srdSpells.filter((s) => s.flags?.ddbimporter?.definitionId && ids.includes(String(s.flags.ddbimporter.definitionId)))
    : srdSpells;
  const finalSpells = await (0,muncher_import/* daeFiddling */.xh)(filteredSpells);

  const finalCount = finalSpells.length;
  (0,utils/* munchNote */.ep)(`Importing ${finalCount} spells...`, true);

  return new Promise((resolve) => {
    resolve((0,muncher_import/* updateCompendium */.X)("spells", { spells: finalSpells }, updateBool));
  });
}



;// CONCATENATED MODULE: ./src/parser/inventory/common.js




function getItemRarity(data) {
  const rarityDropdown = src_utils/* default.versionCompare */.Z.versionCompare(game.data.system.data.version, "1.4.2") >= 0;
  const rarity = data.definition.rarity
    ? rarityDropdown
      ? data.definition.rarity.toLowerCase()
      : data.definition.rarity
    : "";
  return rarity;
}

/**
 * Checks if the character can attune to an item and if yes, if he is attuned to it.
 */
function getAttuned(data) {
  if (data.definition.canAttune !== undefined && data.definition.canAttune === true) {
    return data.isAttuned;
  } else {
    return false;
  }
}

/**
 * Checks if the character can equip an item and if yes, if he is has it currently equipped.
 */
function getEquipped(data) {
  if (data.definition.canEquip !== undefined && data.definition.canEquip === true) {
    return data.equipped;
  } else {
    return false;
  }
}


/**
 * Gets Limited uses information, if any
 * uses: { value: 0, max: 0, per: null }
 */
 function common_getUses(data) {
  if (data.limitedUse !== undefined && data.limitedUse !== null) {
    let resetType = dictionary/* default.resets.find */.Z.resets.find((reset) => reset.id == data.limitedUse.resetType);
    return {
      max: data.limitedUse.maxUses,
      value: data.limitedUse.numberUsed
        ? data.limitedUse.maxUses - data.limitedUse.numberUsed
        : data.limitedUse.maxUses,
      per: resetType ? resetType.value : "",
      description: data.limitedUse.resetTypeDescription,
    };
  } else {
    return { value: 0, max: 0, per: null };
  }
}

function getConsumableUses(data) {
  if (data.limitedUse) {
    let uses = common_getUses(data);
    if (uses.per === "") uses.per = "charges";
    uses.autoUse = false;
    uses.autoDestroy = true;
    return uses;
  } else {
    // default
    return { value: 1, max: 1, per: "charges", autoUse: false, autoDestroy: true };
  }
}

/**
 * Checks the proficiency of the character with this specific weapon
 * @param {obj} data Item data
 * @param {string} weaponType The DND5E weaponType
 * @param {array} proficiencies The character's proficiencies as an array of `{ name: 'PROFICIENCYNAME' }` objects
 */
function getWeaponProficient(data, weaponType, proficiencies) {
  // if it's a simple weapon and the character is proficient in simple weapons:
  if (
    proficiencies.find((proficiency) => proficiency.name === "Simple Weapons") &&
    weaponType.indexOf("simple") !== -1
  ) {
    return true;
  } else if (
    proficiencies.find((proficiency) => proficiency.name === "Martial Weapons") &&
    weaponType.indexOf("martial") !== -1
  ) {
    return true;
  } else {
    return proficiencies.find((proficiency) => proficiency.name === data.definition.type) !== undefined;
  }
};

/**
 * Searches for a magical attack bonus granted by this weapon
 * @param {obj} data item data
 */
function getMagicalBonus(data) {
  let boni = data.definition.grantedModifiers.filter(
    (mod) => mod.type === "bonus" && mod.subType === "magic" && mod.value && mod.value !== 0
  );
  let bonus = boni.reduce((prev, cur) => prev + cur.value, 0);
  return bonus;
}

function getAttunement(item) {
  if (item.isAttuned) {
    return 2;
  } else if (item.definition.canAttune) {
    return 1;
  } else {
    return 0;
  }
}

;// CONCATENATED MODULE: ./src/parser/inventory/weapon.js




/**
 * Gets the DND5E weapontype (simpleM, martialR etc.) as string
 * Supported Types only: Simple/Martial Melee/Ranged and Ammunition (Firearms in D&DBeyond)
 * @param {obj} data item data
 */
function getWeaponType(data) {
  const type = dictionary/* default.weapon.weaponType.find */.Z.weapon.weaponType.find(
    (type) => type.categoryId === data.definition.categoryId
  );
  const range = dictionary/* default.weapon.weaponRange.find */.Z.weapon.weaponRange.find(
    (type) => type.attackType === data.definition.attackType
  );

  if (type && range) {
    return `${type.value}${range.value}`;
  } else {
    return "simpleM";
  }
}

/**
 * Gets the weapons's properties (Finesse, Reach, Heavy etc.)
 * @param {obj} data Item data
 */
function getProperties(data) {
  let result = {};
  dictionary/* default.weapon.properties.forEach */.Z.weapon.properties.forEach((property) => {
    if (data.definition.properties && Array.isArray(data.definition.properties)) {
      result[property.value] = data.definition.properties.some((prop) => prop.name === property.name);
    }
    if (
      !result[property.value] &&
      data.definition.grantedModifiers &&
      Array.isArray(data.definition.grantedModifiers)
    ) {
      result[property.value] = data.definition.grantedModifiers.some(
        (prop) => prop.type === "weapon-property" && prop.friendlySubtypeName === property.name
      );
    }
  });
  return result;
}

/**
 * Gets the range(s) of a given weapon
 */
function weapon_getRange(data, weaponProperties) {
  // range: { value: null, long: null, units: '' },
  // sometimes reach weapons have their range set as 5. it's not clear why.
  const shortRange = data.definition.range ? data.definition.range : 5;
  const reach = weaponProperties.rch && data.definition.range == 5 ? 5 : 0;
  return {
    value: shortRange + reach,
    long: (data.definition.longRange && data.definition.longRange != data.definition.range)
      ? data.definition.longRange + reach
      : "",
    units: "ft",
  };
};

/**
 * Gets the ability which the to hit modifier is baed on
 * Melee: STR
 * Ranged: DEX
 * Finesse: STR || DEX
 * Thrown: STR, unless Finesse, then STR || DEX
 * @param {obj} data item data
 * @param {obj} weaponProperties weapon properties
 * @param {obj} weaponRange weapon range information
 * @param {obj} abilities character abilities (scores)
 */
function getAbility(weaponProperties, weaponRange, abilities) {
  // finesse weapons can choose freely, so we choose the higher one
  if (weaponProperties.fin) {
    return abilities.str?.value > abilities.dex?.value ? "str" : "dex";
  }

  // thrown, but not finesse weapon: STR
  if (weaponProperties.thr) {
    return "str";
  }

  // if it's a ranged weapon, and not a reach weapon (long = 10 (?))
  if (weaponRange.long > 5 && !weaponProperties.rch) {
    return "dex";
  }
  // the default is STR
  return "str";
}

/**
 * Searches for a magical attack bonus granted by this weapon
 * @param {obj} data item data
 * @param {obj} flags
 */
function getWeaponMagicalBonus(data, flags) {
  const bonus = getMagicalBonus(data);
  if (flags.classFeatures.includes("Improved Pact Weapon") && bonus === 0) {
    return 1;
  } else {
    return bonus;
  }
};

function getDamageType(data) {
  if (data.definition.damageType) {
    const damageTypeReplace = data.definition.grantedModifiers.find((mod) =>
      mod.type === "replace-damage-type" &&
      (!mod.restriction || mod.restriction === "")
    );

    const damageType = (damageTypeReplace)
      ? damageTypeReplace.subType.toLowerCase()
      : data.definition.damageType.toLowerCase();
    return damageType;
  } else {
    return undefined;
  }
}

/**
 *
 * @param {obj} data item data
 * @param {obj} flags
 * /* damage: { parts: [], versatile: '' }, * /
 */
function weapon_getDamage(data, flags, betterRolls5e) {
  const magicalDamageBonus = getWeaponMagicalBonus(data, flags);
  // we can safely make these assumptions about GWF and Dueling because the
  // flags are only added for melee attacks
  const greatWeaponFighting = flags.classFeatures.includes("greatWeaponFighting") ? "r<=2" : "";
  const dueling = flags.classFeatures.includes("Dueling") ? " + 2" : "";
  const offHand = flags.classFeatures.includes("OffHand");
  const twoWeapon = flags.classFeatures.includes("Two-Weapon Fighting");
  const twoHanded = data.definition.properties.find((property) => property.name === "Two-Handed");
  const mod = (offHand && !twoWeapon) ? "" : " + @mod";
  const damageType = getDamageType(data);

  const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
  const damageRestrictionHints = game.settings.get("ddb-importer", "add-damage-restrictions-to-hints");
  const hintOrRestriction = globalDamageHints || damageRestrictionHints;

  const damageHint = damageType && globalDamageHints ? damageType : "";
  const damageTag = hintOrRestriction ? `[${damageHint}]` : "";

  const versatile = data.definition.properties
    .filter((property) => property.name === "Versatile")
    .map((versatile) => {
      if (versatile && versatile.notes) {
        return (
          src_utils/* default.parseDiceString */.Z.parseDiceString(versatile.notes + ` + ${magicalDamageBonus}`, null, damageTag, greatWeaponFighting).diceString + mod
        );
      } else {
        return "";
      }
    })[0];

  let chatFlavor = "";
  let parts = [];
  let otherFormula = "";

  // first damage part
  // blowguns and other weapons rely on ammunition that provides the damage parts
  if (data.definition.damage && data.definition.damage.diceString && damageType) {
    // if we have greatweapon fighting style and this is two handed, add the roll tweak
    // else if we have duelling we add the bonus here (assumption- if you have dueling
    // you're going to use it! (DDB also makes this assumption))
    const fightingStyleDiceMod = twoHanded ? greatWeaponFighting : "";

    // if we are a martial artist and the weapon is eligable we may need to use a bigger dice type.
    // this martial arts die info is addedd to the weapon flags before parse weapon is called
    const martialArtsDie = flags.martialArtsDie;
    let diceString = data.definition.damage.diceString;

    if (martialArtsDie.diceValue && data.definition.damage.diceValue && martialArtsDie.diceValue > data.definition.damage.diceValue) {
      diceString = martialArtsDie.diceString;
    }

    // if there is a magical damage bonus, it probably should only be included into the first damage part.
    parts.push([
      src_utils/* default.parseDiceString */.Z.parseDiceString(diceString + ` + ${magicalDamageBonus}`, `${mod}${dueling}`, damageTag, fightingStyleDiceMod)
        .diceString,
        damageType,
    ]);
  }

  // additional damage parts with no restrictions
  data.definition.grantedModifiers
    .filter((mod) => mod.type === "damage" && (!mod.restriction || mod.restriction === ""))
    .forEach((mod) => {
      const damagePart = (mod.dice) ? mod.dice.diceString : mod.value;
      if (damagePart) {
        const damageHintSub = mod.subType && globalDamageHints ? `[${mod.subType}]` : "";
        const damageParsed = src_utils/* default.parseDiceString */.Z.parseDiceString(damagePart, "", damageHintSub).diceString;
        parts.push([`${damageParsed}`, mod.subType]);
      }
    });

  // loop over restricted damage types
  // we do this so we can either break this out for midi users
  data.definition.grantedModifiers
    .filter((mod) => mod.type === "damage" && mod.restriction && mod.restriction !== "")
    .forEach((mod) => {
      const damagePart = (mod.dice) ? mod.dice.diceString : `${mod.value}`;
      if (damagePart) {
        const subType = mod.subType && globalDamageHints ? mod.subType : "";
        const hintAndRestriction = globalDamageHints && mod.restriction !== "" ? " - " : "";
        const subTypeDamageTag = hintOrRestriction ? `[${subType}${hintAndRestriction}${mod.restriction}]` : "";
        const damageParsed = src_utils/* default.parseDiceString */.Z.parseDiceString(damagePart, "", subTypeDamageTag).diceString;

        if (src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("betterrolls5e")) {
          const attackNum = parts.length;
          betterRolls5e.quickDamage.context[attackNum] = mod.restriction;
          parts.push([`${damageParsed}`, mod.subType]);
        } else {
          // if (utils.isModuleInstalledAndActive("midi-qol")) {
          parts.forEach((part) => {
            otherFormula += (otherFormula === "") ? part[0] : ` + ${part[0]}`;
          });
          otherFormula += ` + ${damageParsed}`;
          chatFlavor = `Use Other damage ${mod.restriction}`;
        }
      }
    });

  // add damage modifiers from other sources like improved divine smite
  if (flags.damage.parts) {
    flags.damage.parts.forEach((part) => {
      parts.push(part);
    });
  }

  const result = {
    parts: parts,
    versatile: versatile,
  };

  return [result, betterRolls5e, otherFormula, chatFlavor];
}

function weapon_getActionType(data) {
  if (data.definition.attackType === 1) {
    return "mwak";
  } else {
    return "rwak";
  }
}

function parseWeapon(data, character, flags) {
  let weapon = {
    name: data.definition.name,
    type: "weapon",
    data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("weapon")),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: data.definition.type,
          damage: flags.damage,
          classFeatures: flags.classFeatures,
        },
      },
    },
  };

  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;
  const characterProficiencies = character.flags.ddbimporter.dndbeyond.proficienciesIncludingEffects;

    // if using better rolls lets add some useful QOL information.
  // marks context as magical attack and makes alt click a versatile damage click
  weapon.flags.betterRolls5e = {
    quickDamage: {
      context: {
        "0": getWeaponMagicalBonus(data, flags) > 0 ? "Magical" : "",
      },
      value: {
        "0": true,
      },
      altValue: {
        "0": true,
      },
    },
    quickVersatile: {
      altValue: true,
    },
    quickCharges: {
      value: {
        use: false,
        resource: true
      },
      altValue: {
        use: false,
        resource: true
      }
    },
  };

  weapon.data.weaponType = getWeaponType(data);
  weapon.data.properties = getProperties(data);

  const proficientFeatures = ["pactWeapon", "kensaiWeapon"];
  if (flags.classFeatures.some((feat) => proficientFeatures.includes(feat))) {
    weapon.data.proficient = true;
  } else {
    weapon.data.proficient = getWeaponProficient(data, weapon.data.weaponType, characterProficiencies);
  }

  weapon.data.description = {
    value: data.definition.description,
    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,
    unidentified: data.definition.type,
  };
  weapon.data.source = src_utils/* default.parseSource */.Z.parseSource(data.definition);
  weapon.data.quantity = data.quantity ? data.quantity : 1;
  const bundleSize = data.definition.bundleSize ? data.definition.bundleSize : 1;
  const totalWeight = data.definition.weight ? data.definition.weight : 0;
  weapon.data.weight = totalWeight / bundleSize;
  weapon.data.equipped = getEquipped(data);
  weapon.data.rarity = getItemRarity(data);
  weapon.data.identified = true;
  weapon.data.activation = { type: "action", cost: 1, condition: "" };
  if (flags.classFeatures.includes("OffHand")) weapon.data.activation.type = "bonus";

  weapon.data.range = weapon_getRange(data, weapon.data.properties);
  weapon.data.uses = common_getUses(data);
  weapon.data.ability = getAbility(weapon.data.properties, weapon.data.range, characterAbilities);
  // warlocks can use cha for their Hex weapon
  if (flags.classFeatures.includes("hexWarrior")) {
    if (characterAbilities.cha.value >= characterAbilities[weapon.data.ability].value) {
      weapon.data.ability = "cha";
    }
  }
  // kensai monks
  if (flags.classFeatures.includes("kensaiWeapon") || flags.classFeatures.includes("monkWeapon")) {
    if (characterAbilities.dex.value >= characterAbilities[weapon.data.ability].value) {
      weapon.data.ability = "dex";
    }
  }
  if (flags.magicItemAttackInt && (data.definition.magic || weapon.data.properties.mgc)) {
    if (characterAbilities.int.value > characterAbilities[weapon.data.ability].value) {
      weapon.data.ability = "int";
    }
  }

  weapon.data.actionType = weapon_getActionType(data);
  weapon.data.attackBonus = getWeaponMagicalBonus(data, flags);

  [
    weapon.data.damage,
    weapon.flags.betterRolls5e,
    weapon.data.formula,
    weapon.data.chatFlavor
  ] = weapon_getDamage(data, flags, weapon.flags.betterRolls5e);


  return weapon;
}

;// CONCATENATED MODULE: ./src/parser/inventory/ammunition.js



/**
 * Gets the range(s) of a given weapon
 */
function ammunition_getRange(data) {
  // range: { value: null, long: null, units: '' },
  return {
    value: data.definition.range ? data.definition.range : null,
    long: data.definition.longRange ? data.definition.longRange : null,
    units: (data.definition.range || data.definition.range) ? "ft." : "",
  };
}

/**
 *
 * @param {obj} data item data
 * @param {obj} weaponProperties weapon properties
 * /* damage: { parts: [], versatile: '' }, * /
 */
let ammunition_getDamage = (data, magicalDamageBonus) => {
  let parts = [];

  // first damage part
  // blowguns and other weapons rely on ammunition that provides the damage parts
  if (data.definition.damage && data.definition.damage.diceString && data.definition.damageType) {
    // if there is a magical damage bonus, it probably should only be included into the first damage part.
    parts.push([
      src_utils/* default.parseDiceString */.Z.parseDiceString(data.definition.damage.diceString + `+${magicalDamageBonus}`).diceString,
      data.definition.damageType.toLowerCase(),
    ]);
  }

  // additional damage parts
  // Note: For the time being, restricted additional bonus parts are not included in the damage
  //       The Saving Throw Freature within Foundry is not fully implemented yet, to this will/might change
  data.definition.grantedModifiers
    .filter((mod) => mod.type === "damage" && mod.restriction && mod.restriction.length === 0)
    .forEach((mod) => {
      if (mod.dice) {
        parts.push([mod.dice.diceString, mod.subType]);
      } else if (mod.value) {
        parts.push([mod.value, mod.subType]);
      }
    });

  let result = {
    // label: utils.parseDiceString(parts.map(part => part[0]).join(' + ')).diceString,
    parts: parts,
    versatile: "",
  };

  return result;
};

function parseAmmunition(data, itemType) {
  /**
   * MAIN parseWeapon
   */
  let template = JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("consumable"));
  let ammunition = {
    name: data.definition.name,
    type: "consumable",
    data: template,
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: itemType,
        },
      },
    },
  };

  ammunition.data.description = {
    value: data.definition.description,
    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,
    unidentified: data.definition.type,
  };
  ammunition.data.source = src_utils/* default.parseSource */.Z.parseSource(data.definition);
  ammunition.data.properties = {};
  ammunition.data.quantity = data.quantity ? data.quantity : 1;

  const bundleSize = data.definition.bundleSize ? data.definition.bundleSize : 1;
  const totalWeight = data.definition.weight ? data.definition.weight : 0;
  ammunition.data.weight = (totalWeight / bundleSize) * (ammunition.data.quantity / bundleSize);
  ammunition.data.equipped = getEquipped(data);
  ammunition.data.rarity = getItemRarity(data);
  ammunition.data.identified = true;
  ammunition.data.activation = { type: "action", cost: 1, condition: "" };
  ammunition.data.range = ammunition_getRange(data);
  ammunition.data.ability = "";
  ammunition.data.actionType = "rwak";
  ammunition.data.attackBonus = getMagicalBonus(data);
  ammunition.data.damage = ammunition_getDamage(data, getMagicalBonus(data));
  ammunition.data.consumableType = "ammo";

  return ammunition;
}

;// CONCATENATED MODULE: ./src/parser/inventory/staves.js




/**
 * Gets the DND5E weapontype (simpleM, martialR etc.) as string
 * Supported Types only: Simple/Martial Melee/Ranged and Ammunition (Firearms in D&DBeyond)
 * @param {obj} data item data
 */
function staves_getWeaponType(data) {
  const weaponBehavior = data.definition.weaponBehaviors[0];
  const type = dictionary/* default.weapon.weaponType.find */.Z.weapon.weaponType.find((type) => type.categoryId === weaponBehavior.categoryId);
  const range = dictionary/* default.weapon.weaponRange.find */.Z.weapon.weaponRange.find((type) => type.attackType === weaponBehavior.attackType);

  if (type && range) {
    return `${type.value}${range.value}`;
  } else {
    return "simpleM";
  }
}

/**
 * Gets the weapons's properties (Finesse, Reach, Heavy etc.)
 * @param {obj} data Item data
 */
function staves_getProperties(data) {
  let weaponBehavior = data.definition.weaponBehaviors[0];
  let result = {};
  dictionary/* default.weapon.properties.forEach */.Z.weapon.properties.forEach((property) => {
    if (weaponBehavior.properties && Array.isArray(weaponBehavior.properties)) {
      result[property.value] = weaponBehavior.properties.find((prop) => prop.name === property.name) !== undefined;
    }
  });
  return result;
}


/**
 * Gets the range(s) of a given weapon
 */
function staves_getRange(data) {
  // range: { value: null, long: null, units: '' },
  let weaponBehavior = data.definition.weaponBehaviors[0];
  return {
    value: weaponBehavior.range ? weaponBehavior.range : 5,
    long: weaponBehavior.longRange ? weaponBehavior.longRange : 5,
    units: "ft.",
  };
}

/**
 * Gets the ability which the to hit modifier is baed on
 * Melee: STR
 * Ranged: DEX
 * Finesse: STR || DEX
 * Thrown: STR, unless Finesse, then STR || DEX
 * @param {obj} weaponProperties weapon properties
 * @param {obj} weaponRange weapon range information
 * @param {obj} abilities character abilities (scores)
 */
function staves_getAbility(weaponProperties, weaponRange, abilities) {
  // finesse weapons can choose freely, so we choose the higher one
  if (weaponProperties.fin) {
    return abilities.str.value > abilities.dex.value ? "str" : "dex";
  }

  // thrown, but not finesse weapon: STR
  if (weaponProperties.thr) {
    return "str";
  }

  // if it's a ranged weapon, and hot a reach weapon (long = 10 (?))
  if (weaponRange.long !== 5 && !weaponProperties.rch) {
    return "dex";
  }

  // the default is STR
  return "str";
}

/**
 *
 * @param {obj} data item data
 * @param {obj} weaponProperties weapon properties
 * /* damage: { parts: [], versatile: '' }, * /
 */
function staves_getDamage(data, magicalDamageBonus) {
  let weaponBehavior = data.definition.weaponBehaviors[0];
  let versatile = weaponBehavior.properties.find((property) => property.name === "Versatile");
  if (versatile && versatile.notes) {
    versatile = src_utils/* default.parseDiceString */.Z.parseDiceString(versatile.notes + `+${magicalDamageBonus}`).diceString;
  } else {
    versatile = "";
  }

  let parts = [];

  // first damage part
  // blowguns and other weapons rely on ammunition that provides the damage parts
  if (weaponBehavior.damage && weaponBehavior.damage.diceString && weaponBehavior.damageType) {
    parts.push([
      src_utils/* default.parseDiceString */.Z.parseDiceString(weaponBehavior.damage.diceString + `+${magicalDamageBonus}`).diceString,
      weaponBehavior.damageType.toLowerCase(),
    ]);
  }

  // additional damage parts
  data.definition.grantedModifiers
    .filter((mod) => mod.type === "damage")
    .forEach((mod) => {
      if (mod.dice) {
        parts.push([mod.dice.diceString, mod.subType]);
      } else if (mod.value) {
        parts.push([`${mod.value}`, mod.subType]);
      }
    });

  let result = {
    // label: utils.parseDiceString(parts.map(part => part[0]).join(' + ')).diceString,
    parts: parts,
    versatile: versatile,
  };

  return result;
}

function parseStaff(data, character) {
  let template = JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("weapon"));
  let weapon = {
    name: data.definition.name,
    type: "weapon",
    data: template,
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: data.definition.type,
        },
      },
    },
  };

  weapon.data.weaponType = staves_getWeaponType(data);
  weapon.data.properties = staves_getProperties(data);
  weapon.data.proficient = getWeaponProficient(data, weapon.data.weaponType, character.flags.ddbimporter.dndbeyond.proficienciesIncludingEffects);
  weapon.data.description = {
    value: data.definition.description,
    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,
    unidentified: data.definition.type,
  };

  weapon.data.source = src_utils/* default.parseSource */.Z.parseSource(data.definition);
  weapon.data.quantity = data.quantity ? data.quantity : 1;

  const bundleSize = data.definition.bundleSize ? data.definition.bundleSize : 1;
  const totalWeight = data.definition.weight ? data.definition.weight : 0;
  weapon.data.weight = totalWeight / bundleSize;
  weapon.data.equipped = getEquipped(data);
  weapon.data.rarity = getItemRarity(data);
  weapon.data.identified = true;
  weapon.data.activation = { type: "action", cost: 1, condition: "" };
  weapon.data.range = staves_getRange(data);
  weapon.data.ability = staves_getAbility(weapon.data.properties, weapon.data.range, character.flags.ddbimporter.dndbeyond.effectAbilities);
  weapon.data.actionType = weapon.data.range.long === 5 ? "mwak" : "rwak";
  weapon.data.attackBonus = getMagicalBonus(data);
  weapon.data.damage = staves_getDamage(data, getMagicalBonus(data));

  return weapon;
}

;// CONCATENATED MODULE: ./src/parser/inventory/armor.js




/**
 * Gets the DND5E weapontype (simpleM, martialR etc.) as string
 * Supported Types only: Simple/Martial Melee/Ranged and Ammunition (Firearms in D&DBeyond)
 * @param {obj} data item data
 */
function getArmorType(data, flags) {
  // get the generic armor type
  const nameEntry = dictionary/* default.equipment.armorType.find */.Z.equipment.armorType.find((type) => type.name === data.definition.type);
  const idEntry = dictionary/* default.equipment.armorType.find */.Z.equipment.armorType.find((type) => type.id === data.definition.armorTypeId);

  // get the armor class
  const baseArmorClass = data.definition.armorClass;
  const bonusArmorClass = data.definition.grantedModifiers.reduce((prev, cur) => {
    if (cur.type === "bonus" && cur.subType === "armor-class" && cur.value) {
      return cur.value;
    } else {
      return 0;
    }
  }, 0);

  // get the max dex modifier (Medium Armor: 2, Heavy: 0)
  let maxDexModifier;
  switch (data.definition.type) {
    case "Heavy Armor":
      maxDexModifier = 0;
      break;
    case "Medium Armor":
      maxDexModifier = flags.maxMediumArmorDex;
      break;
    default:
      maxDexModifier = null;
  }

  return {
    type: nameEntry !== undefined ? nameEntry.value : idEntry !== undefined ? idEntry.value : "medium",
    value: baseArmorClass + bonusArmorClass,
    dex: maxDexModifier,
  };
}

/**
 * Gets the strength requirement to wear this armor, if any
 * @param {obj} data Item data
 */
function getStrength(data) {
  return data.definition.strengthRequirement !== null ? data.definition.strengthRequirement : 0;
}

/**
 * Wearing this armor can give a disadvantage on stealth checks
 */
function getStealthPenalty(data) {
  return data.definition.stealthCheck === 2;
}

/**
 * Checks the proficiency of the character with this specific weapon
 * @param {obj} data Item data
 * @param {array} proficiencies The character's proficiencies as an array of `{ name: 'PROFICIENCYNAME' }` objects
 */
function getProficient(data, proficiencies) {
  // Proficiency in armor category (Light Armor, Shield)
  if (proficiencies.find((proficiency) => proficiency.name === data.definition.type) !== -1) return true;
  // Specific proficiency
  if (proficiencies.find((proficiency) => proficiency.name === data.definition.baseArmorName) !== -1) return true;
  return false;
}

function parseArmor(data, character, flags) {
  let armor = {
    name: data.definition.name,
    type: "equipment",
    data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("equipment")),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: data.definition.type,
        },
      },
    },
  };

  armor.data.armor = getArmorType(data, flags);
  armor.data.strength = getStrength(data);
  armor.data.stealth = getStealthPenalty(data);
  armor.data.proficient = getProficient(data, character.flags.ddbimporter.dndbeyond.proficienciesIncludingEffects);
  armor.data.description = {
    value: data.definition.description,
    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,
    unidentified: data.definition.type,
  };

  armor.data.source = src_utils/* default.parseSource */.Z.parseSource(data.definition);
  armor.data.quantity = data.quantity ? data.quantity : 1;
  const bundleSize = data.definition.bundleSize ? data.definition.bundleSize : 1;
  const totalWeight = data.definition.weight ? data.definition.weight : 0;
  armor.data.weight = totalWeight / bundleSize;
  armor.data.equipped = getEquipped(data);
  armor.data.rarity = getItemRarity(data);
  armor.data.identified = true;
  armor.data.uses = common_getUses(data);

  return armor;
}

;// CONCATENATED MODULE: ./src/parser/inventory/wonderous.js



function parseWonderous(data) {
  /**
   * MAIN parseEquipment
   */
  let item = {
    name: data.definition.name,
    type: "equipment",
    data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("equipment")),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: data.definition.type,
        },
      },
    },
  };

  //
  // "armor": {
  // "type": "trinket",
  // "value": 10,
  // "dex": null
  // }
  item.data.armor = {
    type: "trinket",
    value: 10,
    dex: null,
  };

  /* "strength": 0 */
  item.data.strength = 0;

  /* "stealth": false,*/
  item.data.stealth = false;
  item.data.proficient = true;
  item.data.description = {
    value: data.definition.description,
    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,
    unidentified: data.definition.type,
  };

  item.data.source = src_utils/* default.parseSource */.Z.parseSource(data.definition);
  item.data.quantity = data.quantity ? data.quantity : 1;
  const bundleSize = data.definition.bundleSize ? data.definition.bundleSize : 1;
  const totalWeight = data.definition.weight ? data.definition.weight : 0;
  item.data.weight = totalWeight / bundleSize;
  item.data.equipped = getEquipped(data);
  item.data.rarity = getItemRarity(data);
  item.data.identified = true;
  item.data.uses = common_getUses(data);

  return item;
}

;// CONCATENATED MODULE: ./src/parser/inventory/potion.js




function potion_getActionType(data) {
  if (data.definition.tags.includes("Healing")) {
    return "heal";
  } else if (data.definition.tags.includes("Damage")) {
    // ranged spell attack. This is a good guess
    return "rsak";
  } else {
    return "other";
  }
}

function potion_getDamage(data, actionType) {
  let damage = { parts: [], versatile: "" };
  // is this a damage potion
  switch (actionType) {
    case "heal": {
      // healing potion
      // we only get the first matching modifier
      const healingModifier = data.definition.grantedModifiers.find(
        (mod) => mod.type === "bonus" && mod.subType === "hit-points"
      );
      if (healingModifier && healingModifier.dice) {
        damage.parts = [[healingModifier.dice.diceString + "[healing] ", "healing"]];
      } else if (healingModifier && healingModifier.fixedValue) {
        damage.parts = [[healingModifier.fixedValue + "[healing] ", "healing"]];
      }
      break;
    }
    case "rsak": {
      // damage potion
      const damageModifier = data.definition.grantedModifiers.find((mod) => mod.type === "damage" && mod.dice);
      if (damageModifier && damageModifier.dice) {
        damage.parts = [[damageModifier.dice.diceString + `[${damageModifier.subType}] `, damageModifier.subType]];
      } else if (damageModifier && damageModifier.fixedValue) {
        damage.parts = [[damageModifier.fixedValue + `[${damageModifier.subType}] `, damageModifier.subType]];
      }
      break;
    }
    // no default
  }
  return damage;
}

function potion_getDuration(data) {
  let duration = {
    value: null,
    units: "",
  };

  if (data.definition.duration) {
    if (data.definition.duration.durationUnit !== null) {
      duration.units = data.definition.duration.durationUnit.toLowerCase();
    } else {
      duration.units = data.definition.duration.durationType.toLowerCase().substring(0, 4);
    }
    if (data.definition.duration.durationInterval) duration.value = data.definition.duration.durationInterval;
  } else {
    const durationArray = [
      { foundryUnit: "day", descriptionMatches: ["day", "days"] },
      { foundryUnit: "hour", descriptionMatches: ["hour", "hours"] },
      { foundryUnit: "inst", descriptionMatches: ["instant", "instantaneous"] },
      { foundryUnit: "minute", descriptionMatches: ["minute", "minutes"] },
      { foundryUnit: "month", descriptionMatches: ["month", "months"] },
      { foundryUnit: "perm", descriptionMatches: ["permanent"] },
      { foundryUnit: "round", descriptionMatches: ["round", "rounds"] },
     // { foundryUnit: "spec", descriptionMatches: [null] },
      { foundryUnit: "turn", descriptionMatches: ["turn", "turns"] },
      { foundryUnit: "year", descriptionMatches: ["year", "years"] },
    ];
    // attempt to parse duration
    const descriptionUnits = durationArray.map((unit) => unit.descriptionMatches).flat().join("|");
    const durationExpression = new RegExp(`(\\d*)(?:\\s)(${descriptionUnits})`);
    const durationMatch = data.definition.description.match(durationExpression);

    if (durationMatch) {
      duration.units = durationArray.find((duration) => duration.descriptionMatches.includes(durationMatch[2])).foundryUnit;
      duration.value = durationMatch[1];
    }
  }
  return duration;
}


function parsePotion(data, itemType) {
  let consumable = {
    name: data.definition.name,
    type: "consumable",
    data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("consumable")),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: itemType,
        },
      },
    },
  };

  consumable.data.consumableType = "potion";
  consumable.data.uses = getConsumableUses(data);
  consumable.data.description = {
    value: data.definition.description,
    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,
    unidentified: data.definition.type,
  };
  consumable.data.source = src_utils/* default.parseSource */.Z.parseSource(data.definition);
  consumable.data.quantity = data.quantity ? data.quantity : 1;

  const bundleSize = data.definition.bundleSize ? data.definition.bundleSize : 1;
  const totalWeight = data.definition.weight ? data.definition.weight : 0;
  consumable.data.weight = totalWeight / bundleSize;
  consumable.data.equipped = getEquipped(data);
  consumable.data.rarity = getItemRarity(data);
  consumable.data.identified = true;
  consumable.data.activation = { type: "action", cost: 1, condition: "" };
  consumable.data.duration = potion_getDuration(data);
  consumable.data.actionType = potion_getActionType(data);
  consumable.data.damage = potion_getDamage(data, potion_getActionType(data));

  return consumable;
}

;// CONCATENATED MODULE: ./src/parser/inventory/scroll.js




function parseScroll(data) {
  let consumable = {
    name: data.definition.name,
    type: "consumable",
    data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("consumable")),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: data.definition.type,
        },
      },
    },
  };

  consumable.data.consumableType = "scroll";
  consumable.data.uses = getConsumableUses(data);
  consumable.data.description = {
    value: data.definition.description,
    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,
    unidentified: data.definition.type,
  };

  consumable.data.source = src_utils/* default.parseSource */.Z.parseSource(data.definition);
  consumable.data.quantity = data.quantity ? data.quantity : 1;

  const bundleSize = data.definition.bundleSize ? data.definition.bundleSize : 1;
  const totalWeight = data.definition.weight ? data.definition.weight : 0;
  consumable.data.weight = totalWeight / bundleSize;
  consumable.data.equipped = getEquipped(data);
  consumable.data.rarity = getItemRarity(data);
  consumable.data.identified = true;
  consumable.data.activation = { type: "action", cost: 1, condition: "" };
  consumable.data.actionType = "other";

  return consumable;
}

;// CONCATENATED MODULE: ./src/parser/inventory/tool.js




function isHalfProficiencyRoundedUp(data, ab) {
  const longAbility = dictionary/* default.character.abilities.filter */.Z.character.abilities.filter((ability) => ab === ability.value)
    .map((ability) => ability.long)[0];
  const roundUp = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "half-proficiency-round-up", `${longAbility}-ability-checks`);
  return Array.isArray(roundUp) && roundUp.length;
}

function getProficiency(data, toolName, ability) {
  const modifiers = [
      src_utils/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(data, true),
      src_utils/* default.getModifiers */.Z.getModifiers(data, "race", true),
      src_utils/* default.getModifiers */.Z.getModifiers(data, "background", true),
      src_utils/* default.getModifiers */.Z.getModifiers(data, "feat", true),
      src_utils/* default.getActiveItemModifiers */.Z.getActiveItemModifiers(data, true),
    ]
    .flat()
    .filter((modifier) => modifier.friendlySubtypeName === toolName)
    .map((mod) => mod.type);

  const halfProficiency =
    src_utils/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(data).find(
      (modifier) =>
        // Jack of All trades/half-rounded down
        (modifier.type === "half-proficiency" && modifier.subType === "ability-checks") ||
        // e.g. champion for specific ability checks
        isHalfProficiencyRoundedUp(data, ability)
    ) !== undefined
      ? 0.5
      : 0;

  const proficient = modifiers.includes("expertise") ? 2 : modifiers.includes("proficiency") ? 1 : halfProficiency;

  return proficient;
}

function parseTool(ddb, data, itemType) {
  /**
   * MAIN parseTool
   */
  let tool = {
    name: data.definition.name,
    type: "tool",
    data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("tool")),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: itemType,
        },
      },
    },
  };

  tool.data.ability = dictionary/* default.character.proficiencies.filter */.Z.character.proficiencies.filter((prof) => prof.name === tool.name)
    .map((prof) => prof.ability);

  if (!tool.data.ability) tool.data.ability = "dex";

  tool.data.description = {
    value: data.definition.description,
    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,
    unidentified: data.definition.type,
  };

  tool.data.proficient = (ddb) ? getProficiency(ddb, tool.name, tool.data.ability) : 0;
  tool.data.source = src_utils/* default.parseSource */.Z.parseSource(data.definition);
  tool.data.quantity = data.quantity ? data.quantity : 1;

  const bundleSize = data.definition.bundleSize ? data.definition.bundleSize : 1;
  const totalWeight = data.definition.weight ? data.definition.weight : 0;
  tool.data.weight = totalWeight / bundleSize;
  tool.data.equipped = getEquipped(data);
  tool.data.rarity = getItemRarity(data);
  tool.data.identified = true;
  tool.data.uses = common_getUses(data);

  return tool;
}

;// CONCATENATED MODULE: ./src/parser/inventory/loot.js



function getItemType(data) {
  let result = {
    type: "loot"
  };

  const foundryTypes = ["weapon", "equipment", "consumable", "tool", "loot", "class", "spell", "feat", "backpack"];

  const itemTypes =
    data.definition.tags && Array.isArray(data.definition.tags)
      ? [data.definition.type.toLowerCase(), ...data.definition.tags.map((t) => t.toLowerCase())]
      : [data.definition.type.toLowerCase()];

  let itemType = itemTypes
    .map((itemType) => {
      if (itemType === "container") return "backpack";
      if (itemType === "consumable") return "consumable";
      return foundryTypes.find((t) => t.indexOf(itemType) !== -1 || itemType.indexOf(t) !== -1);
    })
    .reduce(
      (itemType, currentType) => (currentType !== undefined && itemType === undefined ? currentType : itemType),
      undefined
    );

  if (!itemType) {
    const isConsumable =
      data.definition.type === "Gear" &&
      data.definition.subType === "Adventuring Gear" &&
      data.definition.tags.includes('Utility') &&
      ((data.definition.tags.includes('Damage') &&
      data.definition.tags.includes('Combat')) ||
      data.definition.tags.includes('Healing'));
    if (isConsumable) itemType = "consumable";
  }

  if (itemType) {
    result.type = itemType;
    if (itemType === "consumable") {
      if (data.definition.name.includes('vial') || data.definition.name.includes('flask')) {
        result.consumableType = "potion";
      } else {
        result.consumableType = "trinket";
      }
    }
  }

  return result;
}

function parseLoot(data, itemType) {
  const type = getItemType(data);

  let loot = {
    name: data.definition.name,
    type: type.type,
    data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("loot")), // was: tool
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: itemType,
        },
      },
    },
  };

  if (type.consumableType) {
    loot.data.consumableType = type.consumableType;
    loot.data.uses = getConsumableUses(data);
  }

  loot.data.description = {
    value: data.definition.description,
    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,
    unidentified: data.definition.type,
  };

  loot.data.source = src_utils/* default.parseSource */.Z.parseSource(data.definition);
  loot.data.quantity = data.quantity ? data.quantity : 1;

  const bundleSize = data.definition.bundleSize ? data.definition.bundleSize : 1;
  const totalWeight = data.definition.weight ? data.definition.weight : 0;
  loot.data.weight = totalWeight / bundleSize;
  loot.data.equipped = getEquipped(data);
  loot.data.rarity = getItemRarity(data);
  loot.data.identified = true;

  return loot;
}

;// CONCATENATED MODULE: ./src/parser/inventory/custom.js



function parseCustomItem(data) {
  let customItem = {
    name: data.definition.name,
    type: "loot",
    data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("loot")),
    flags: {
      ddbimporter: {
        custom: true,
        dndbeyond: {
          type: "Custom Item",
        },
      },
    },
  };

  let description = data.definition.description ? data.definition.description : "";
  description = data.definition.notes
    ? description + `<p><blockquote>${data.definition.notes}</blockquote></p>`
    : description;

  customItem.data.description = {
    value: description,
    chat: description,
    unidentified: description,
  };

  customItem.data.source = "Custom item";

  customItem.data.quantity = data.definition.quantity ? data.definition.quantity : 1;

  let bundleSize = data.definition.bundleSize ? data.definition.bundleSize : 1;
  let totalWeight = data.definition.weight ? data.definition.weight : 0;
  customItem.data.weight = totalWeight / bundleSize; // ;* (loot.data.quantity / bundleSize);
  customItem.data.price = data.definition.cost ? data.definition.cost : 0;
  customItem.data.equipped = getEquipped(data);
  customItem.data.identified = true;
  customItem.data.rarity = getItemRarity(data);

  return customItem;
}

;// CONCATENATED MODULE: ./src/parser/inventory/magicify.js
//
// Attempts to parse information from ddb about items to build a magicitems
// compatible set of metadata.
//
// https://gitlab.com/riccisi/foundryvtt-magic-items/
//
// Wand of Entangle Target example
//
// flags": {
// "magicitems": {
//       "enabled": true,
//       "charges": "7",
//       "chargeType": "c1",
//       "destroy": true,
//       "destroyCheck": "d1",
//       "rechargeable": true,
//       "recharge": "1d6+1",
//       "rechargeType": "t2",
//       "rechargeUnit": "r2",
//       "spells": {
//           "0": {
//               "id": "af8QUpphSZMoi2yb",
//               "name": "Entangle",
//               "pack": "world.spellsdndbeyond",
//               "img": "iconizer/Spell_Nature_StrangleVines.png",
//               "baseLevel": "1",
//               "level": "1",
//               "consumption": "1",
//               "upcast": "1",
//               "upcastCost": "1"
//           }
//       }
// "feats": {},
// "tables": {},
// "equipped": true,
// "attuned": true,
// "destroyFlavorText": "reaches 0 charges: it crumbles into ashes and is destroyed.",
// "sorting": "l"

// }
//
//
//



const MAGICITEMS = {};
MAGICITEMS.DAILY = "r1";
MAGICITEMS.SHORT_REST = "r4";
MAGICITEMS.LONG_REST = "r5";
MAGICITEMS.CHARGE_TYPE_WHOLE_ITEM = "c1";
MAGICITEMS.CHARGE_TYPE_PER_SPELL = "c2";
MAGICITEMS.NUMERIC_RECHARGE = "t1";
MAGICITEMS.FORMULA_RECHARGE = "t2";
MAGICITEMS.DestroyCheckAlways = "d1";
MAGICITEMS.DestroyCheck1D20 = "d2";

function getRechargeFormula(description, maxCharges) {
  if (description === "") {
    return maxCharges;
  }

  let chargeMatchFormula = /regains (\dd\d* \+ \d) expended charges/i;
  let chargeMatchFixed = /regains (\d*) /i;
  let chargeMatchLastDitch = /(\dd\d* \+ \d)/i;
  let chargeNextDawn = /can't be used this way again until the next/i;

  let matchFormula = chargeMatchFormula.exec(description);
  let matchFixed = chargeMatchFixed.exec(description);
  let matchLastDitch = chargeMatchLastDitch.exec(description);

  let match = maxCharges;
  if (matchFormula && matchFormula[1]) {
    match = matchFormula[1];
  } else if (matchFixed && matchFixed[1]) {
    match = matchFixed[1];
  } else if (matchLastDitch && matchLastDitch[1]) {
    match = matchLastDitch[1];
  } else if (description.search(chargeNextDawn) !== -1) {
    match = maxCharges;
  }

  return match;
}

function getPerSpell(useDescription, itemDescription) {
  if (useDescription === "") {
    // some times 1 use per day items, like circlet of blasting have nothing in
    // the limited use description, fall back to this
    let limitedUse = /can't be used this way again until the next/i;
    if (itemDescription.search(limitedUse) !== -1) {
      return 1;
    }
    return false;
  }

  let perSpell = /each ([A-z]*|\n*) per/i;
  let match = perSpell.exec(useDescription);
  if (match) {
    match = dictionary/* default.magicitems.nums.find */.Z.magicitems.nums.find((num) => num.id == match[1]).value;
  } else {
    match = false;
  }
  return match;
}

function checkDestroy(description) {
  let destroy = /expend the .* last charge/i;
  if (description.search(destroy) !== -1) {
    return true;
  } else {
    return false;
  }
}

function checkD20Destroy(description) {
  let destroy = /roll a d20.*destroyed/i;
  if (description.search(destroy) !== -1) {
    return MAGICITEMS.DestroyCheck1D20;
  } else {
    return MAGICITEMS.DestroyCheckAlways;
  }
}

// returns the default magicitem flags
function buildMagicItemSpell(chargeType, itemSpell) {
  let consumption = chargeType == MAGICITEMS.CHARGE_TYPE_PER_SPELL ? 1 : itemSpell.data.level;
  let castLevel = itemSpell.data.level;
  let upcast = itemSpell.data.level;

  // Do we have charge use data on spell?
  if (itemSpell.flags.ddbimporter.dndbeyond.spellLimitedUse) {
    const limitedUse = itemSpell.flags.ddbimporter.dndbeyond.spellLimitedUse;

    if (
      chargeType == MAGICITEMS.CHARGE_TYPE_WHOLE_ITEM &&
      !!limitedUse.minNumberConsumed &&
      itemSpell.data.level !== 0
    ) {
      consumption = limitedUse.minNumberConsumed;
      if (limitedUse.maxNumberConsumed) {
        upcast = itemSpell.data.level - limitedUse.minNumberConsumed + limitedUse.maxNumberConsumed;
      }
    }

    if (itemSpell.flags.ddbimporter.dndbeyond.castAtLevel) {
      castLevel = itemSpell.flags.ddbimporter.dndbeyond.castAtLevel;
    }
  }

  return {
    id: "",
    name: itemSpell.name,
    img: "",
    pack: "",
    baseLevel: itemSpell.data.level,
    level: castLevel,
    consumption: consumption,
    upcast: upcast,
    upcastCost: 1,
  };
}

function getItemSpells(itemId, chargeType, itemSpells) {
  let spells = {};

  for (let spellIndex = 0, i = 0; i < itemSpells.length; i++) {
    if (itemSpells[i].flags.ddbimporter.dndbeyond.lookupId === itemId) {
      spells[spellIndex] = buildMagicItemSpell(chargeType, itemSpells[i]);
      spellIndex++;
    }
  }

  return spells;
}

function createDefaultItem() {
  return {
    enabled: true,
    charges: 0,
    chargeType: MAGICITEMS.CHARGE_TYPE_WHOLE_ITEM, // c1 charge whole item, c2 charge per spells
    rechargeable: false,
    recharge: 0, // recharge amount/formula
    rechargeType: MAGICITEMS.FORMULA_RECHARGE, // t1 fixed amount, t2 formula
    rechargeUnit: "", // r1 daily, r2 dawn, r3 sunset, r4vshort rest, r5 long rest
    destroy: false, // destroy on depleted?
    destroyCheck: MAGICITEMS.DestroyCheckAlways, // d1 always, 1d20
    spells: {},
    feats: {},
    tables: {},
    equipped: true,
    attuned: false,
    destroyFlavorText: (src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("magicitems"))
      ? game.i18n.localize("MAGICITEMS.MagicItemDestroy")
      : "reaches 0 charges: it crumbles into ashes and is destroyed.",
    sorting: "l"
  };
}

function capitalize(word) {
  return word.charAt(0).toUpperCase() + word.slice(1);
}

function getResetType(description) {
  let resetType = null;

  const chargeMatchFormula = /expended charges (?:\w) at (\w)/i;
  const usedAgainFormula = /(?:until|when) you (?:take|finish) a (short|long|short or long) rest/i;
  const chargeNextDawnFormula = /can't be used this way again until the next (dawn|dusk)/i;

  const chargeMatch = chargeMatchFormula.exec(description);
  const untilMatch = usedAgainFormula.exec(description);
  const dawnMatch = chargeNextDawnFormula.exec(description);

  if (chargeMatch && chargeMatch[1]) {
    resetType = capitalize(`${chargeMatch[1]}Rest`);
  } else if (untilMatch && untilMatch[1]) {
    switch (untilMatch[1]) {
      case "short or long":
        resetType = "ShortRest";
        break;
      default:
        resetType = capitalize(`${untilMatch[1]}Rest`);
    }
  } else if (dawnMatch && dawnMatch[1]) {
    resetType = capitalize(`${dawnMatch[1]}Rest`);
  }

  return resetType;
}

function parseMagicItem(data, itemSpells, characterItem = true) {
  // this builds metadata for the magicitems module to use
  // https://gitlab.com/riccisi/foundryvtt-magic-items/

  if (data.definition.magic) {
    // default magicitem data
    let magicItem = createDefaultItem();
    magicItem.equipped = data.definition.canEquip;

    if (!characterItem) {
      const maxUses = "has (\\d*) charges";
      const maxUsesMatches = maxUses.exec(data.definition.description);
      const limitedUse = {
        maxUses: (maxUsesMatches && maxUsesMatches[1]) ? maxUsesMatches[1] : null,
        numberUsed: 0,
        resetType: getResetType(data.definition.description),
        resetTypeDescription: data.definition.description,
      };

      if (limitedUse.maxUses || limitedUse.resetType) data.limitedUse = limitedUse;
    }

    if (data.limitedUse) {
      // if the item is x per spell
      let perSpell = getPerSpell(data.limitedUse.resetTypeDescription, data.definition.description);
      if (perSpell) {
        magicItem.charges = perSpell;
        magicItem.recharge = perSpell;
        magicItem.rechargeUnit = MAGICITEMS.DAILY;
        magicItem.rechargeable = true;
        magicItem.rechargeType = MAGICITEMS.NUMERIC_RECHARGE;
        magicItem.chargeType = MAGICITEMS.CHARGE_TYPE_PER_SPELL;
      } else {
        magicItem.charges = data.limitedUse.maxUses;
        magicItem.recharge = getRechargeFormula(data.limitedUse.resetTypeDescription, magicItem.charges);

        if (data.limitedUse.resetType) {
          magicItem.rechargeUnit = dictionary/* default.magicitems.rechargeUnits.find */.Z.magicitems.rechargeUnits.find(
            (reset) => reset.id == data.limitedUse.resetType
          ).value;
        }
        magicItem.rechargeable = true;
      }

      magicItem.destroy = checkDestroy(data.limitedUse.resetTypeDescription);
      magicItem.destroyCheck = checkD20Destroy(data.limitedUse.resetTypeDescription);
    }

    magicItem.spells = getItemSpells(data.definition.id, magicItem.chargeType, itemSpells);

    return magicItem;
  } else {
    return {
      enabled: false,
    };
  }
}


;// CONCATENATED MODULE: ./src/parser/inventory/special.js
// import DICTIONARY from "../../dictionary.js";
// import logger from "../../logger.js";

function prepItem(item) {
  if (item.name.startsWith("Potion of")) {
    if (!item.data.duration) item.data.duration = { units: "", value: null };
    if (!item.data.target) item.data.target = { value: null, width: null, units: "", type: "creature" };
    if (!item.data.range) item.data.range = { value: null, long: null, units: "", type: "touch" };
  }
}

/**
 * Some items we need to fix up or massage because they are modified
 * in interesting ways
 * @param {*} ddb
 * @param {*} items
 */
function fixItems(items) {
  items.forEach((item) => {
    prepItem(item);
    switch (item.name) {
      case "Potion of Healing":
        item.data.damage = { parts: [["2d4 + 2", "healing"]], versatile: "", value: "" };
        item.data.uses = { value: 1, max: 1, per: "charges", autoDestroy: true, autoUse: true };
        item.data["duration"]["value"] = 0;
        item.data.actionType = "heal";
        item.data["target"]["type"] = "creature";
        item.data["range"]["type"] = "touch";
        break;
      case "Potion of Healing (Greater)":
      case "Potion of Greater Healing":
        item.data.damage = { parts: [["4d4 + 4", "healing"]], versatile: "", value: "" };
        item.data.uses = { value: 1, max: 1, per: "charges", autoDestroy: true, autoUse: true };
        item.data["duration"]["value"] = 0;
        item.data.actionType = "heal";
        item.data["target"]["type"] = "creature";
        item.data["range"]["type"] = "touch";
        item.flags["ddbimporter"]["dndbeyond"]["alternativeNames"] = ["Potion of Greater Healing"];
        break;
      case "Potion of Healing (Superior)":
      case "Potion of Superior Healing":
        item.data.damage = { parts: [["8d4 + 8", "healing"]], versatile: "", value: "" };
        item.data.uses = { value: 1, max: 1, per: "charges", autoDestroy: true, autoUse: true };
        item.data["duration"]["value"] = 0;
        item.data.actionType = "heal";
        item.data["target"]["type"] = "creature";
        item.data["range"]["type"] = "touch";
        item.flags["ddbimporter"]["dndbeyond"]["alternativeNames"] = [
          "Potion of Superior Healing",
          "potion of superior healing",
        ];
        break;
      case "Potion of Healing (Supreme)":
      case "Potion of Supreme Healing":
        item.data.damage = { parts: [["10d4 + 20", "healing"]], versatile: "", value: "" };
        item.data.uses = { value: 1, max: 1, per: "charges", autoDestroy: true, autoUse: true };
        item.data["duration"]["value"] = 0;
        item.data.actionType = "heal";
        item.data["target"]["type"] = "creature";
        item.data["range"]["type"] = "touch";
        item.flags["ddbimporter"]["dndbeyond"]["alternativeNames"] = ["Potion of Supreme Healing"];
        break;
      case "Iron Bands of Binding":
        item.data.activation = { type: "action", cost: 1, condition: "" };
        item.data.uses = { value: 1, max: "1", per: "day" };
        item.data.range = { value: 60, long: null, units: "ft" };
        item.data.ability = "dex";
        item.data.actionType = "rwak";
        item.data.save = { ability: "str", dc: 20, scaling: "flat" };
        item.data.target = { value: 1, width: null, units: "any", type: "creature" };
        break;
      case "Far Realm Shard": {
        item.data.activation.type = "special";
        item.data.actionType = "save";
        item.data.damage = { parts: [["3d6[psychic]", "psychic"]], versatile: "", value: "" };
        item.data.save = {
          ability: "cha",
          dc: null,
          scaling: "spell",
        };
        break;
      }
      case "Acid (vial)": {
        item.data.activation = { type: "action", cost: 1, condition: "" };
        item.data.target = { value: 1, width: null, units: "any", type: "creature" };
        item.data.range = { value: 20, long: null, units: "ft" };
        item.data.ability = "dex";
        item.data.actionType = "rwak";
        item.data.chatFlavor = "improvised weapon";
        item.data.damage = { parts: [["2d6[acid]", "acid"]], versatile: "", value: "" };
        break;
      }
      case "Alchemist's Fire (flask)":
      case "Alchemist's Fire": {
        item.data.activation = { type: "action", cost: 1, condition: "" };
        item.data.target = { value: 1, width: null, units: "any", type: "creature" };
        item.data.range = { value: 20, long: null, units: "ft" };
        item.data.ability = "dex";
        item.data.actionType = "rwak";
        item.data.chatFlavor = "improvised weapon";
        item.data.damage = { parts: [["1d4[fire]", "fire"]], versatile: "", value: "" };
        item.data.save = {
          ability: "dex",
          dc: 10,
          scaling: "flat",
        };
        break;
      }
      case "Bomb": {
        item.type = "consumable";
        item.data.activation = { type: "action", cost: 1, condition: "" };
        item.data.target = { value: 5, width: null, units: "ft", type: "radius" };
        item.data.range = { value: 60, long: null, units: "ft" };
        item.data.ability = "dex";
        item.data.actionType = "rwak";
        item.data.chatFlavor = "improvised weapon";
        item.data.damage = { parts: [["3d6[fire]", "fire"]], versatile: "", value: "" };
        item.data.save = {
          ability: "dex",
          dc: 12,
          scaling: "flat",
        };
        break;
      }
      case "Grenade, Fragmentation": {
        item.type = "consumable";
        item.data.activation = { type: "action", cost: 1, condition: "" };
        item.data.target = { value: 20, width: null, units: "ft", type: "radius" };
        item.data.range = { value: 60, long: null, units: "ft" };
        item.data.ability = "dex";
        item.data.actionType = "rwak";
        item.data.chatFlavor = "improvised weapon";
        item.data.damage = { parts: [["5d6[piercing]", "piercing"]], versatile: "", value: "" };
        item.data.save = {
          ability: "dex",
          dc: 15,
          scaling: "flat",
        };
        break;
      }
      // no default
    }
  });
}

// EXTERNAL MODULE: ./src/parser/effects/effects.js + 4 modules
var effects_effects = __webpack_require__(908);
// EXTERNAL MODULE: ./src/parser/effects/acEffects.js
var acEffects = __webpack_require__(419);
;// CONCATENATED MODULE: ./src/parser/inventory/infusions.js





// function isInfused(ddb, item) {
//   return ddb.infusions.item.some((mapping) =>
//     mapping.itemId === item.flags.ddbimporter.definitionId &&
//     mapping.inventoryMappingId === item.flags.ddbimporter.id &&
//     mapping.itemTypeId === item.flags.ddbimporter.definitionEntityTypeId
//   );
// }

// function getInfusionId(item, infusionMap) {
//   const infusionInMap = infusionMap.find((mapping) =>
//     mapping.itemId === item.flags.ddbimporter.definitionId &&
//     mapping.inventoryMappingId === item.flags.ddbimporter.id &&
//     mapping.itemTypeId === item.flags.ddbimporter.definitionEntityTypeId
//   );

//   if (infusionInMap) {
//     return infusionInMap.definitionKey.replace("infusion:", "");
//   } else {
//     return undefined;
//   }
// }


function getInfusionItemMap(ddb, item) {
  if (!ddb.infusions?.item) return undefined;
  return ddb.infusions.item.find((mapping) =>
    mapping.itemId === item.flags.ddbimporter.definitionId &&
    mapping.inventoryMappingId === item.flags.ddbimporter.id &&
    mapping.itemTypeId === item.flags.ddbimporter.definitionEntityTypeId
  );
}

function getInfusionDetail(ddb, definitionKey) {
  if (!ddb.infusions?.infusions?.definitionData) return undefined;
  return ddb.infusions.infusions.definitionData.find(
    (infusion) => infusion.definitionKey === definitionKey
  );
}


function getInfusionModifiers(infusionItemMap, infusionDetail) {
  let modifiers = [];

  switch (infusionDetail.modifierDataType) {
    case "class-level":
    case "damage-type-choice": {
      const damageMods = infusionDetail.modifierData.find(
        (data) => data.id === infusionItemMap.modifierGroupId
      );
      if (damageMods) modifiers = damageMods.modifiers;
      break;
    }
    case "granted":
    default: {
      modifiers = infusionDetail.modifierData.map((data) => data.modifiers).flat();
    }
  }

  // logger.debug(`${infusionDetail.name} ${infusionDetail.modifierDataType}`, modifiers);

  return modifiers;
}

function addMagicBonus(character, item, modifiers) {
  const filteredModifiers = src_utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "bonus", "magic");
  const magicBonus = src_utils/* default.getModifierSum */.Z.getModifierSum(filteredModifiers, character);

  if (magicBonus && magicBonus !== 0 && magicBonus !== "") {
    item.data.damage.parts[0][0] += ` + ${magicBonus}`;
    item.data.attackBonus += magicBonus;
    // to do add infusion description to item
  }
  return item;
}

function getInfusionActionData(ddb) {
  if (!ddb.infusions?.item) return [];
  const generatedInfusionMap = ddb.infusions.item.map((mapping) => {
    return getInfusionDetail(ddb, mapping.definitionKey);
  });

  const infusionActions = generatedInfusionMap
    .filter((infusionDetail) => infusionDetail.type === "augment" && infusionDetail.actions.length > 0)
    .map((infusionDetail) => {
      const actions = infusionDetail.actions.map((action) => {
        const itemLookup = ddb.infusions.item.find((mapping) => mapping.definitionKey === infusionDetail.definitionKey);
        if (!action.name) {
          const itemLookup = ddb.infusions.item.find((mapping) => mapping.definitionKey === infusionDetail.definitionKey);
          const item = ddb.character.inventory.find((item) => item.id === itemLookup.inventoryMappingId);
          const itemName = item?.definition?.name ? `${item.definition.name} : ` : ``;
          action.name = `${itemName}[Infusion] ${infusionDetail.name}`;
        }
        action.infusionFlags = {
          maps: [JSON.parse(JSON.stringify(itemLookup))],
          applied: [JSON.parse(JSON.stringify(infusionDetail))],
          infused: true,
        };
        return action;
      });
      return actions;
    })
    .flat();

  src_logger/* default.debug */.Z.debug(`Infusions Actions Map`, generatedInfusionMap);
  src_logger/* default.debug */.Z.debug(`Generated Infusions Actions`, infusionActions);
  return infusionActions;
}

function parseInfusion(ddb, character, foundryItem, ddbItem, compendiumItem) {
    // get item mapping
  const infusionItemMap = getInfusionItemMap(ddb, foundryItem);
  foundryItem.flags.infusions = { maps: [], applied: [], infused: false };
  if (infusionItemMap) {
    src_logger/* default.debug */.Z.debug(`Infusion detected for ${foundryItem.name}`);
    // console.warn(ddb);
    // console.warn(ddbItem);
    // console.warn(foundryItem);
    const infusionDetail = getInfusionDetail(ddb, infusionItemMap.definitionKey);

    // get modifiers && generate effects
    const ddbInfusionItem = JSON.parse(JSON.stringify(ddbItem));
    ddbInfusionItem.definition.grantedModifiers = getInfusionModifiers(infusionItemMap, infusionDetail);

    foundryItem = (0,effects_effects/* generateEffects */.K7)(ddb, character, ddbInfusionItem, foundryItem, compendiumItem, "infusion");
    // magic bonuses can't be added as effects as it's real hard to pin to one item
    foundryItem = addMagicBonus(character, foundryItem, ddbInfusionItem.definition.grantedModifiers);

    // add infusion flags
    foundryItem.flags.infusions.infused = true;
    foundryItem.flags.infusions.applied.push(infusionDetail);
    foundryItem.flags.infusions.maps.push(infusionItemMap);

    // Update Item description
    foundryItem.data.description.value += `<div class="infusion-description"><p><b>Infusion: ${infusionDetail.name}</b></p><p>${infusionDetail.description}</p></div>`;
    foundryItem.data.description.chat += `<div class="infusion-description"><p><b>Infusion: ${infusionDetail.name}</b></p><p>${infusionDetail.snippet ? infusionDetail.snippet : infusionDetail.description}</p></div>`;

    // adjust name for infused item
    foundryItem.name += " [Infusion]";
    // if item is loot, lets move it to equipment/trinket so effects will apply
    if (foundryItem.type === "loot") {
      foundryItem.type = "equipment";
      foundryItem.data.armor = {
        type: "trinket",
        value: 10,
        dex: null,
      };
      // infusions will over ride the can equip status, so just check for equipped
      foundryItem.data.equipped = ddbItem.equipped;
    }
  }
  return foundryItem;

}

;// CONCATENATED MODULE: ./src/parser/inventory/index.js

// type: weapon




// type: armor


// tyoe: wonderous item


// type: consumables



// type: tool


// other loot




// magicitems support






// effects support




// tables


/**
 * We get extra damage to a weapon attack here, for example Improved
 * Divine Smite
 * @param {*} data
 * @param {*} restrictions (array)
 */
function getExtraDamage(ddb, restrictions) {
  return src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "damage", null, restrictions).map((mod) => {
    if (mod.dice) {
      return [mod.dice.diceString, mod.subType];
    } else if (mod.value) {
      return [mod.value, mod.subType];
    } else {
      return [null, null];
    }
  });
}

function isMartialArtists(classes) {
  return classes.some((cls) => cls.classFeatures.some((feature) => feature.definition.name === "Martial Arts"));
}

function getWarlockFeatures(ddb, weapon) {
  // Some features, notably hexblade abilities we scrape out here
  const warlockFeatures = ddb.character.characterValues
    .filter(
      (characterValue) =>
        characterValue.value &&
        characterValue.valueId == weapon.id &&
        dictionary/* default.character.characterValuesLookup.some */.Z.character.characterValuesLookup.some(
          (entry) => entry.typeId == characterValue.typeId
        )
    )
    .map(
      (characterValue) =>
        dictionary/* default.character.characterValuesLookup.find */.Z.character.characterValuesLookup.find(
          (entry) => entry.typeId == characterValue.typeId
        ).name
    );

  // Any Pact Weapon Features
  const pactFeatures = ddb.character.options.class
    .filter(
      (option) =>
        warlockFeatures.includes("pactWeapon") &&
        option.definition.name &&
        dictionary/* default.character.pactFeatures.includes */.Z.character.pactFeatures.includes(option.definition.name)
    )
    .map((option) => option.definition.name);

  const features = warlockFeatures.concat(pactFeatures);
  return features;
}

function getMonkFeatures(ddb, weapon) {
  const kenseiWeapon = src_utils/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(ddb).some((mod) =>
    mod.friendlySubtypeName === weapon.definition.type &&
    mod.type === "kensei"
  );

  const monkWeapon = src_utils/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(ddb).some((mod) =>
    mod.friendlySubtypeName === weapon.definition.type &&
    mod.type == "monk-weapon"
  ) || (weapon.definition.isMonkWeapon && isMartialArtists(ddb.character.classes));

  let features = [];

  if (kenseiWeapon) features.push("kenseiWeapon");
  if (monkWeapon) features.push("monkWeapon");

  return features;
}


function getMartialArtsDie(ddb) {
  let result = {
    diceCount: null,
    diceMultiplier: null,
    diceString: null,
    diceValue: null,
    fixedValue: null,
  };

  const die = ddb.character.classes
    // is a martial artist
    .filter((cls) => cls.classFeatures.some((feature) => feature.definition.name === "Martial Arts"))
    // get class features
    .map((cls) => cls.classFeatures)
    .flat()
    // filter relevant features, those that are martial arts and have a levelscaling hd
    .filter((feature) => feature.definition.name === "Martial Arts" && feature.levelScale && feature.levelScale.dice)
    // get this dice object
    .map((feature) => feature.levelScale.dice);

  if (die && die.length > 0) {
    result = die[0];
  }

  return result;

}

function getClassFeatures(ddb, weapon) {
  const warlockFeatures = getWarlockFeatures(ddb, weapon);
  const monkFeatures = getMonkFeatures(ddb, weapon);
  return warlockFeatures.concat(monkFeatures);
}

function getItemFlags(ddb, data, character) {
  let flags = {
    damage: {
      parts: [],
    },
      // Some features, notably hexblade abilities we scrape out here
    classFeatures: getClassFeatures(ddb, data),
    martialArtsDie: getMartialArtsDie(ddb),
    maxMediumArmorDex: Math.max(...src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "set", "ac-max-dex-armored-modifier").map((mod) => mod.value), 2),
    magicItemAttackInt: src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "bonus", "magic-item-attack-with-intelligence").length > 0,
  };

  if (flags.classFeatures.includes("Lifedrinker")) {
    flags.damage.parts.push(["@mod", "necrotic"]);
  }
  // const addItemEffects = game.settings.get("ddb-importer", "character-update-policy-add-item-effects");
  const addCharacterEffects = game.settings.get("ddb-importer", "character-update-policy-add-character-effects");

  // for melee attacks get extras
  if (data.definition.attackType === 1) {
    // get improved divine smite etc for melee attacks
    const extraDamage = getExtraDamage(ddb, ["Melee Weapon Attacks"]);

    if (!!extraDamage.length > 0) {
      flags.damage.parts = flags.damage.parts.concat(extraDamage);
    }
    // do we have great weapon fighting?
    if (src_utils/* default.hasChosenCharacterOption */.Z.hasChosenCharacterOption(ddb, "Great Weapon Fighting")) {
      flags.classFeatures.push("greatWeaponFighting");
    }
    // do we have dueling fighting style?
    if (src_utils/* default.hasChosenCharacterOption */.Z.hasChosenCharacterOption(ddb, "Dueling") && !addCharacterEffects) {
      flags.classFeatures.push("Dueling");
    }
    // do we have dueling fighting style?
    if (src_utils/* default.hasChosenCharacterOption */.Z.hasChosenCharacterOption(ddb, "Two-Weapon Fighting")) {
      flags.classFeatures.push("Two-Weapon Fighting");
    }
    if (src_utils/* default.getCustomValue */.Z.getCustomValue(data, character, 18)) {
      flags.classFeatures.push("OffHand");
    }
  }
  // ranged fighting style is added as a global modifier elsewhere
  // as is defensive style

  return flags;
}

function getItemFromGearTypeIdOne(ddb, data) {
  let item = {};

  switch (data.definition.subType) {
    case "Potion":
      item = parsePotion(data, data.definition.subType);
      break;
    case "Tool":
      item = parseTool(ddb, data, data.definition.subType);
      break;
    case "Ammunition":
      item = parseAmmunition(data, data.definition.subType);
      break;
    default:
      item = parseLoot(data, data.definition.subType);
  }
  return item;
}

function otherGear (ddb, data) {
  let item = {};

  switch (data.definition.gearTypeId) {
    case 1:
      item = getItemFromGearTypeIdOne(ddb, data);
      break;
    case 4:
      item = parseLoot(data, "Mount");
      break;
    case 5:
    item = parsePotion(data, "Poison");
      break;
    case 6:
    item = parsePotion(data, "Potion");
      break;
    case 11:
      item = parseTool(ddb, data, "Tool");
      break;
    case 12:
    case 17:
      item = parseLoot(data, "Vehicle");
      break;
    case 16:
      item = parseLoot(data, "Equipment Pack");
      break;
    case 18:
      // Change to parseGemstone (consummable) ?
      item = parseLoot(data, "Gemstone");
      break;
    default:
      src_logger/* default.warn */.Z.warn("Other Gear type missing from " + data.definition.name);
  }
  return item;
}

function inventory_addCustomValues(ddbItem, foundryItem, character) {
  // to hit override requires a lot of crunching
  // const toHitOverride = utils.getCustomValue(item, character, 13);
  const toHitBonus = src_utils/* default.getCustomValue */.Z.getCustomValue(ddbItem, character, 12);
  const damageBonus = src_utils/* default.getCustomValue */.Z.getCustomValue(ddbItem, character, 10);
  // const displayAsAttack = utils.getCustomValue(item, character, 16);
  const costOverride = src_utils/* default.getCustomValue */.Z.getCustomValue(ddbItem, character, 19);
  const weightOverride = src_utils/* default.getCustomValue */.Z.getCustomValue(ddbItem, character, 22);
  // dual wield 18
  // silvered
  const silvered = src_utils/* default.getCustomValue */.Z.getCustomValue(ddbItem, character, 20);
  // adamantine
  const adamantine = src_utils/* default.getCustomValue */.Z.getCustomValue(ddbItem, character, 21);
  // off-hand
  // const offHand = utils.getCustomValue(ddbItem, character, 18);

  if (toHitBonus) foundryItem.data.attackBonus += toHitBonus;
  if (damageBonus && foundryItem.data?.damage?.parts && foundryItem.data?.damage?.parts.length !== 0) {
    foundryItem.data.damage.parts[0][0] = foundryItem.data.damage.parts[0][0].concat(` +${damageBonus}`);
  } else if (damageBonus && foundryItem.data?.damage?.parts) {
    const part = [`+${damageBonus}`, ""];
    foundryItem.data.damage.parts.push(part);
  }
  if (costOverride) foundryItem.data.cost = costOverride;
  if (weightOverride) foundryItem.data.weight = weightOverride;
  if (silvered) foundryItem.data.properties['sil'] = true;
  if (adamantine) foundryItem.data.properties['ada'] = true;
}

function addExtraDDBFlags(data, item) {
  item.flags.ddbimporter['id'] = data.id;
  item.flags.ddbimporter['entityTypeId'] = data.entityTypeId;

  if (data.definition.avatarUrl) item.flags.ddbimporter.dndbeyond['avatarUrl'] = data.definition.avatarUrl.split('?')[0];
  if (data.definition.largeAvatarUrl) item.flags.ddbimporter.dndbeyond['largeAvatarUrl'] = data.definition.largeAvatarUrl.split('?')[0];
  if (data.definition.filterType) {
    const filter = dictionary/* default.items.find */.Z.items.find((i) => i.filterType === data.definition.filterType);
    if (filter) item.flags.ddbimporter.dndbeyond['filterType'] = filter.filterType;
  }

  // container info
  if (data.containerEntityId) item.flags.ddbimporter['containerEntityId'] = data.containerEntityId;
  if (data.containerEntityTypeId) item.flags.ddbimporter['containerEntityTypeId'] = data.containerEntityTypeId;
  return item;
}

// the filter type "Other Gear" represents the equipment while the other filters represents the magic items in ddb
function parseItem(ddb, data, character, flags) {
  try {
    // is it a weapon?
    let item = {};
    if (data.definition.filterType) {
      switch (data.definition.filterType) {
        case "Weapon": {
          if (data.definition.type === "Ammunition" || data.definition.subType === "Ammunition") {
            item = parseAmmunition(data, "Ammunition");
          } else {
            item = parseWeapon(data, character, flags);
          }
          break;
        }
        case "Armor":
          item = parseArmor(data, character, flags);
          break;
        case "Wondrous item":
        case "Ring":
        case "Wand":
        case "Rod":
          item = parseWonderous(data);
          break;
        case "Staff":
          item = parseStaff(data, character);
          break;
        case "Potion":
          item = parsePotion(data, data.definition.type);
          break;
        case "Scroll":
          item = parseScroll(data);
          break;
        case "Other Gear":
          item = otherGear(ddb, data);
          break;
        default:
          src_logger/* default.warn */.Z.warn("Item filterType not implemented for " + data.definition.name);
          break;
      }
    } else {
      // try parsing it as a custom item
      item = parseCustomItem(data);
    }
    item.data.attunement = getAttunement(data);
    if (data.definition.cost) item.data.price = data.definition.cost;

    item = addExtraDDBFlags(data, item);

    return item;
  } catch (err) {
    src_logger/* default.warn */.Z.warn(
      `Unable to parse item: ${data.definition.name}, ${data.definition.type}/${data.definition.filterType}. ${err.message}`,
      "character"
    );
    src_logger/* default.error */.Z.error(err.stack);
    return { // return empty strut
      name: data.definition.name,
      flags: {
        ddbimporter: {
          dndbeyond: {
          },
        },
      },
    };
  }
}

function enrichFlags(data, item) {
  if (data.definition.magic) {
    if (item.data.properties) {
      item.data.properties['mgc'] = true;
    } else {
      item.data.properties = { mgc: true };
    }
  }
  if (item.data.uses?.max && !item.flags?.betterRolls5e) {
    item.flags['betterRolls5e'] = {
      quickCharges: {
        value: {
          use: true,
          resource: true
        },
        altValue: {
          use: true,
          resource: true
        }
      },
    };
  }
  if (data.definition?.entityTypeId) item.flags.ddbimporter['definitionEntityTypeId'] = data.definition.entityTypeId;
  if (data.definition?.id) item.flags.ddbimporter['definitionId'] = data.definition.id;
  if (data.entityTypeId) item.flags.ddbimporter['entityTypeId'] = data.entityTypeId;
  if (data.id) item.flags.ddbimporter['id'] = data.id;
  if (data.definition?.tags) item.flags.ddbimporter.dndbeyond['tags'] = data.definition.tags;
  if (data.definition?.sources) item.flags.ddbimporter.dndbeyond['sources'] = data.definition.sources;
}

function getInventory(ddb, character, itemSpells) {
  let items = [];
  // first, check custom name, price or weight
  ddb.character.characterValues.forEach((cv) => {
    // try to find a matching item based on the characterValues (an array of custom adjustements to different parts of the character)
    let item = ddb.character.inventory.find((item) => item.id === cv.valueId);
    if (item) {
      // check if this property is in the list of supported ones, based on our DICT
      let property = dictionary/* default.item.characterValues.find */.Z.item.characterValues.find((entry) => entry.typeId === cv.typeId);
      // overwrite the name, weight or price with the custom value
      if (property && cv.value.length !== 0) item.definition[property.value] = cv.value;
    }
  });

  // now parse all items

  const customItems = ddb.character.customItems
    ? ddb.character.customItems.map((customItem) => ({
      id: customItem.id,
      definition: customItem,
    }))
    : [];

  const daeInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("dae");
  const compendiumItem = character.flags.ddbimporter.compendium;
  const addEffects = (compendiumItem)
    ? game.settings.get("ddb-importer", "munching-policy-add-effects")
    : game.settings.get("ddb-importer", "character-update-policy-add-item-effects");
  const generateArmorACEffect = (compendiumItem)
    ? game.settings.get("ddb-importer", "munching-policy-add-ac-armor-effects")
    : game.settings.get("ddb-importer", "character-update-policy-generate-ac-armor-effects");
  const autoAC = src_utils/* default.versionCompare */.Z.versionCompare(game.data.system.data.version, "1.4.0") >= 0;

  for (let ddbItem of ddb.character.inventory.concat(customItems)) {
    const originalName = ddbItem.definition.name;
    ddbItem.definition.name = src_utils/* default.getName */.Z.getName(ddbItem, character);
    const flags = getItemFlags(ddb, ddbItem, character);

    const updateExisting = compendiumItem
      ? game.settings.get("ddb-importer", "munching-policy-update-existing")
      : false;
    ddbItem.definition.description = (0,table/* generateTable */.p)(ddbItem.definition.name, ddbItem.definition.description, updateExisting);

    let item = Object.assign({}, parseItem(ddb, ddbItem, character, flags));
    inventory_addCustomValues(ddbItem, item, character);
    enrichFlags(ddbItem, item);

    if (item) {
      item.flags.magicitems = parseMagicItem(ddbItem, itemSpells);
      item.flags.ddbimporter.originalName = originalName;
      if (!item.effects) item.effects = [];
      if (!item.name || item.name === "") item.name = "Item";

      if (daeInstalled && addEffects) item = (0,effects_effects/* generateEffects */.K7)(ddb, character, ddbItem, item, compendiumItem, "item");
      // if this is a piece of armor and not generating effects don't generate ac
      if (item.type === "equipment" && item.data.armor?.type && !["trinket", "clothing"].includes(item.data.armor.type)) {
        if (daeInstalled && generateArmorACEffect) {
          item = (0,acEffects/* generateBaseACItemEffect */.se)(ddb, character, ddbItem, item, compendiumItem);
        }
      } else if (autoAC || daeInstalled) {
        // always generate other item ac effects
        item = (0,acEffects/* generateBaseACItemEffect */.se)(ddb, character, ddbItem, item, compendiumItem);
      }

      if (!compendiumItem) item = parseInfusion(ddb, character, item, ddbItem, compendiumItem);
      items.push(item);
    }
  }

  fixItems(items);
  return items;
}

;// CONCATENATED MODULE: ./src/muncher/items.js
// Main module class








async function getCharacterInventory(items) {
  return items.map((item) => {
    return {
      chargesUsed: 0,
      definitionId: 0,
      definitionTypeId: 0,
      displayAsAttack: null,
      entityTypeId: 0,
      equipped: false,
      id: 0,
      isAttuned: false,
      quantity: 1,
      definition: item,
    };
  });
}

async function generateImportItems(items) {
  const mockCharacter = {
    data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("character")),
    type: "character",
    name: "",
    flags: {
      ddbimporter: {
        compendium: true,
        dndbeyond: {
          effectAbilities: [],
          totalLevels: 0,
          proficiencies: [],
          proficienciesIncludingEffects: [],
          characterValues: [],
        },
      },
    },
  };
  const mockDDB = {
    character: {
      classes: [],
      race: {
        racialTraits: [],
      },
      characterValues: [],
      inventory: items,
      customItems: null,
      options: {
        class: [],
        race: [],
        feat: [],
      },
      modifiers: {
        race: [],
        class: [],
        background: [],
        feat: [],
        item: [],
        condition: [],
      },
      feats: [],
    }
  };
  let itemSpells = []; // here we need to parse each available spell and build a mock spell parser
  const inventory = getInventory(mockDDB, mockCharacter, itemSpells);
  const results = {
    items: inventory,
    itemSpellNames: itemSpells, // this needs to be a list of spells to find
  };
  return results;
}

function getItemData(sourceFilter) {
  const cobaltCookie = getCobalt();
  const campaignId = (0,utils/* getCampaignId */.F9)();
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get("ddb-importer", "debug-json");
  const sources = game.settings.get("ddb-importer", "munching-policy-monster-sources").flat();

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/items`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          (0,utils/* download */.LR)(JSON.stringify(data), `items-raw.json`, "application/json");
        }
        if (!data.success) {
          (0,utils/* munchNote */.ep)(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => {
        if (sources.length == 0 || !sourceFilter) return data.data;
        return data.data.filter((item) =>
          item.sources.some((source) => sources.includes(source.sourceId))
        );
      })
      .then((data) => getCharacterInventory(data))
      .then((items) => generateImportItems(items))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

async function addMagicItemSpells(items, spells, updateBool) {
  if (spells.length === 0) return;
  const itemSpells = await (0,muncher_import/* updateCompendium */.X)("itemspells", { itemspells: spells }, updateBool);
  // scan the inventory for each item with spells and copy the imported data over
  items.forEach((item) => {
    if (item.flags.magicitems.spells) {
      for (let [i, spell] of Object.entries(item.flags.magicitems.spells)) {
        const itemSpell = itemSpells.find((item) => item.name === spell.name);
        if (itemSpell) {
          for (const [key, value] of Object.entries(itemSpell)) {
            item.flags.magicitems.spells[i][key] = value;
          }
        }
      }
    }
  });
}

async function parseItems(ids = null) {
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");
  const magicItemsInstalled = !!game.modules.get("magicitems");
  const uploadDirectory = game.settings.get("ddb-importer", "other-image-upload-directory").replace(/^\/|\/$/g, "");

  // to speed up file checking we pregenerate existing files now.
  src_logger/* default.info */.Z.info("Checking for existing files...");
  await src_utils/* default.generateCurrentFiles */.Z.generateCurrentFiles(uploadDirectory);
  src_logger/* default.info */.Z.info("Check complete, getting ItemData.");

  const addToCompendiumFolder = game.settings.get("ddb-importer", "munching-policy-use-compendium-folders");
  const compendiumFoldersInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("compendium-folders");
  if (addToCompendiumFolder && compendiumFoldersInstalled) {
    (0,utils/* munchNote */.ep)(`Checking compendium folders..`, true);
    await (0,compendiumFolders/* createCompendiumFolderStructure */.FT)("items");
  }

  // disable source filter if ids provided
  const sourceFilter = !(ids !== null && ids.length > 0);
  const results = await getItemData(sourceFilter);
  let items = results.items;

  // Items Spell addition is currently not done, parsing out spells needs to be addded
  // let itemSpells = results.value.itemSpells;
  let itemSpells = null;

  // store all spells in the folder specific for Dynamic Items
  if (magicItemsInstalled && itemSpells && Array.isArray(itemSpells)) {
    await addMagicItemSpells(items, itemSpells, updateBool);
  }

  const srdItems = await (0,muncher_import/* srdFiddling */.cC)(items, "inventory");
  const filteredItems = (ids !== null && ids.length > 0)
    ? srdItems.filter((s) => s.flags?.ddbimporter?.definitionId && ids.includes(String(s.flags.ddbimporter.definitionId)))
    : srdItems;
  const finalItems = await (0,muncher_import/* daeFiddling */.xh)(filteredItems);

  const finalCount = finalItems.length;
  (0,utils/* munchNote */.ep)(`Importing ${finalCount} items!`, true);

  return new Promise((resolve) => {
    resolve((0,muncher_import/* updateCompendium */.X)("inventory", { inventory: finalItems }, updateBool));
  });
}



// EXTERNAL MODULE: ./src/muncher/importMonster.js
var importMonster = __webpack_require__(633);
;// CONCATENATED MODULE: ./src/muncher/monsters.js
// Main module class









async function getMonsterData(ids) {
  const cobaltCookie = getCobalt();
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");

  const body = {
    cobalt: cobaltCookie,
    betaKey: betaKey,
  };

  if (ids && ids.length > 0) {
    body.ids = [...new Set(ids)];
  } else {
    const searchTerm = $("#monster-munch-filter")[0].value;
    body.sources = game.settings.get("ddb-importer", "munching-policy-monster-sources").flat();
    body.search = $("#monster-munch-filter")[0].value;
    body.homebrew = body.sources.length > 0 ? false : game.settings.get("ddb-importer", "munching-policy-monster-homebrew");
    body.homebrewOnly = body.sources.length > 0 ? false : game.settings.get("ddb-importer", "munching-policy-monster-homebrew-only");
    body.searchTerm = encodeURIComponent(searchTerm);
    body.exactMatch = game.settings.get("ddb-importer", "munching-policy-monster-exact-match");
    body.sources = game.settings.get("ddb-importer", "munching-policy-monster-sources").flat();
  }

  const debugJson = game.settings.get("ddb-importer", "debug-json");

  const url = ids && ids.length > 0
    ? `${parsingApi}/proxy/monsters/ids`
    : `${parsingApi}/proxy/monster`;

  return new Promise((resolve, reject) => {
    fetch(url, {
      method: "POST",
      mode: "cors",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (!data.success) {
          (0,utils/* munchNote */.ep)(`API Failure: ${data.message}`);
          reject(data.message);
        }
        if (debugJson) {
          (0,utils/* download */.LR)(JSON.stringify(data), `monsters-raw.json`, "application/json");
        }
        return data;
      })
      .then((data) => {
        (0,utils/* munchNote */.ep)(`Retrieved ${data.data.length} monsters, starting parse...`, true, false);
        src_logger/* default.info */.Z.info(`Retrieved ${data.data.length} monsters`);
        const parsedMonsters = (0,monster/* parseMonsters */.U)(data.data);
        return parsedMonsters;
      })
      .then((data) => {
        (0,utils/* munchNote */.ep)(
          `Parsed ${data.actors.length} monsters, failed ${data.failedMonsterNames.length} monsters`,
          false,
          true
        );
        if (data.failedMonsterNames && data.failedMonsterNames.length !== 0)
          src_logger/* default.error */.Z.error(`Failed to parse ${data.failedMonsterNames}`);
        resolve(data.actors);
      })
      .catch((error) => reject(error));
  });
}

async function parseCritters(ids = null) {
  await (0,importMonster/* checkMonsterCompendium */.eX)();
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");
  const updateImages = game.settings.get("ddb-importer", "munching-policy-update-images");
  const uploadDirectory = game.settings.get("ddb-importer", "other-image-upload-directory").replace(/^\/|\/$/g, "");

  // to speed up file checking we pregenerate existing files now.
  src_logger/* default.info */.Z.info("Checking for existing files...");
  await src_utils/* default.generateCurrentFiles */.Z.generateCurrentFiles(uploadDirectory);
  src_logger/* default.info */.Z.info("Check complete getting monster data...");
  let monsters = await getMonsterData(ids);

  if (!updateBool || !updateImages) {
    (0,utils/* munchNote */.ep)(`Calculating which monsters to update...`, true);
    const existingMonsters = await (0,muncher_import/* getCompendiumItems */.pI)(monsters, "npc");
    const existingMonstersTotal = existingMonsters.length + 1;
    if (!updateBool) {
      src_logger/* default.debug */.Z.debug("Removing existing monsters from import list");
      src_logger/* default.debug */.Z.debug(`Matched ${existingMonstersTotal}`);
      (0,utils/* munchNote */.ep)(`Removing ${existingMonstersTotal} from update...`);
      monsters = await (0,muncher_import/* removeItems */.Er)(monsters, existingMonsters);
    }
    if (!updateImages) {
      src_logger/* default.debug */.Z.debug("Copying monster images across...");
      (0,utils/* munchNote */.ep)(`Copying images for ${existingMonstersTotal} monsters...`);
      monsters = (0,importMonster/* copyExistingMonsterImages */.ph)(monsters, existingMonsters);
    }
  }
  (0,utils/* munchNote */.ep)("");
  (0,utils/* munchNote */.ep)(`Fiddling with the SRD data...`, true);
  const finalMonsters = await (0,muncher_import/* srdFiddling */.cC)(monsters, "monsters");

  // let features = [];
  // let cr = [];
  // console.warn(finalMonsters);
  // finalMonsters.forEach((monster) => {
  //   cr.push({name: monster.name, cr: monster.data.details.cr, type: monster.data.details.type });
  // monster.items.forEach((feature) => {
  //   features.push({ name: feature.name, monster: monster.name, srdImage: feature.img});
  // })
  // });
  // download(JSON.stringify(features), `monster-features.json`, "application/json");
  // download(JSON.stringify(cr), `monster-details.json`, "application/json");
  // return 0;

  (0,utils/* munchNote */.ep)(`Generating Icon Map..`, true);
  await (0,importMonster/* generateIconMap */.NM)(finalMonsters);


  const addToCompendiumFolder = game.settings.get("ddb-importer", "munching-policy-use-compendium-folders");
  const compendiumFoldersInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("compendium-folders");
  if (addToCompendiumFolder && compendiumFoldersInstalled) {
    (0,utils/* munchNote */.ep)(`Checking compendium folders..`, true);
    await (0,compendiumFolders/* createCompendiumFolderStructure */.FT)("monsters");
  }

  let monstersParsed = [];
  let currentMonster = 1;
  const monsterCount = finalMonsters.length;
  (0,utils/* munchNote */.ep)(`Importing ${monsterCount} monsters!`, true);
  for (const monster of finalMonsters) {
    (0,utils/* munchNote */.ep)(`Importing ${monster.name} (${currentMonster}/${monsterCount})`, false, true);
    src_logger/* default.debug */.Z.debug(`Importing ${monster.name}`);
    // eslint-disable-next-line no-await-in-loop
    const munched = await (0,importMonster/* addNPC */.Fx)(monster);
    monstersParsed.push(munched);
    currentMonster += 1;
  }
  (0,utils/* munchNote */.ep)("", false, true);

  if (ids !== null) {
    return Promise.all(monstersParsed);
  }
  return monsterCount;
}

// EXTERNAL MODULE: ./src/lib/DirectoryPicker.js
var DirectoryPicker = __webpack_require__(222);
;// CONCATENATED MODULE: ./src/muncher/races/races.js






const RACE_TEMPLATE = {
  "name": "",
  "type": "feat",
  "data": {
    "description": {
      "value": "",
      "chat": "",
      "unidentified": ""
    },
    "source": "",
  },
  "sort": 2600000,
  "flags": {
    "ddbimporter": {},
  },
  "img": null
};

function buildBase(data) {
  let result = JSON.parse(JSON.stringify(RACE_TEMPLATE));

  result.name = (data.fullName) ? data.fullName : data.name;
  result.data.description.value += `${data.description}\n\n`;

  result.flags.ddbimporter = {
    entityRaceId: data.entityRaceId,
  };

  if (data.moreDetailsUrl) {
    result.flags.ddbimporter['moreDetailsUrl'] = data.moreDetailsUrl;
  }

  result.data.source = src_utils/* default.parseSource */.Z.parseSource(data);

  if (data.isSubRace && data.baseRaceName) result.data.requirements = data.baseRaceName;

  return result;
}


async function buildRace(race, compendiumRacialTraits, compendiumLabel) {
  let result = buildBase(race);

  let avatarUrl;
  let largeAvatarUrl;
  let portraitAvatarUrl;

  if (race.portraitAvatarUrl) {
    portraitAvatarUrl = await (0,muncher_import/* getImagePath */.al)(race.portraitAvatarUrl, "race-portrait", race.fullName);
    result.img = portraitAvatarUrl;
    result.flags.ddbimporter['portraitAvatarUrl'] = race.portraitAvatarUrl;
  }

  if (race.avatarUrl) {
    avatarUrl = await (0,muncher_import/* getImagePath */.al)(race.avatarUrl, "race-avatar", race.fullName);
    result.flags.ddbimporter['avatarUrl'] = race.avatarUrl;
    if (!result.img) {
      result.img = avatarUrl;
    }
  }

  if (race.largeAvatarUrl) {
    largeAvatarUrl = await (0,muncher_import/* getImagePath */.al)(race.largeAvatarUrl, "race-large", race.fullName);
    // eslint-disable-next-line require-atomic-updates
    result.flags.ddbimporter['largeAvatarUrl'] = race.largeAvatarUrl;
    if (!result.img) {
      // eslint-disable-next-line require-atomic-updates
      result.img = largeAvatarUrl;
    }
  }

  const image = (avatarUrl) ? `<img src="${avatarUrl}">\n\n` : (largeAvatarUrl) ? `<img src="${largeAvatarUrl}">\n\n` : "";
  // eslint-disable-next-line require-atomic-updates
  result.data.description.value += image;

  race.racialTraits.forEach((f) => {
    const feature = f.definition;
    const featureMatch = compendiumRacialTraits.find((match) => feature.name === match.name && match.flags.ddbimporter && match.flags.ddbimporter.entityRaceId === feature.entityRaceId);
    const title = (featureMatch) ? `<p><b>${feature.name}</b> @Compendium[${compendiumLabel}.${featureMatch._id}]{${feature.name}}</p>` : `<p><b>${feature.name}</b></p>`;

    result.data.description.value += `${title}\n${feature.description}\n\n`;
  });

  return result;
}

function getRacialTrait(trait, fullName) {
  src_logger/* default.debug */.Z.debug("Race trait build started");

  let result = buildBase(trait);

  result.flags.ddbimporter['spellListIds'] = trait.spellListIds;
  result.flags.ddbimporter['definitionKey'] = trait.definitionKey;
  result.flags.ddbimporter['race'] = fullName;
  result.data.requirements = fullName;

  return result;
}

const NO_TRAITS = [
  "Speed",
  "Ability Score Increase",
  "Size",
  "Feat",
  "Languages",
];

async function getRaces(data) {
  src_logger/* default.debug */.Z.debug("get races started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  let results = [];
  let races = [];
  let racialFeatures = [];

  data.forEach((race) => {
    src_logger/* default.debug */.Z.debug(`${race.fullName} features parsing started...`);
    race.racialTraits.forEach((trait) => {
      src_logger/* default.debug */.Z.debug(`${trait.definition.name} trait starting...`);
      if (!trait.definition.hideInSheet && !NO_TRAITS.includes(trait.definition.name)) {
        const parsedTrait = getRacialTrait(trait.definition, race.fullName);
        racialFeatures.push(parsedTrait);
        results.push({ race: race.fullName, trait: trait.definition.name });
      }
    });
  });

  const fiddledRacialFeatures = await (0,muncher_import/* srdFiddling */.cC)(racialFeatures, "traits");
  (0,utils/* munchNote */.ep)(`Importing ${fiddledRacialFeatures.length} traits!`, true);
  await (0,muncher_import/* updateCompendium */.X)("traits", { traits: fiddledRacialFeatures }, updateBool);

  const compendiumLabel = (0,muncher_import/* getCompendiumLabel */.Eb)("traits");
  const compendium = await game.packs.get(compendiumLabel);
  const index = await compendium.getIndex();
  const firstPassTraits = await index.filter((i) => fiddledRacialFeatures.some((orig) => i.name === orig.name));
  let compendiumRacialTraits = [];

  await Promise.allSettled(firstPassTraits.map(async (feature) => {
    const trait = await compendium.getEntry(feature._id);
    compendiumRacialTraits.push(trait);
  }));

  await Promise.allSettled(data.map(async (race) => {
    src_logger/* default.debug */.Z.debug(`${race.fullName} race parsing started...`);
    const builtRace = await buildRace(race, compendiumRacialTraits, compendiumLabel);
    races.push(builtRace);
  }));

  const fiddledRaces = await (0,muncher_import/* srdFiddling */.cC)(races, "races");
  (0,utils/* munchNote */.ep)(`Importing ${fiddledRaces.length} races!`, true);

  await (0,muncher_import/* updateCompendium */.X)("races", { races: fiddledRaces }, updateBool);

  return results;
}

;// CONCATENATED MODULE: ./src/muncher/races.js
// Main module class




function getRaceData() {
  const cobaltCookie = getCobalt();
  const campaignId = (0,utils/* getCampaignId */.F9)();
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get("ddb-importer", "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/races`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          (0,utils/* download */.LR)(JSON.stringify(data), `races-raw.json`, "application/json");
        }
        if (!data.success) {
          (0,utils/* munchNote */.ep)(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => getRaces(data.data))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

async function parseRaces() {
  const results = await getRaceData();

  // download(JSON.stringify(results), `races-icon.json`, "application/json");

  return results;
}



;// CONCATENATED MODULE: ./src/muncher/feats/feats.js





const FEAT_TEMPLATE = {
  "name": "",
  "type": "feat",
  "data": {
    "description": {
      "value": "",
      "chat": "",
      "unidentified": ""
    },
    "source": "",
  },
  "sort": 2600000,
  "flags": {
    "ddbimporter": {},
  },
  "img": null
};

function feats_buildBase(data) {
  let result = JSON.parse(JSON.stringify(FEAT_TEMPLATE));

  result.name = data.name;
  result.data.description.value += `${data.description}\n\n`;
  result.data.description.chat += `${data.snippet}\n\n`;

  result.flags.ddbimporter = {
    featId: data.id,
  };

  result.flags.ddbimporter['prerequisites'] = data.prerequisites;
  if (data.prerequisites.length > 0) {
    const requirements = data.prerequisites.map((requirement) => requirement.description);
    result.data.requirements = requirements.join(", ");
    result.data.description.value += `<h3>Requirements</h3>\n\n${requirements.join("\n\n")}\n\n`;
  }

  result.data.source = src_utils/* default.parseSource */.Z.parseSource(data);

  return result;
}


async function buildFeat(feat,) {
  let result = feats_buildBase(feat);

  return result;
}


async function getFeats(data) {
  src_logger/* default.debug */.Z.debug("get feats started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  let feats = [];

  data.forEach((feat) => {
    src_logger/* default.debug */.Z.debug(`${feat.name} feat parsing started...`);
    const parsedFeat = buildFeat(feat);
    feats.push(parsedFeat);
  });

  const fiddledFeats = await (0,muncher_import/* srdFiddling */.cC)(feats, "feats");
  const finalFeats = await (0,muncher_import/* daeFiddling */.xh)(fiddledFeats);

  (0,utils/* munchNote */.ep)(`Importing ${finalFeats.length} feats!`, true);
  await (0,muncher_import/* updateCompendium */.X)("feats", { feats: finalFeats }, updateBool);

  return finalFeats;
}

;// CONCATENATED MODULE: ./src/muncher/feats.js
// Main module class




function getFeatData() {
  const cobaltCookie = getCobalt();
  const campaignId = (0,utils/* getCampaignId */.F9)();
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get("ddb-importer", "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/feats`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          (0,utils/* download */.LR)(JSON.stringify(data), `feats-raw.json`, "application/json");
        }
        if (!data.success) {
          (0,utils/* munchNote */.ep)(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => getFeats(data.data))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

async function parseFeats() {
  const results = await getFeatData();

  return results;
}



;// CONCATENATED MODULE: ./src/muncher/classes/shared.js






const CLASS_TEMPLATE = {
  "name": "",
  "type": "feat",
  "data": {
    "description": {
      "value": "",
      "chat": "",
      "unidentified": ""
    },
    "source": "",
  },
  "sort": 2600000,
  "flags": {
    "ddbimporter": {},
  },
  "img": null
};

const shared_NO_TRAITS = [
  "Speed",
  "Ability Score Increase",
  "Ability Score Improvement",
  "Size",
  "Feat",
  "Languages",
  "Hit Points",
  "Proficiencies",
];

const FEATURE_DUP = [
  "Expertise",
  "Fighting Style",
  "Land's Stride",
  "Otherworldly Patron",
  "Pact Magic",
  "Potent Spellcasting",
  "Timeless Body",
  "Unarmored Defense",
  "Circle Spells",
  "Divine Strike",
  "Evasion",
  "Channel Divinity",
  "Expanded Spell List",
  "Oath Spells",
  "Psionic Power",
  "Psychic Blades",
  "Spellcasting",
  "Primal Companion",
  "Domain Spells",
  "Bonus Cantrip",
  "Bonus Cantrips",
  "Bonus Proficiencies",
  "Bonus Proficiency",
  "Extra Attack",
  "Tool Proficiency",
];

function shared_buildBase(data) {
  let result = JSON.parse(JSON.stringify(CLASS_TEMPLATE));
  const updateExisting = game.settings.get("ddb-importer", "munching-policy-update-existing");

  result.name = data.name;
  const tableDescription = (0,table/* generateTable */.p)(data.name, data.description, updateExisting);
  result.data.description.value += `${tableDescription}\n\n`;

  result.flags.ddbimporter = {
    id: data.id,
    data: data,
  };

  if (data.moreDetailsUrl) {
    result.flags.ddbimporter['moreDetailsUrl'] = data.moreDetailsUrl;
  }

  result.data.source = src_utils/* default.parseSource */.Z.parseSource(data);

  return result;
}
function getClassFeature(feature, klass, subClassName = "") {
  src_logger/* default.debug */.Z.debug("Class feature build started");

  let result = shared_buildBase(feature);

  const duplicateFeature = FEATURE_DUP.includes(feature.name);
  result.name = (duplicateFeature) ? `${feature.name} (${klass.name})` : feature.name;

  result.flags.ddbimporter['featureId'] = feature.id;
  result.flags.ddbimporter['requiredLevel'] = feature.requiredLevel;
  result.flags.ddbimporter['prerequisite'] = feature.prerequisite;
  result.flags.ddbimporter['class'] = klass.name;
  result.flags.ddbimporter['classId'] = klass.id;
  result.flags.ddbimporter['subClass'] = subClassName;
  result.data.requirements = klass.name;

  return result;
}

async function buildBaseClass(klass) {
  let result = shared_buildBase(klass);
  src_logger/* default.debug */.Z.debug(`Parsing ${klass.name}`);

  result.type = "class";

  let avatarUrl;
  let largeAvatarUrl;
  let portraitAvatarUrl;

  if (klass.portraitAvatarUrl) {
    portraitAvatarUrl = await (0,muncher_import/* getImagePath */.al)(klass.portraitAvatarUrl, "class-portrait", klass.fullName);
    result.img = portraitAvatarUrl;
    result.flags.ddbimporter['portraitAvatarUrl'] = klass.portraitAvatarUrl;
  }

  if (klass.avatarUrl) {
    avatarUrl = await (0,muncher_import/* getImagePath */.al)(klass.avatarUrl, "class-avatar", klass.fullName);
    result.flags.ddbimporter['avatarUrl'] = klass.avatarUrl;
    if (!result.img) {
      result.img = avatarUrl;
    }
  }

  if (klass.largeAvatarUrl) {
    largeAvatarUrl = await (0,muncher_import/* getImagePath */.al)(klass.largeAvatarUrl, "class-large", klass.fullName);
    // eslint-disable-next-line require-atomic-updates
    result.flags.ddbimporter['largeAvatarUrl'] = klass.largeAvatarUrl;
    if (!result.img) {
      // eslint-disable-next-line require-atomic-updates
      result.img = largeAvatarUrl;
    }
  }

  const image = (avatarUrl) ? `<img class="ddb-class-image" src="${avatarUrl}">\n\n` : `<img class="ddb-class-image" src="${largeAvatarUrl}">\n\n`;

  // eslint-disable-next-line require-atomic-updates
  result.data.description.value += image;

  // eslint-disable-next-line require-atomic-updates
  result.flags.ddbimporter['parentClassId'] = klass.parentClassId;
  // eslint-disable-next-line require-atomic-updates
  result.flags.ddbimporter['hitDice'] = klass.hitDice;
  // eslint-disable-next-line require-atomic-updates
  result.flags.ddbimporter['spellCastingAbilityId'] = klass.spellCastingAbilityId;
  // eslint-disable-next-line require-atomic-updates
  result.flags.ddbimporter['canCastSpells'] = klass.canCastSpells;

  // setup data
  // eslint-disable-next-line require-atomic-updates
  result.data.levels = 1;
  // eslint-disable-next-line require-atomic-updates
  result.data.hitDice = `d${klass.hitDice}`;

  let spellcasting = {};
  if (klass.canCastSpells) {
    const spellProgression = dictionary/* default.spell.progression.find */.Z.spell.progression.find((cls) => cls.name == klass.name);
    const spellCastingAbility = klass.spellCastingAbilityId
      ? dictionary/* default.character.abilities.find */.Z.character.abilities.find((a) => a.id == klass.spellCastingAbilityId).value
      : null;
    if (spellProgression) {
      spellcasting = {
        progression: spellProgression.value,
        ability: spellCastingAbility,
      };
    }
  }
  // eslint-disable-next-line require-atomic-updates
  result.data.spellcasting = spellcasting;

  // this can be used with the add class response
  // const classSkillSubType = `choose-a-${klass.name.toLowerCase()}-skill`;
  // const skillCount = .filter((mod) => mod.subType === classSkillSubType && mod.type === "proficiency"));

  const proficiencyOption = klass.classFeatures.find((feature) =>
    feature.name === "Proficiencies" &&
    feature.requiredLevel === 1
  );

  let dom = new DocumentFragment();
  $.parseHTML(proficiencyOption.description).forEach((element) => {
    dom.appendChild(element);
  });

  // Choose any three
  // Skills: Choose two from Arcana, Animal Handling, Insight, Medicine, Nature, Perception, Religion, and Survival
  const allSkillRegex = /Skills: Choose any (\w+)(.*)($|\.$|\w+:)/;
  const allMatch = dom.textContent.match(allSkillRegex);
  const skillRegex = /Skills: Choose (\w+) from (.*)($|The|\.$|\w+:)/;
  const skillMatch = dom.textContent.match(skillRegex);

  if (allMatch) {
    const skills = dictionary/* default.character.skills.map */.Z.character.skills.map((skill) => skill.name);
    const numberSkills = dictionary/* default.numbers.find */.Z.numbers.find((num) => allMatch[1].toLowerCase() === num.natural);
    // eslint-disable-next-line require-atomic-updates
    result.data.skills = {
      number: numberSkills ? numberSkills.num : 2,
      choices: skills,
      value: [],
    };
  } else if (skillMatch) {
    const skillNames = skillMatch[2].replace('and', ',').split(',').map((skill) => skill.trim());
    const skills = skillNames.filter((name) => dictionary/* default.character.skills.some */.Z.character.skills.some((skill) => skill.label.toLowerCase() === name.toLowerCase()))
    .map((name) => {
      const dictSkill = dictionary/* default.character.skills.find */.Z.character.skills.find((skill) => skill.label.toLowerCase() === name.toLowerCase());
      return dictSkill.name;
    });
    const numberSkills = dictionary/* default.numbers.find */.Z.numbers.find((num) => skillMatch[1].toLowerCase() === num.natural);
    // eslint-disable-next-line require-atomic-updates
    result.data.skills = {
      number: numberSkills ? numberSkills.num : 2,
      choices: skills,
      value: [],
    };
  }

  // "moreDetailsUrl": "/characters/classes/rogue",

  if (klass.equipmentDescription) {
    // eslint-disable-next-line require-atomic-updates
    result.data.description.value += `<p><b>Starting Equipment</b></p>\n${klass.equipmentDescription}\n\n`;
  }

  return result;
}

async function buildClassFeatures(klass, compendiumClassFeatures, compendiumLabel) {
  src_logger/* default.debug */.Z.debug(`Parsing ${klass.name} features`);
  let description = "<h3>Class Features</h3>\n\n";
  let classFeatures = [];

  klass.classFeatures.forEach((feature) => {
    const classFeaturesAdded = classFeatures.some((f) => f === feature.name);

    // sort by level?
    if (!classFeaturesAdded) {
      const featureMatch = compendiumClassFeatures.find((match) => feature.name.trim().toLowerCase() == match.name.trim().toLowerCase() && match.flags.ddbimporter && match.flags.ddbimporter.classId == klass.id);
      const title = (featureMatch) ? `<p><b>${feature.name}</b> @Compendium[${compendiumLabel}.${featureMatch._id}]{${feature.name}}</p>` : `<p><b>${feature.name}</b></p>`;

      // eslint-disable-next-line require-atomic-updates
      description += `${title}\n${feature.description}\n\n`;
      classFeatures.push(feature.name);
    }

  });

  return description;
}

;// CONCATENATED MODULE: ./src/muncher/classes/classes.js






async function buildClass(klass, compendiumClassFeatures, compendiumLabel) {
  let result = await buildBaseClass(klass);
  result.data.description.value += await buildClassFeatures(klass, compendiumClassFeatures, compendiumLabel);
  return result;
}

async function getClasses(data) {
  let results = [];
  src_logger/* default.debug */.Z.debug("get clases started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  let klasses = [];
  let classFeatures = [];

  data.forEach((klass) => {
    src_logger/* default.debug */.Z.debug(`${klass.name} feature parsing started...`);
    klass.classFeatures.forEach((feature) => {
      const existingFeature = classFeatures.some((f) => f.name === feature.name);
      src_logger/* default.debug */.Z.debug(`${feature.name} feature starting...`);
      if (!shared_NO_TRAITS.includes(feature.name) && !existingFeature) {
        const parsedFeature = getClassFeature(feature, klass);
        classFeatures.push(parsedFeature);
        results.push({ class: klass.name, subClass: "", feature: feature.name });
      }
    });
  });

  const fiddledClassFeatures = await (0,muncher_import/* srdFiddling */.cC)(classFeatures, "features");
  (0,utils/* munchNote */.ep)(`Importing ${fiddledClassFeatures.length} features!`, true);
  await (0,muncher_import/* updateCompendium */.X)("features", { features: fiddledClassFeatures }, updateBool);

  const compendiumLabel = (0,muncher_import/* getCompendiumLabel */.Eb)("features");
  const compendium = await game.packs.get(compendiumLabel);
  const index = await compendium.getIndex();
  const firstPassFeatures = await index.filter((i) => fiddledClassFeatures.some((orig) => i.name === orig.name));
  let compendiumClassFeatures = [];

  await Promise.all(firstPassFeatures.map(async (f) => {
    const feature = await compendium.getDocument(f._id);
    compendiumClassFeatures.push(feature.toJSON());
  }));

  await Promise.all(data.map(async (klass) => {
    src_logger/* default.debug */.Z.debug(`${klass.name} class parsing started...`);
    const builtClass = await buildClass(klass, compendiumClassFeatures, compendiumLabel);
    klasses.push(builtClass);
  }));

  const fiddledClasses = await (0,muncher_import/* srdFiddling */.cC)(klasses, "classes");
  (0,utils/* munchNote */.ep)(`Importing ${fiddledClasses.length} classes!`, true);

  await (0,muncher_import/* updateCompendium */.X)("classes", { classes: fiddledClasses }, updateBool);

  // return fiddledClasses.concat(fiddledClassFeatures);
  return results;
}

// EXTERNAL MODULE: ./src/ddbConfig.js
var ddbConfig = __webpack_require__(31);
;// CONCATENATED MODULE: ./src/muncher/classes/subclasses.js







async function buildSubClassBase(klass, subClass) {
  delete klass['_id'];

  let avatarUrl;
  let largeAvatarUrl;
  let portraitAvatarUrl;

  if (subClass.portraitAvatarUrl) {
    portraitAvatarUrl = await (0,muncher_import/* getImagePath */.al)(subClass.portraitAvatarUrl, "class-portrait", subClass.fullName);
    // eslint-disable-next-line require-atomic-updates
    klass.img = portraitAvatarUrl;
    // eslint-disable-next-line require-atomic-updates
    klass.flags.ddbimporter['portraitAvatarUrl'] = subClass.portraitAvatarUrl;
  }

  if (subClass.avatarUrl) {
    avatarUrl = await (0,muncher_import/* getImagePath */.al)(subClass.avatarUrl, "class-avatar", subClass.fullName);
    // eslint-disable-next-line require-atomic-updates
    klass.flags.ddbimporter['avatarUrl'] = subClass.avatarUrl;
    if (!klass.img) {
      // eslint-disable-next-line require-atomic-updates
      klass.img = avatarUrl;
    }
  }

  if (subClass.largeAvatarUrl) {
    largeAvatarUrl = await (0,muncher_import/* getImagePath */.al)(subClass.largeAvatarUrl, "class-large", subClass.fullName);
    // eslint-disable-next-line require-atomic-updates
    klass.flags.ddbimporter['largeAvatarUrl'] = subClass.largeAvatarUrl;
    if (!klass.img) {
      // eslint-disable-next-line require-atomic-updates
      klass.img = largeAvatarUrl;
    }
  }

  // eslint-disable-next-line require-atomic-updates
  klass.flags.ddbimporter['parentClassId'] = subClass.parentClassId;
  // eslint-disable-next-line require-atomic-updates
  klass.flags.ddbimporter['spellCastingAbilityId'] = subClass.spellCastingAbilityId;
  // eslint-disable-next-line require-atomic-updates
  klass.flags.ddbimporter['canCastSpells'] = subClass.canCastSpells;
  // eslint-disable-next-line require-atomic-updates
  klass.flags.ddbimporter['moreDetailsUrl'] = subClass.moreDetailsUrl;

  if (avatarUrl || largeAvatarUrl) {
    const imageMatch = /$<img class="ddb-class-image"(.*)$/;
    const image = (avatarUrl)
      ? `<img class="ddb-class-image" src="${avatarUrl}">\n\n`
      : `<img class="ddb-class-image" src="${largeAvatarUrl}">\n\n`;
    klass.data.description.value.replace(imageMatch, image);
  }

  // eslint-disable-next-line require-atomic-updates
  klass.name += ` (${subClass.name})`;
  // eslint-disable-next-line require-atomic-updates
  klass.data.description.value += `<h3>${subClass.name}</h3>\n${subClass.description}\n\n`;

  // spell caster now?
  // if canCastSpells but now canCastSpells then set to third
  if (klass.data.spellcasting === "" && subClass.canCastSpells) {
    // eslint-disable-next-line require-atomic-updates
    klass.data.spellcasting = "third";
  }

  return klass;

}

async function buildSubClass(klass, subclass, compendiumSubClassFeatures, compendiumLabel) {
  let baseClass = await buildBaseClass(klass.flags.ddbimporter.data);
  let result = await buildSubClassBase(baseClass, subclass);
  result.data.description.value += await buildClassFeatures(subclass, compendiumSubClassFeatures, compendiumLabel);
  return result;
}

async function getSubClasses(data) {
  src_logger/* default.debug */.Z.debug("get subclasses started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  let subClasses = [];
  let classFeatures = [];
  let results = [];

  data.forEach((subClass) => {
    const classMatch = ddbConfig/* DDB_CONFIG.classConfigurations.find */.U.classConfigurations.find((k) => k.id === subClass.parentClassId);
    src_logger/* default.debug */.Z.debug(`${subClass.name} feature parsing started...`);
    subClass.classFeatures.forEach((feature) => {
      const existingFeature = classFeatures.some((f) => f.name === feature.name);
      src_logger/* default.debug */.Z.debug(`${feature.name} feature starting...`);
      if (!shared_NO_TRAITS.includes(feature.name.trim()) && !existingFeature) {
        const parsedFeature = getClassFeature(feature, subClass, subClass.name);
        classFeatures.push(parsedFeature);
        results.push({ class: classMatch.name, subClass: subClass.name, feature: feature.name });
      }
    });
  });

  const fiddledClassFeatures = await (0,muncher_import/* srdFiddling */.cC)(classFeatures, "features");
  (0,utils/* munchNote */.ep)(`Importing ${fiddledClassFeatures.length} features!`, true);
  await (0,muncher_import/* updateCompendium */.X)("features", { features: fiddledClassFeatures }, updateBool);

  const compendiumLabel = (0,muncher_import/* getCompendiumLabel */.Eb)("features");
  const compendium = await game.packs.get(compendiumLabel);
  const index = await compendium.getIndex();
  const firstPassFeatures = await index.filter((i) => fiddledClassFeatures.some((orig) => i.name === orig.name));

  let compendiumClassFeatures = [];

  await Promise.allSettled(firstPassFeatures.map(async (f) => {
    const feature = await compendium.getDocument(f._id);
    compendiumClassFeatures.push(feature.toJSON());
  }));

  // get base class
  const classCompendiumLabel = (0,muncher_import/* getCompendiumLabel */.Eb)("class");
  const classCompendium = await game.packs.get(classCompendiumLabel);
  // const classIndex = await classCompendium.getIndex();
  const content = await classCompendium.getDocuments();

  await Promise.all(data.map(async (subClass) => {
    const classMatch = content.find((i) => i.data.flags.ddbimporter['id'] == subClass.parentClassId);
    const builtClass = await buildSubClass(classMatch.data, subClass, compendiumClassFeatures, compendiumLabel);
    subClasses.push(builtClass);
  }));

  const fiddledClasses = await (0,muncher_import/* srdFiddling */.cC)(subClasses, "classes");
  (0,utils/* munchNote */.ep)(`Importing ${fiddledClasses.length} subclasses!`, true);

  await (0,muncher_import/* updateCompendium */.X)("classes", { classes: fiddledClasses }, updateBool);

  // return fiddledClasses.concat(fiddledClassFeatures);
  return results;
}

;// CONCATENATED MODULE: ./src/muncher/classes/options.js







async function getClassOptions(data, className) {
  src_logger/* default.debug */.Z.debug("get options started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");
  let results = [];

  let classFeatures = [];
  const classMatch = ddbConfig/* DDB_CONFIG.classConfigurations.find */.U.classConfigurations.find((k) => k.name === className);

  const klass = {
    name: className,
    id: classMatch.id,
  };

  data.forEach((feature) => {
    const existingFeature = classFeatures.some((f) => f.name === feature.name);
    src_logger/* default.debug */.Z.debug(`${feature.name} feature starting...`);
    if (!shared_NO_TRAITS.includes(feature.name.trim()) && !existingFeature) {
      const parsedFeature = getClassFeature(feature, klass);
      classFeatures.push(parsedFeature);
      results.push({ class: className, subClass: "", feature: feature.name });
    }
  });

  const fiddledClassFeatures = await (0,muncher_import/* srdFiddling */.cC)(classFeatures, "features");
  (0,utils/* munchNote */.ep)(`Importing ${fiddledClassFeatures.length} options!`, true);
  await (0,muncher_import/* updateCompendium */.X)("features", { features: fiddledClassFeatures }, updateBool);

  // return fiddledClassFeatures;
  return results;
}

;// CONCATENATED MODULE: ./src/muncher/classes.js
// Main module class






function getSubClassesData(className) {
  const cobaltCookie = getCobalt();
  const campaignId = (0,utils/* getCampaignId */.F9)();
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey, className: className };
  const debugJson = game.settings.get("ddb-importer", "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/subclass`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          (0,utils/* download */.LR)(JSON.stringify(data), `subclass-${className}-raw.json`, "application/json");
        }
        if (!data.success) {
          (0,utils/* munchNote */.ep)(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => getSubClasses(data.data))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

function getClassOptionsData(className) {
  const cobaltCookie = getCobalt();
  const campaignId = (0,utils/* getCampaignId */.F9)();
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey, className: className };
  const debugJson = game.settings.get("ddb-importer", "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/v5/classes/options`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          (0,utils/* download */.LR)(JSON.stringify(data), `subclass-${className}-raw.json`, "application/json");
        }
        if (!data.success) {
          (0,utils/* munchNote */.ep)(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => getClassOptions(data.data, className))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

function getClassesData() {
  const cobaltCookie = getCobalt();
  const campaignId = (0,utils/* getCampaignId */.F9)();
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get("ddb-importer", "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/classes`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          (0,utils/* download */.LR)(JSON.stringify(data), `classes-raw.json`, "application/json");
        }
        if (!data.success) {
          (0,utils/* munchNote */.ep)(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => getClasses(data.data))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

async function parseClasses() {
  const classesResults = await getClassesData();

  const subClassResults = await Promise.all([
    getSubClassesData("Cleric"),
    getSubClassesData("Druid"),
    getSubClassesData("Sorcerer"),
    getSubClassesData("Warlock"),
    getSubClassesData("Wizard"),
    getSubClassesData("Paladin"),
    getSubClassesData("Ranger"),
    getSubClassesData("Bard"),
    getSubClassesData("Barbarian"),
    getSubClassesData("Fighter"),
    getSubClassesData("Artificer"),
    getSubClassesData("Rogue"),
    getSubClassesData("Monk"),
    getSubClassesData("Blood Hunter"),
  ]);

  const classOptionsResults = await Promise.all([
    getClassOptionsData("Cleric"),
    getClassOptionsData("Druid"),
    getClassOptionsData("Sorcerer"),
    getClassOptionsData("Warlock"),
    getClassOptionsData("Wizard"),
    getClassOptionsData("Paladin"),
    getClassOptionsData("Ranger"),
    getClassOptionsData("Bard"),
    getClassOptionsData("Barbarian"),
    getClassOptionsData("Fighter"),
    getClassOptionsData("Rogue"),
    getClassOptionsData("Monk"),
    getClassOptionsData("Blood Hunter"),
    getClassOptionsData("Artificer"),
  ]);

  const results = classesResults.concat(subClassResults.flat(), classOptionsResults.flat());

  // download(JSON.stringify(results), `classes-icon.json`, "application/json");

  return results;
}



;// CONCATENATED MODULE: ./src/muncher/frames.js
// Main module class





async function getFrameData() {
  const cobaltCookie = getCobalt();
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const debugJson = game.settings.get("ddb-importer", "debug-json");

  const body = {
    cobalt: cobaltCookie,
    betaKey: betaKey,
  };

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/frames`, {
      method: "POST",
      mode: "cors",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (!data.success) {
          (0,utils/* munchNote */.ep)(`API Failure: ${data.message}`);
          reject(data.message);
        }
        if (debugJson) {
          (0,utils/* download */.LR)(JSON.stringify(data), `frames-raw.json`, "application/json");
        }
        return data;
      })
      .then((data) => {
        (0,utils/* munchNote */.ep)(`Retrieved ${data.data.length} frames, starting parse...`, true, false);
        src_logger/* default.info */.Z.info(`Retrieved ${data.data.length} frames`);
        resolve(data.data);
      })
      .catch((error) => reject(error));
  });
}

async function parseFrames() {
  const frames = await getFrameData();
  src_logger/* default.debug */.Z.debug("Importing frames", frames);

  (0,utils/* munchNote */.ep)(`Fetching DDB Frames`);
  frames.forEach(async (frame) => {
    await (0,muncher_import/* getImagePath */.al)(frame.frameAvatarUrl, 'frame', `DDB ${frame.name}`, true);
  });

  (0,utils/* munchNote */.ep)("");

  return frames.length;
}

;// CONCATENATED MODULE: ./src/muncher/adventure.js




function getVehicleData() {
  const cobaltCookie = getCobalt();
  const campaignId = (0,utils/* getCampaignId */.F9)();
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get("ddb-importer", "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/vehicles`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          (0,utils/* download */.LR)(JSON.stringify(data), `vehicles-raw.json`, "application/json");
        }
        if (!data.success) {
          (0,utils/* munchNote */.ep)(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => resolve(data.data))
      .catch((error) => reject(error));
  });
}


async function getMonsterMap () {
  // ddb://monsters
  const monsterCompendiumLabel = await game.settings.get("ddb-importer", "entity-monster-compendium");
  const monsterCompendium = await game.packs.get(monsterCompendiumLabel);
  const monsterIndices = ["name", "flags.ddbimporter.id"];
  const monsterIndex = await monsterCompendium.getIndex({ fields: monsterIndices });

  const results = monsterIndex
    .filter((monster) => monster.flags?.ddbimporter?.id)
    .map((monster) => {
      return {
        id: monster.flags.ddbimporter.id,
        _id: monster._id,
        compendium: monsterCompendiumLabel,
        name: monster.name,
        documentName: monster.name,
      };
    });

  return Promise.all(results);
}

async function getSpellMap() {
  // ddb://spells
  // mm 2176
  const spellCompendiumLabel = await game.settings.get("ddb-importer", "entity-spell-compendium");
  const spellCompendium = await game.packs.find((pack) => pack.collection === spellCompendiumLabel);
  const spellIndices = ["name", "flags.ddbimporter.definitionId"];
  const spellIndex = await spellCompendium.getIndex({ fields: spellIndices });

  const results = spellIndex
    .filter((spell) => spell.flags?.ddbimporter?.definitionId)
    .map((spell) => {
      return {
        id: spell.flags.ddbimporter.definitionId,
        _id: spell._id,
        compendium: spellCompendiumLabel,
        name: spell.name,
        documentName: spell.name,
      };
    });

  return Promise.all(results);
}

async function getItemMap() {
  // ddb://magicitems
  const itemCompendiumLabel = await game.settings.get("ddb-importer", "entity-item-compendium");
  const itemCompendium = await game.packs.find((pack) => pack.collection === itemCompendiumLabel);
  const itemIndices = ["name", "flags.ddbimporter.definitionId"];
  const itemIndex = await itemCompendium.getIndex({ fields: itemIndices });

  const results = itemIndex
    .filter((item) => item.flags?.ddbimporter?.definitionId)
    .map((item) => {
      return {
        id: item.flags.ddbimporter.definitionId,
        _id: item._id,
        compendium: itemCompendiumLabel,
        name: item.name,
        documentName: item.name,
      };
    });

  return Promise.all(results);
}

async function generateAdventureConfig(full = true) {
  const customProxy = game.settings.get("ddb-importer", "custom-proxy");

  const result = {
    cobalt: getCobalt(),
    campaignId: (0,utils/* getCampaignId */.F9)(),
    generateTokens: true,
    version: game.modules.get("ddb-importer").data.version,
    lookups: {
      monsters: [],
      items: [],
      spells: [],
      skills: [],
      senses: [],
      conditions: [],
      actions: [],
      weaponproperties: [],
      vehicles: [],
    }
  };

  // @Compendium[${compendiumLabel}.${featureMatch._id}]{${feature.name}}

  if (full) {
    result.lookups.monsters = await getMonsterMap();
    result.lookups.spells = await getSpellMap();
    result.lookups.items = await getItemMap();
  }

  const rulesCompendium = "dnd5e.rules";
  const srdCompendium = await game.packs.get(rulesCompendium);
  const srdIndex = await srdCompendium.getIndex();

  const skillEntry = srdIndex.find((i) => i.name === "Using Each Ability");
  result.lookups.skills = ddbConfig/* DDB_CONFIG.abilitySkills.map */.U.abilitySkills.map((skill) => {
    return {
      id: skill.id,
      _id: skillEntry.id,
      name: skill.name,
      compendium: rulesCompendium,
      documentName: skillEntry.name,
    };
  });
  result.lookups.senses = ddbConfig/* DDB_CONFIG.senses.filter */.U.senses.filter((sense) => srdIndex.some((i) => i.name === sense.name))
    .map((sense) => {
      const entry = srdIndex.find((i) => i.name === sense.name);
      return {
        id: sense.id,
        _id: entry.id,
        name: sense.name,
        compendium: rulesCompendium,
        documentName: entry.name,
      };
    });

  result.lookups.conditions = ddbConfig/* DDB_CONFIG.conditions.filter */.U.conditions.filter((condition) => srdIndex.some((i) => i.name.trim() === condition.definition.name.trim()))
    .map((condition) => {
      const entry = srdIndex.find((i) => i.name.trim() === condition.definition.name.trim());
      return {
        id: condition.definition.id,
        _id: entry.id,
        name: condition.definition.name,
        compendium: rulesCompendium,
        slug: condition.definition.slug,
        documentName: entry.name,
      };
    });

  const actionEntry = srdIndex.find((i) => i.name === "Actions in Combat");
  result.lookups.actions = ddbConfig/* DDB_CONFIG.basicActions.map */.U.basicActions.map((action) => {
    return {
      id: action.id,
      _id: actionEntry.id,
      name: action.name,
      compendium: rulesCompendium,
      documentName: actionEntry.name,
    };
  });

  const weaponPropertiesEntry = srdIndex.find((i) => i.name === "Weapons");
  result.lookups.weaponproperties = ddbConfig/* DDB_CONFIG.weaponProperties.map */.U.weaponProperties.map((prop) => {
    return {
      id: prop.id,
      _id: weaponPropertiesEntry.id,
      name: prop.name,
      compendium: rulesCompendium,
      documentName: weaponPropertiesEntry.name,
    };
  });

  // vehicles
  if (!customProxy) {
    const vehicleData = await getVehicleData();

    result.lookups.vehicles = vehicleData.map((v) => {
      return {
        id: v.id,
        url: v.url,
        name: v.name,
      };
    });
  }

  return result;

}

async function downloadAdventureConfig() {
  const fullConfig = game.settings.get("ddb-importer", "adventure-muncher-full-config");
  const result = await generateAdventureConfig(fullConfig);
  (0,utils/* download */.LR)(JSON.stringify(result, null, 4), `adventure-config.json`, "application/json");
  return result;
}

;// CONCATENATED MODULE: ./src/muncher/adventure/common.js




class Helpers {

  /**
   * Imports binary file, by extracting from zip file and uploading to path.
   *
   * @param  {string} path - Path to image within zip file
   * @param  {object} zip - Zip file
   * @returns {string} - Path to file within VTT
   */
  static async importImage(path, zip, adventure, misc = false) {
    try {
      if (path[0] === "*") {
        // this file was flagged as core data, just replace name.
        return path.replace(/\*/g, "");
      } else if (path.startsWith("icons/") || path.startsWith("systems/dnd5e/icons/") || path.startsWith("ddb://")) {
        // these are core icons, ignore
        // or are ddb:// paths that will be replaced by muncher
        return path;
      } else {
        const adventurePath = (adventure.name).replace(/[^a-z0-9]/gi, '_');
        const targetPath = path.replace(/[\\/][^\\/]+$/, '');
        const filename = path.replace(/^.*[\\/]/, '').replace(/\?(.*)/, '');
        const baseUploadPath = misc
          ? game.settings.get("ddb-importer", "adventure-misc-path")
          : game.settings.get("ddb-importer", "adventure-upload-path");
        const parsedBaseUploadPath = DirectoryPicker/* DirectoryPicker.parse */.B.parse(baseUploadPath);
        const uploadPath = misc
         ? `${parsedBaseUploadPath.current}/${targetPath}`
         : `${parsedBaseUploadPath.current}/${adventurePath}/${targetPath}`;

        if (!CONFIG.DDBI.ADVENTURE.TEMPORARY.import[path]) {
          await DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(parsedBaseUploadPath, `${uploadPath}`);
          const img = await zip.file(path).async("uint8array");
          const fileData = new File([img], filename);
          await Helpers.UploadFile(parsedBaseUploadPath.activeSource, `${uploadPath}`, fileData, { bucket: parsedBaseUploadPath.bucket });
          // eslint-disable-next-line require-atomic-updates
          CONFIG.DDBI.ADVENTURE.TEMPORARY.import[path] = true;
        } else {
          src_logger/* default.debug */.Z.debug(`File already imported ${path}`);
        }

        const returnFilePath = misc
          ? `${targetPath}/${filename}`
          : `${adventurePath}/${targetPath}/${filename}`;
        const returnPath = await src_utils/* default.getFileUrl */.Z.getFileUrl(baseUploadPath, returnFilePath);

        return `${returnPath}`;
      }
    } catch (err) {
      src_logger/* default.error */.Z.error(`Error importing image file ${path} : ${err.message}`);
    }

    return path;
  }

  /**
   * Async for each loop
   *
   * @param  {array} array - Array to loop through
   * @param  {function} callback - Function to apply to each array item loop
   */
  static async asyncForEach(array, callback) {
    for (let index = 0; index < array.length; index += 1) {
      // eslint-disable-next-line callback-return, no-await-in-loop
      await callback(array[index], index, array);
    }
  }

  /**
   * Attempts to find a compendium pack by name, if not found, create a new one based on item type
   * @param  {string} type - Type of compendium
   * @param  {string} name - Name of compendium
   * @returns {object} - Compendium pack
   */
  static async getCompendiumPack(type, name) {
    let pack = game.packs.find((p) => {
      return p.metadata.label === name;
    });

    if (!pack) {
      pack = await Compendium.create({ entity: type, label: name }, { keepId: true });
    }

    return pack;
  }

  /**
   * Find an entity by the import key.
   * @param  {string} type - Entity type to search for
   * @param  {string} id - Entity Id
   * @returns {object} - Entity Object Data
   */
  static findEntityByImportId(type, id) {
    return game.data[type].find((item) => item._id === id);
      // item.flags.importid === id
  }

  /**
   * Converts and object into an update object for entity update function
   * @param  {object} newItem - Object data
   * @returns {object} - Entity Update Object
   */
  static buildUpdateData(newItem) {
    let updateData = {};

    for (let key in newItem) {
      const recursiveObject = (itemkey, obj) => {
        for (let objkey in obj) {
          if (typeof obj[objkey] === "object") {
            recursiveObject(`${itemkey}.${objkey}`, obj[objkey]);
          } else if (obj[objkey]) {
            const datakey = `${itemkey}.${objkey}`;
            updateData[datakey] = obj[objkey];
          }
        }
      };

      if (typeof newItem[key] === "object") {
        recursiveObject(key, newItem[key]);
      } else {
        const datakey = `${key}`;
        updateData[datakey] = `${newItem[key]}`;
      }
    }
    return updateData;
  }


  /**
   * Async replace for all matching patterns
   *
   * @param  {string} str - Original string to replace values in
   * @param  {string} regex - regex for matching
   * @param  {function} asyncFn - async function to run on each match
   * @returns {string}
   */
  static async replaceAsync(str, regex, asyncFn) {
    const promises = [];
    str.replace(regex, (match, ...args) => {
        const promise = asyncFn(match, ...args);
        promises.push(promise);
    });
    const data = await Promise.all(promises);
    return str.replace(regex, () => data.shift());
}

  /**
   * Returns the difference between object 1 and 2
   * @param  {object} obj1
   * @param  {object} obj2
   * @returns {object}
   */
  static diff(obj1, obj2) {
    var result = {};
    for (const key in obj1) {
        if (obj2[key] != obj1[key]) result[key] = obj2[key];
        // eslint-disable-next-line valid-typeof
        if (typeof obj2[key] == 'array' && typeof obj1[key] == 'array')
            result[key] = this.diff(obj1[key], obj2[key]);
        if (typeof obj2[key] == 'object' && typeof obj1[key] == 'object')
            result[key] = this.diff(obj1[key], obj2[key]);
    }
    return result;
  }

  /**
   * Read data from a user provided File object
   * @param {File} file           A File object
   * @return {Promise.<String>}   A Promise which resolves to the loaded text data
   */
  static readBlobFromFile(file) {
    const reader = new FileReader();
    return new Promise((resolve, reject) => {
      reader.onload = () => {
        resolve(reader.result);
      };
      reader.onerror = () => {
        reader.abort();
        reject();
      };
      reader.readAsBinaryString(file);
    });
  }

  static async importFolder(parentFolder, folders, adventure, folderList) {
    await this.asyncForEach(folders, async (f) => {
      let folderData = f;

      let newFolder = game.folders.find((folder) => {
        return (folder.data._id === folderData._id || folder.data.flags.importid === folderData._id) && folder.data.type === folderData.type;
      });

      if (!newFolder) {
        if (folderData.parent !== null) {
          folderData.parent = CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[folderData.parent];
        } else if (adventure?.options?.folders) {
            folderData.parent = CONFIG.DDBI.ADVENTURE.TEMPORARY.folders["null"];
          } else {
            folderData.parent = CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[folderData.type];
          }

        newFolder = await Folder.create(folderData, { keepId: true });
        src_logger/* default.debug */.Z.debug(`Created new folder ${newFolder.data._id} with data:`, folderData, newFolder);
      }

      // eslint-disable-next-line require-atomic-updates
      CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[folderData.flags.importid] = newFolder.data._id;

      let childFolders = folderList.filter((folder) => {
        return folder.parent === folderData._id;
      });

      if (childFolders.length > 0) {
        await this.importFolder(newFolder, childFolders, adventure, folderList);
      }
    });
  }

  /**
   * Replaces matchAll as it's not yet available in Electron App
   * @param   {string} regex  RegEx to use
   * @param   {string} string String to match on
   * @returns {Array}
   */
  static reMatchAll(regexp, string) {
    const matches = string.match(new RegExp(regexp, "gm"));
    if (matches) {
        let start = 0;
        return matches.map((group0) => {
            const match = group0.match(regexp);
            match.index = string.indexOf(group0, start);
            start = match.index;
            return match;
        });
    }
    return matches;
  }

  /**
   * Uploads a file to Foundry without the UI Notification
   * @param  {string} source
   * @param  {string} path
   * @param  {blog} file
   * @param  {object} options
   */
  static async UploadFile(source, path, file, options) {
    if (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge) {
      return Helpers.ForgeUploadFile(path, file);
    }

    const fd = new FormData();
    fd.set("source", source);
    fd.set("target", path);
    fd.set("upload", file);
    Object.entries(options).forEach((o) => fd.set(...o));

    const request = await fetch(FilePicker.uploadURL, { method: "POST", body: fd });
    if (request.status === 413) {
      return ui.notifications.error(game.i18n.localize("FILES.ErrorTooLarge"));
    } else if (request.status !== 200) {
      return ui.notifications.error(game.i18n.localize("FILES.ErrorSomethingWrong"));
    }
    return undefined;
  }

  /**
   * Uploads a file to Forge Asset Library without the UI Notification
   * @param  {string} source
   * @param  {string} path
   * @param  {blog} file
   * @param  {object} options
   */
  static async ForgeUploadFile(path, file) {
    const fd = new FormData();
    fd.append("file", file);
    fd.append("path", `${path}/${file.name}`);

    const response = await ForgeAPI.call("assets/upload", fd);
    if (!response || response.error) {
      ui.notifications.error(response ? response.error : "An unknown error occured accessing The Forge API");
      return false;
    } else {
      return { path: response.url };
    }
  }

  /**
   * Browse files using FilePicker
   * @param  {string} source
   * @param  {string} target
   * @param  {object} options={}
   */
  static async BrowseFiles(source, target, options = {}) {
    if (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge) {
      if (target.startsWith(ForgeVTT.ASSETS_LIBRARY_URL_PREFIX)) source = "forgevtt";

      if (source === "forgevtt") {
        return Helpers.BrowseForgeFiles(source, target, options);
      }
    }

    return FilePicker.browse(source, target, options);
  }

  /**
   * Browse files using Forge API
   * @param  {string} source
   * @param  {string} target
   * @param  {object} options={}
   */
  static async BrowseForgeFiles(source, target, options = {}) {
    if (target.startsWith(ForgeVTT.ASSETS_LIBRARY_URL_PREFIX)) {
      if (options.wildcard)
          options.wildcard = target;
      target = target.slice(ForgeVTT.ASSETS_LIBRARY_URL_PREFIX.length);
      target = target.split("/").slice(1, -1).join("/"); // Remove userid from url to get target path
    }

    const response = await ForgeAPI.call('assets/browse', { path: decodeURIComponent(target), options });
    if (!response || response.error) {
        ui.notifications.error(response ? response.error : "An unknown error occured accessing The Forge API");
        return { target, dirs: [], files: [], gridSize: null, private: false, privateDirs: [], extensions: options.extensions };
    }
    // Should be decodeURIComponent but FilePicker's _onPick needs to do encodeURIComponent too, but on each separate path.
    response.target = decodeURI(response.folder);
    delete response.folder;
    response.dirs = response.dirs.map((d) => d.path.slice(0, -1));
    response.files = response.files.map((f) => f.url);
    // 0.5.6 specific
    response.private = true;
    response.privateDirs = [];
    response.gridSize = null;
    response.extensions = options.extensions;
    return response;
  }

}

;// CONCATENATED MODULE: ./src/muncher/adventure/import.js











const COMPENDIUM_MAP = {
  "spells": "spells",
  "magicitems": "items",
  "weapons": "items",
  "armor": "items",
  "adventuring-gear": "items",
  "monsters": "monsters",
};

const DDB_MAP = {
  "spells": "spells",
  "magicitems": "magic-items",
  "weapons": "equipment",
  "armor": "equipment",
  "adventuring-gear": "equipment",
  "monsters": "monsters",
};

class AdventureMunch extends FormApplication {
  /** @override */
  constructor(object = {}, options = {}) {
    super(object, options);
    this._itemsToRevisit = [];
    const importPathData = game.settings.get("ddb-importer", "adventure-import-path");
    this._importPathData = DirectoryPicker/* DirectoryPicker.parse */.B.parse(importPathData);
  }

  /** @override */
  static get defaultOptions() {
    this.pattern = /(@[a-z]*)(\[)([a-z0-9]*|[a-z0-9.]*)(\])(\{)(.*?)(\})/gmi;
    this.altpattern = /((data-entity)=\\?["']?([a-zA-Z]*)\\?["']?|(data-pack)=\\?["']?([[\S.]*)\\?["']?) data-id=\\?["']?([a-zA-Z0-9]*)\\?["']?.*?>(.*?)<\/a>/gmi;

    return mergeObject(super.defaultOptions, {
      id: "ddb-adventure-import",
      classes: ["ddb-adventure-import"],
      title: "Adventure Munch",
      template: "modules/ddb-importer/handlebars/adventure/import.hbs",
      width: 350,
    });
  }

  /** @override */
  // eslint-disable-next-line class-methods-use-this
  async getData() {
    let data;
    let files = [];

    try {
      // const parsedDirectory = DirectoryPicker.parse(this._importPathData);
      const verifiedDirectory = await DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(this._importPathData);
      if (verifiedDirectory) {
        const options = { bucket: this._importPathData.bucket, extensions: [".fvttadv", ".FVTTADV", ".zip"], wildcard: false };
        data = await Helpers.BrowseFiles(this._importPathData.activeSource, this._importPathData.current, options);
        files = data.files.map((file) => {
          const filename = decodeURIComponent(file).replace(/^.*[\\/]/, '');

          return { path: decodeURIComponent(file), name: filename };
        });
      }
    } catch (err) {
      src_logger/* default.error */.Z.error(err);
      src_logger/* default.warn */.Z.warn(`Unable to verify import path, this may be due to permissions on the server. You may be able to ignore this message.`);
    }

    return {
      data,
      files,
      cssClass: "ddb-importer-window"
    };

  }

  static async _createFolders(adventure, folders) {
    if (folders) {
      const maintainFolders = adventure?.options?.folders;
      let itemFolder = null;
      if (!maintainFolders) {
        const importTypes = ["Scene", "Actor", "Item", "JournalEntry", "RollTable"];
        await Helpers.asyncForEach(importTypes, async (importType) => {
          itemFolder = game.folders.find((folder) => {
            return folder.data.name === adventure.name && folder.data.type === importType;
          });

          if (!itemFolder) {
            src_logger/* default.debug */.Z.debug(`Creating folder ${adventure.name} - ${importType}`);

            // eslint-disable-next-line require-atomic-updates
            itemFolder = await Folder.create({
              color: adventure.folderColour ? adventure.folderColour : "#FF0000",
              name: adventure.name,
              parent: null,
              type: importType
            }, { keepId: true });
          }

          CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[importType] = itemFolder.data._id;
        });
      } else {
        CONFIG.DDBI.ADVENTURE.TEMPORARY.folders["null"] = null;
        CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups = null;
      }

      // the folder list could be out of order, we need to create all folders with parent null first
      const firstLevelFolders = folders.filter((folder) => folder.parent === null);
      await Helpers.importFolder(itemFolder, firstLevelFolders, adventure, folders);
    }
  }

  /** @override */
  activateListeners(html) {
    super.activateListeners(html);

    html.find(".dialog-button").on("click", this._dialogButton.bind(this));
  }

  // eslint-disable-next-line complexity
  async _dialogButton(event) {
    event.preventDefault();
    event.stopPropagation();
    const a = event.currentTarget;
    const action = a.dataset.button;

    if (action === "import") {
      let importFilename;
      try {
        $(".import-progress").toggleClass("import-hidden");
        $(".ddb-overlay").toggleClass("import-invalid");

        const form = $("form.ddb-importer-window")[0];

        let zip;
        if (form.data.files.length) {
          importFilename = form.data.files[0].name;
          zip = await Helpers.readBlobFromFile(form.data.files[0]).then(JSZip.loadAsync);
        } else {
          const selectedFile = $("#import-file").val();
          importFilename = selectedFile;
          zip = await fetch(`/${selectedFile}`)
            .then((response) => {
                if (response.status === 200 || response.status === 0) {
                    return Promise.resolve(response.blob());
                } else {
                    return Promise.reject(new Error(response.statusText));
                }
            })
            .then(JSZip.loadAsync);
        }

        const adventure = JSON.parse(await zip.file("adventure.json").async("text"));
        let folders;
        try {
          folders = JSON.parse(await zip.file("folders.json").async("text"));
        } catch (err) {
          src_logger/* default.warn */.Z.warn(`Folder structure file not found.`);
        }

        if (adventure.system !== game.data.system.data.name) {
          ui.notifications.error(`Invalid sysytem for Adventure ${adventure.name}.  Expects ${adventure.system}`);
          throw new Error(`Invalid sysytem for Adventure ${adventure.name}.  Expects ${adventure.system}`);
        }

        CONFIG.DDBI.ADVENTURE.TEMPORARY = {
          folders: {},
          import: {},
          actors: {},
          sceneTokens: {},
        };

        await AdventureMunch._createFolders(adventure, folders);

        if (adventure.required?.monsters && adventure.required.monsters.length > 0) {
          src_logger/* default.debug */.Z.debug(`${adventure.name} - monsters required`, adventure.required.monsters);
          AdventureMunch._progressNote(`Checking for missing monsters from DDB`);
          await AdventureMunch._checkForMissingDocuments("monster", adventure.required.monsters);
        }
        if (adventure.required?.spells && adventure.required.spells.length > 0) {
          src_logger/* default.debug */.Z.debug(`${adventure.name} - spells required`, adventure.required.spells);
          AdventureMunch._progressNote(`Checking for missing spells from DDB`);
          await AdventureMunch._checkForMissingDocuments("spell", adventure.required.spells);
        }
        if (adventure.required?.items && adventure.required.items.length > 0) {
          src_logger/* default.debug */.Z.debug(`${adventure.name} - items required`, adventure.required.items);
          AdventureMunch._progressNote(`Checking for missing items from DDB`);
          await AdventureMunch._checkForMissingDocuments("item", adventure.required.items);
        }

        // now we have imported all missing data, generate the lookup data
        CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups = await generateAdventureConfig();
        src_logger/* default.debug */.Z.debug("Lookups loaded", CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups.lookups);

        if (AdventureMunch._folderExists("scene", zip)) {
          src_logger/* default.debug */.Z.debug(`${adventure.name} - Loading scenes`);
          await this._checkForDataUpdates("scene", zip, adventure);
        }
        if (AdventureMunch._folderExists("actor", zip)) {
          src_logger/* default.debug */.Z.debug(`${adventure.name} - Loading actors`);
          await this._importFile("actor", zip, adventure);
        }
        if (AdventureMunch._folderExists("item", zip)) {
          src_logger/* default.debug */.Z.debug(`${adventure.name} - Loading item`);
          await this._importFile("item", zip, adventure);
        }
        if (AdventureMunch._folderExists("journal", zip)) {
          src_logger/* default.debug */.Z.debug(`${adventure.name} - Loading journal`);
          await this._importFile("journal", zip, adventure);
        }
        if (AdventureMunch._folderExists("table", zip)) {
          src_logger/* default.debug */.Z.debug(`${adventure.name} - Loading table`);
          await this._importFile("table", zip, adventure);
        }
        if (AdventureMunch._folderExists("playlist", zip)) {
          src_logger/* default.debug */.Z.debug(`${adventure.name} - Loading playlist`);
          await this._importFile("playlist", zip, adventure);
        }
        if (AdventureMunch._folderExists("compendium", zip)) {
          src_logger/* default.debug */.Z.debug(`${adventure.name} - Loading compendium`);
          await this._importCompendium("compendium", zip, adventure);
        }
        if (AdventureMunch._folderExists("macro", zip)) {
          src_logger/* default.debug */.Z.debug(`${adventure.name} - Loading macro`);
          await this._importFile("macro", zip, adventure);
        }

        try {
          if (this._itemsToRevisit.length > 0) {
            let totalCount = this._itemsToRevisit.length;
            let currentCount = 0;

            await Helpers.asyncForEach(this._itemsToRevisit, async (item) => {
              const toTimer = setTimeout(() => {
                src_logger/* default.warn */.Z.warn(`Reference update timed out.`);
                const title = `Successful Import of ${adventure.name}`;
                new Dialog(
                  {
                    title: title,
                    content: {
                      adventure
                    },
                    buttons: {
                      two: {
                        label: "Ok",
                      },
                    },
                  },
                  {
                    classes: ["dialog", "adventure-import-export"],
                    template: "modules/ddb-importer/handlebars/adventure/import-complete.hbs",
                  }
                ).render(true);
                this.close();
              }, 60000);
              try {
                const obj = await fromUuid(item);
                // let rawData;
                let updatedData = {};
                switch (obj.documentName) {
                  case "Scene": {
                    const scene = JSON.parse(JSON.stringify(obj.data));
                    // this is a scene we need to update links to all items
                    src_logger/* default.info */.Z.info(`Updating ${scene.name}, ${scene.tokens.length} tokens`);
                    await Helpers.asyncForEach(scene.tokens, async (token) => {
                      if (token.actorId) {
                        const sceneToken = scene.flags.ddb.tokens.find((t) => t._id === token._id);
                        delete sceneToken.scale;
                        const worldActor = game.actors.get(token.actorId);
                        if (worldActor) {
                          const tokenData = await worldActor.getTokenData();
                          delete tokenData.y;
                          delete tokenData.x;
                          const jsonTokenData = JSON.parse(JSON.stringify(tokenData));
                          const updateData = mergeObject(jsonTokenData, sceneToken);
                          src_logger/* default.debug */.Z.debug(`${token.name} token data for id ${token.actorId}`, updateData);
                          await obj.updateEmbeddedDocuments("Token", [updateData], { keepId: true });
                        }
                      }
                    });

                    // In 0.8.x the thumbs don't seem to be generated.
                    // This code would embed the thumbnail.
                    // Consider writing this out.
                    if (!obj.data.thumb) {
                      const thumbData = await obj.createThumbnail();
                      updatedData["thumb"] = thumbData.thumb;
                    }
                    await obj.update(updatedData);
                    break;
                  }
                  // no default
                }
              } catch (err) {
                src_logger/* default.warn */.Z.warn(`Error updating references for object ${item}`, err);
              }
              currentCount += 1;
              AdventureMunch._updateProgress(totalCount, currentCount, "References");
              clearTimeout(toTimer);
            });
          }
        } catch (err) {
          // eslint-disable-next-line no-undef
          src_logger/* default.warn */.Z.warn(`Error during reference update for object ${item}`, err);
        }

        $(".ddb-overlay").toggleClass("import-invalid");

        const title = `Successful Import of ${adventure.name}`;
        new Dialog(
          {
            title: title,
            content: {
              adventure
            },
            buttons: {
              two: {
                label: "Ok",
              },
            },
          },
          {
            classes: ["dialog", "adventure-import-export"],
            template: "modules/ddb-importer/handlebars/adventure/import-complete.hbs",
          }
        ).render(true);

        // eslint-disable-next-line require-atomic-updates
        CONFIG.DDBI.ADVENTURE.TEMPORARY = {};
        this.close();
      } catch (err) {
        $(".ddb-overlay").toggleClass("import-invalid");
        ui.notifications.error(`There was an error importing ${importFilename}`);
        src_logger/* default.error */.Z.error(`Error importing file ${importFilename}`, err);
        this.close();
      }
    }
  }

  static _folderExists(folder, zip) {
    const files = Object.values(zip.files).filter((file) => {
      return file.dir && file.name.toLowerCase().includes(folder);
    });

    return files.length > 0;
  }

  static _getFiles(folder, zip) {
    const files = Object.values(zip.files).filter((file) => {
      return !file.dir && file.name.split('.').pop() === 'json' && file.name.includes(`${folder}/`);
    });

    return files;
  }

  async _importCompendium(type, zip, adventure) {
    let totalCount = 0;
    let currentCount = 0;
    const typeName = type[0].toUpperCase() + type.slice(1);
    const dataFiles = AdventureMunch._getFiles(type, zip);
    src_logger/* default.info */.Z.info(`Importing ${adventure.name} - ${typeName} (${dataFiles.length} items)`);
    totalCount = dataFiles.length;

    await Helpers.asyncForEach(dataFiles, async (file) => {
      const rawData = await zip.file(file.name).async("text");
      const data = JSON.parse(rawData);

      let pack = await Helpers.getCompendiumPack(data.info.entity, data.info.label);
      await pack.getIndex();

      totalCount += data.items.length;
      await Helpers.asyncForEach(data.items, async (item) => {
        let obj;
        let entry = pack.index.find((e) => e.name === item.name);

        item.flags.importid = item._id;

        if (item.img) {
          // eslint-disable-next-line require-atomic-updates
          item.img = await Helpers.importImage(item.img, zip, adventure);
        }
        if (item.thumb) {
          // eslint-disable-next-line require-atomic-updates
          item.thumb = await Helpers.importImage(item.thumb, zip, adventure);
        }
        if (item?.token?.img) {
          // eslint-disable-next-line require-atomic-updates
          item.token.img = await Helpers.importImage(item.token.img, zip, adventure);
        }

        if (item?.items?.length) {
          await Helpers.asyncForEach(data.items, async (i) => {
            if (i.img) {
              // eslint-disable-next-line require-atomic-updates
              i.img = await Helpers.importImage(i.img, zip, adventure);
            }
          });
        }

        switch (data.info.entity) {
          case "Item":
            obj = new Item(item, { temporary: true });
            break;
          case "Actor":
            obj = new Actor(item, { temporary: true });
            break;
          case "Scene":
            obj = new Scene(item, { temporary: true });
            break;
          case "JournalEntry":
            obj = new JournalEntry(item, { temporary: true });
            break;
          case "Macro":
            obj = new Macro(item, { temporary: true });
            break;
          case "RollTable":
            await Helpers.asyncForEach(item.results, async (result) => {
              // eslint-disable-next-line require-atomic-updates
              result.img = await Helpers.importImage(result.img, zip, adventure);
            });
            obj = new RollTable(item, { temporary: true });
            break;
          case "Playlist":
            await Helpers.asyncForEach(item.sounds, async (sound) => {
              // eslint-disable-next-line require-atomic-updates
              sound.path = await Helpers.importImage(sound.path, zip, adventure);
            });
            obj = new Playlist(item, { temporary: true });
            break;
          // no default
        }

        if (!entry) {
          let compendiumItem = await pack.importDocument(obj);

          if (JSON.stringify(item).match(this.pattern) || JSON.stringify(item).match(this.altpattern)) {
            this._itemsToRevisit.push(`Compendium.${pack.metadata.package}.${pack.metadata.name}.${compendiumItem.data._id}`);
          }
        }
        currentCount += 1;
        AdventureMunch._updateProgress(totalCount, currentCount, typeName);
      });
      currentCount += 1;
      AdventureMunch._updateProgress(totalCount, currentCount, typeName);
    });
  }

  // import a scene file
  async _importRenderedSceneFile(adventure, typeName, data, zip, needRevisit, overwriteIds, overwriteEntity) {
    if (!Helpers.findEntityByImportId("scenes", data._id) || overwriteEntity) {
      await Helpers.asyncForEach(data.tokens, async (token) => {
        // eslint-disable-next-line require-atomic-updates
        if (token.img) token.img = await Helpers.importImage(token.img, zip, adventure);
      });

      await Helpers.asyncForEach(data.sounds, async (sound) => {
        // eslint-disable-next-line require-atomic-updates
        sound.path = await Helpers.importImage(sound.path, zip, adventure);
      });

      await Helpers.asyncForEach(data.notes, async (note) => {
        // eslint-disable-next-line require-atomic-updates
        note.icon = await Helpers.importImage(note.icon, zip, adventure, true);
      });

      await Helpers.asyncForEach(data.tiles, async (tile) => {
        // eslint-disable-next-line require-atomic-updates
        tile.img = await Helpers.importImage(tile.img, zip, adventure);
      });

      if (overwriteEntity) await Scene.delete([data._id]);
      const scene = await Scene.create(data, { keepId: true });
      this._itemsToRevisit.push(`Scene.${scene.data._id}`);
    }
  }

  async _importRenderedFile(adventure, typeName, data, zip, needRevisit, overwriteIds) {
    const overwriteEntity = overwriteIds.includes(data._id);
    switch (typeName) {
      case "Scene": {
        await this._importRenderedSceneFile(adventure, typeName, data, zip, needRevisit, overwriteIds, overwriteEntity);
        break;
      }
      case "Actor":
        if (!Helpers.findEntityByImportId("actors", data._id)) {
          let actor = await Actor.create(data, { keepId: true });
          await actor.update({ [`data.token.actorId`]: actor.data._id });
          if (needRevisit) {
            this._itemsToRevisit.push(`Actor.${actor.data._id}`);
          }
        }
      break;
      case "Item":
        if (!Helpers.findEntityByImportId("items", data._id)) {
          let item = await Item.create(data, { keepId: true });
          if (needRevisit) {
            this._itemsToRevisit.push(`Item.${item.data._id}`);
          }
        }
      break;
      case "JournalEntry":
        if (!Helpers.findEntityByImportId("journal", data._id)) {
          let journal = await JournalEntry.create(data, { keepId: true });
          if (needRevisit) {
            this._itemsToRevisit.push(`JournalEntry.${journal.data._id}`);
          }
        }
      break;
      case "RollTable":
        if (!Helpers.findEntityByImportId("tables", data._id)) {
          let rolltable = await RollTable.create(data, { keepId: true });
          if (needRevisit) {
            this._itemsToRevisit.push(`RollTable.${rolltable.data._id}`);
          }
        }
      break;
      case "Playlist":
        if (!Helpers.findEntityByImportId("playlists", data._id)) {
          data.name = `${adventure.name}.${data.name}`;
          await Playlist.create(data, { keepId: true });
        }
      break;
      case "Macro":
        if (!Helpers.findEntityByImportId("macros", data._id)) {
          let macro = await Macro.create(data, { keepId: true });
          if (needRevisit) {
            this._itemsToRevisit.push(`Macro.${macro.data._id}`);
          }
        }
      break;
      // no default
    }
  }

  static async _loadMissingDocuments(type, docIds) {
    return new Promise((resolve) => {
      if (docIds && docIds.length > 0) {
        src_logger/* default.debug */.Z.debug(`Importing missing ${type}s from DDB`, docIds);
        AdventureMunch._progressNote(`Importing ${docIds.length} missing ${type}s from DDB`);
        switch (type) {
          case "item":
            resolve(parseItems(docIds));
            break;
          case "monster": {
            const tier = game.settings.get("ddb-importer", "patreon-tier");
            const tiers = (0,utils/* getPatreonTiers */.A1)(tier);
            if (tiers.all) {

              resolve(parseCritters(docIds));
            } else {
              resolve([]);
            }
            break;
          }
          case "spell":
            resolve(parseSpells(docIds));
            break;
          // no default
        }
      } else {
        resolve([]);
      }
    });
  }

  static async _getCompendiumIndex(type) {
    return new Promise((resolve) => {
      const compendiumLabel = game.settings.get("ddb-importer", `entity-${type}-compendium`);
      const compendium = game.packs.get(compendiumLabel);
      const fields = (type === "monster")
        ? ["flags.ddbimporter.id"]
        : ["flags.ddbimporter.definitionId"];

      const compendiumIndex = compendium.getIndex({ fields: fields });
      resolve(compendiumIndex);
    });
  }

  static async _checkForMissingDocuments(type, ids) {
    const index = await AdventureMunch._getCompendiumIndex(type);

    return new Promise((resolve) => {
      const missingIds = ids.filter((id) => {
        switch (type) {
          case "monster":
            return !index.some((i) => i.flags?.ddbimporter?.id && String(i.flags.ddbimporter.id) == id);
          case "spell":
          case "item":
            return !index.some((i) => i.flags?.ddbimporter?.definitionId && String(i.flags.ddbimporter.definitionId) == id);
          // no default
        }
        return false;
      });
      const missingDocuments = AdventureMunch._loadMissingDocuments(type, missingIds);
      resolve(missingDocuments);
    });
  }

  static async _linkExistingActorTokens(tokens) {
    const monsterIndex = await AdventureMunch._getCompendiumIndex("monster");

    const newTokens = tokens.map((token) => {
      const monsterHit = monsterIndex.find((monster) =>
        monster.flags?.ddbimporter?.id && token.flags.ddbActorFlags?.id &&
        monster.flags.ddbimporter.id === token.flags.ddbActorFlags.id);
      if (monsterHit) {
        token.flags.compendiumActorId = monsterHit._id;
      }
      return token;
    });

    return newTokens;
  }

  static _foundryCompendiumReplace(text) {
    // replace the ddb:// entries with known compendium look ups if we have them
    // ddb://spells
    // ddb://magicitems || weapons || adventuring-gear || armor
    // ddb://monsters

    let doc = src_utils/* default.htmlToDoc */.Z.htmlToDoc(text);

    const lookups = CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups.lookups;

    for (const lookupKey in COMPENDIUM_MAP) {
      const compendiumLinks = doc.querySelectorAll(`a[href*="ddb://${lookupKey}/"]`);
      src_logger/* default.debug */.Z.debug(`replacing ${lookupKey} references`, compendiumLinks);

      const lookupRegExp = new RegExp(`ddb://${lookupKey}/([0-9]*)`);
      compendiumLinks.forEach((node) => {
        const lookupMatch = node.outerHTML.match(lookupRegExp);
        const lookupValue = lookups[COMPENDIUM_MAP[lookupKey]];

        if (lookupValue) {
          const lookupEntry = lookupValue.find((e) => e.id == lookupMatch[1]);
          if (lookupEntry) {
            const documentRef = lookupEntry.documentName ? lookupEntry.documentName : lookupEntry._id;
            doc.body.innerHTML = doc.body.innerHTML.replace(node.outerHTML, `@Compendium[${lookupEntry.compendium}.${documentRef}]{${node.textContent}}`);
          } else {
            src_logger/* default.warn */.Z.warn(`NO Lookup Compendium Entry for ${node.outerHTML}`);
          }
        }
      });
    }

    // vehicles - not yet handled, links to DDB
    const compendiumLinks = doc.querySelectorAll("a[href*=\"ddb://vehicles/\"]");
    const lookupRegExp = /ddb:\/\/vehicles\/([0-9]*)/g;
    compendiumLinks.forEach((node) => {
      const target = node.outerHTML;
      const lookupMatch = node.outerHTML.match(lookupRegExp);
      const lookupValue = lookups["vehicles"];
      if (lookupMatch) {
        const lookupEntry = lookupValue.find((e) => e.id == lookupMatch[1]);
        if (lookupEntry) {
          node.setAttribute("href", `https://www.dndbeyond.com${lookupEntry.url}`);
          doc.body.innerHTML = doc.body.innerHTML.replace(target, node.outerHTML);
        } else {
          src_logger/* default.warn */.Z.warn(`NO Vehicle Lookup Entry for ${node.outerHTML}`);
        }
      } else {
        src_logger/* default.warn */.Z.warn(`NO Vehicle Lookup Match for ${node.outerHTML}`);
      }
    });

    // final replace in case of failure
    // there is a chance that the adventure references items or monsters we don't have access to
    // in this case attempt to link to DDB instead of compendium doc
    for (const lookupKey in COMPENDIUM_MAP) {
      const compendiumLinks = doc.querySelectorAll(`a[href*="ddb://${lookupKey}/"]`);
      src_logger/* default.debug */.Z.debug(`final replace for missing ${lookupKey} references`, compendiumLinks);

      compendiumLinks.forEach((node) => {
        const target = node.outerHTML;
        const ddbStub = DDB_MAP[lookupKey];
        const ddbNameGuess = node.textContent.toLowerCase().replace(" ", "-").replace(/[^0-9a-z-]/gi, '');
        src_logger/* default.warn */.Z.warn(`No Compendium Entry for ${node.outerHTML} attempting to guess a link to DDB`);

        node.setAttribute("href", `https://www.dndbeyond.com/${ddbStub}/${ddbNameGuess}`);
        doc.body.innerHTML = doc.body.innerHTML.replace(target, node.outerHTML);
      });
    }

    return doc.body.innerHTML;
  }

  static async _linkDDBActors(tokens) {
    const linkedExistingTokens = await AdventureMunch._linkExistingActorTokens(tokens);
    const newTokens = linkedExistingTokens
      .filter((token) => token.flags.ddbActorFlags?.id && token.flags.compendiumActorId);

    return Promise.all(newTokens);
  }

  static async _generateTokenActors(scene) {
    const monsterCompendium = await (0,importMonster/* checkMonsterCompendium */.eX)();

    const tokens = await AdventureMunch._linkDDBActors(scene.tokens);

    const neededActors = tokens
      .map((token) => {
        return { name: token.name, ddbId: token.flags.ddbActorFlags.id, actorId: token.actorId, compendiumId: token.flags.compendiumActorId, folderId: token.flags.actorFolderId };
      })
      .filter((obj, pos, arr) => {
        // we only need to create 1 actor per actorId
        return arr.map((mapObj) => mapObj["actorId"]).indexOf(obj["actorId"]) === pos;
      });

    src_logger/* default.debug */.Z.debug("Trying to import actors from compendium", neededActors);
    await Helpers.asyncForEach(neededActors, async (actor) => {
      let worldActor = game.actors.get(actor.actorId);
      if (!worldActor) {
        src_logger/* default.info */.Z.info(`Importing actor ${actor.name} with DDB ID ${actor.ddbId} from ${monsterCompendium.metadata.name} with id ${actor.compendiumId}`);
        try {
          worldActor = await game.actors.importFromCompendium(monsterCompendium, actor.compendiumId, { _id: actor.actorId, folder: actor.folderId }, { keepId: true });
        } catch (err) {
          src_logger/* default.error */.Z.error(err);
          src_logger/* default.warn */.Z.warn(`Unable to import actor ${actor.name} with id ${actor.compendiumId} from DDB Compendium`);
          src_logger/* default.debug */.Z.debug(`Failed on: game.actors.importFromCompendium(monsterCompendium, "${actor.compendiumId}", { _id: "${actor.actorId}", folder: "${actor.folderId}" }, { keepId: true });`);
        }
      }
    });

    src_logger/* default.debug */.Z.debug("Actors transferred from compendium to world.");

  }

  static getImportType(type) {
    const typeName = type[0].toUpperCase() + type.slice(1);
    let importType = typeName;

    switch (type) {
      case "journal":
        importType = "JournalEntry";
        break;
      case "table":
        importType = "RollTable";
        break;
      default:
        importType = typeName;
        break;
    }

    return importType;
  }

  // check the document for version data and for update info to see if we can replace it
  static _extractDocumentVersionData(newDoc, existingDoc, ddbIVersion) {
    // do we have versioned metadata?
    if (newDoc?.flags?.ddb?.versions?.ddbMetaData?.lastUpdate) {
      // check old data, it might not exist
      const oldDDBMetaDataVersions = existingDoc.data?.flags?.ddb?.versions?.ddbMetaData?.lastUpdate
        ? existingDoc.data.flags.ddb.versions.ddbMetaData
        : {
          lastUpdate: "0.0.1",
          drawings: "0.0.1",
          notes: "0.0.1",
          tokens: "0.0.1",
          walls: "0.0.1",
          lights: "0.0.1",
        };
      const oldDDBImporterVersion = existingDoc.data?.flags?.ddb?.versions?.ddbImporter
      ? existingDoc.data.flags.ddb.versions.ddbImporter
      : "2.0.1";
      const oldAdventureMuncherVersion = existingDoc.data?.flags?.ddb?.versions?.adventureMuncher
      ? existingDoc.data.flags.ddb.versions.adventureMuncher
      : "0.3.0";
      const oldVersions = { ddbImporter: oldDDBImporterVersion, ddbMetaData: oldDDBMetaDataVersions, adventureMuncher: oldAdventureMuncherVersion };

      const documentVersions = newDoc.flags.ddb.versions;
      const importerVersionChanged = isNewerVersion(ddbIVersion, oldVersions["ddbImporter"]);
      const metaVersionChanged = isNewerVersion(documentVersions["ddbMetaData"]["lastUpdate"], oldVersions["ddbMetaData"]["lastUpdate"]);
      const muncherVersionChanged = isNewerVersion(documentVersions["adventureMuncher"], oldVersions["adventureMuncher"]);

      if (importerVersionChanged || metaVersionChanged || muncherVersionChanged) {
        newDoc.oldVersions = oldVersions;
        newDoc.importerVersionChanged = importerVersionChanged;
        newDoc.metaVersionChanged = metaVersionChanged;
        newDoc.muncherVersionChanged = muncherVersionChanged;
        newDoc.drawingVersionChanged = isNewerVersion(documentVersions["ddbMetaData"]["drawings"], oldVersions["ddbMetaData"]["drawings"]);
        newDoc.noteVersionChanged = isNewerVersion(documentVersions["ddbMetaData"]["notes"], oldVersions["ddbMetaData"]["notes"]);
        newDoc.tokenVersionChanged = isNewerVersion(documentVersions["ddbMetaData"]["tokens"], oldVersions["ddbMetaData"]["tokens"]);
        newDoc.wallVersionChanged = isNewerVersion(documentVersions["ddbMetaData"]["walls"], oldVersions["ddbMetaData"]["walls"]);
        newDoc.lightVersionChanged = isNewerVersion(documentVersions["ddbMetaData"]["lights"], oldVersions["ddbMetaData"]["lights"]);
      }
    }
    return newDoc;
  }

  async _checkForDataUpdates(type, zip, adventure) {
    const importType = AdventureMunch.getImportType(type);
    const dataFiles = AdventureMunch._getFiles(type, zip);

    src_logger/* default.info */.Z.info(`Checking ${adventure.name} - ${importType} (${dataFiles.length} for updates)`);

    let fileData = [];
    let hasVersions = false;
    const moduleInfo = game.modules.get("ddb-importer").data;
    const installedVersion = moduleInfo.version;

    await Helpers.asyncForEach(dataFiles, async (file) => {
      const raw = await zip.file(file.name).async("text");
      const json = JSON.parse(raw);
      if (!hasVersions && json?.flags?.ddb?.versions) {
        hasVersions = true;
      }
      switch (importType) {
        case "Scene": {
          const existingScene = await game.scenes.find((item) => item.data._id === json._id);
          if (existingScene) {
            const scene = AdventureMunch._extractDocumentVersionData(json, existingScene, installedVersion);
            if (scene.importerVersionChanged || scene.metaVersionChanged || scene.muncherVersionChanged) {
              fileData.push(scene);
            }
          }
          break;
        }
        // no default
      }
    });

    return new Promise((resolve) => {
      if (hasVersions && fileData.length > 0) {
        new Dialog(
          {
            title: `${importType} updates`,
            content: {
              "dataType": type,
              "dataTypeDisplay": importType,
              "fileData": fileData,
              "cssClass": "import-data-updates"
            },
            buttons: {
              confirm: {
                label: "Confirm",
                callback: async () => {
                  const formData = $('.import-data-updates').serializeArray();
                  let ids = [];
                  let dataType = "";
                  for (let i = 0; i < formData.length; i++) {
                    const key = formData[i].name;
                    if (key.startsWith("new_")) {
                      ids.push(key.substr(4));
                    } else if (key === "type") {
                      dataType = formData[i].value;
                    }
                  }
                  resolve(this._importFile(dataType, zip, adventure, ids));
                }
              },
            },
            default: "confirm",
            close: async () => {
              resolve(this._importFile(type, zip, adventure));
            },
          },
          {
            width: 700,
            classes: ["dialog", "adventure-import-updates"],
            template: "modules/ddb-importer/handlebars/adventure/import-updates.hbs",
          }
        ).render(true);
      } else {
        resolve(this._importFile(type, zip, adventure));
      }
    });

  }

  async _importFile(type, zip, adventure, overwriteIds = []) {
    let totalCount = 0;
    let currentCount = 0;

    src_logger/* default.info */.Z.info(`IDs to overwrite of type ${type}: ${JSON.stringify(overwriteIds)}`);

    const importType = AdventureMunch.getImportType(type);
    const dataFiles = AdventureMunch._getFiles(type, zip);

    src_logger/* default.info */.Z.info(`Importing ${adventure.name} - ${importType} (${dataFiles.length} items)`);

    totalCount = dataFiles.length;

    await Helpers.asyncForEach(dataFiles, async (file) => {
      const rawdata = await zip.file(file.name).async("text");
      const data = JSON.parse(rawdata);

      let needRevisit = false;

      // let pattern = /(\@[a-z]*)(\[)([a-z0-9]*|[a-z0-9\.]*)(\])/gmi
      if (rawdata.match(this.pattern) || rawdata.match(this.altpattern)) {
        needRevisit = true;
      }

      if (data.img) {
        // eslint-disable-next-line require-atomic-updates
        data.img = await Helpers.importImage(data.img, zip, adventure);
      }
      if (data.thumb) {
        // eslint-disable-next-line require-atomic-updates
        data.thumb = await Helpers.importImage(data.thumb, zip, adventure);
      }
      if (data?.token?.img) {
        if (data?.token?.randomImg) {
          const imgFilepaths = data.token.img.split("/");
          const imgFilename = (imgFilepaths.reverse())[0];
          const imgFilepath = data.token.img.replace(imgFilename, "");

          const filesToUpload = Object.values(zip.files).filter((file) => {
            return !file.dir && file.name.includes(imgFilepath);
          });

          let adventurePath = (adventure.name).replace(/[^a-z0-9]/gi, '_');

          data.token.img = `${this._importPathData.current}/${adventurePath}/${data.token.img}`;

          if (filesToUpload.length > 0) {
            totalCount += filesToUpload.length;

            await Helpers.asyncForEach(filesToUpload, async (file) => {
              await Helpers.importImage(file.name, zip, adventure);
              currentCount += 1;
              AdventureMunch._updateProgress(totalCount, currentCount, importType);
            });
          }

        } else {
          // eslint-disable-next-line require-atomic-updates
          data.token.img = await Helpers.importImage(data.token.img, zip, adventure);
        }
      }

      if (data?.items?.length) {
        await Helpers.asyncForEach(data.items, async (item) => {
          if (item.img) {
            // eslint-disable-next-line require-atomic-updates
            item.img = await Helpers.importImage(item.img, zip, adventure);
          }
        });
      }

      if (importType === "Scene") {
        if (data.tokens) {
          await AdventureMunch._generateTokenActors(data);
        }
      } else if (importType === "Playlist") {
        await Helpers.asyncForEach(data.sounds, async (sound) => {
          if (sound.path) {
            // eslint-disable-next-line require-atomic-updates
            sound.path = await Helpers.importImage(sound.path, zip, adventure);
          }
        });
      } else if (importType === "RollTable") {
        await Helpers.asyncForEach(data.results, async (result) => {
          if (result.img) {
            // eslint-disable-next-line require-atomic-updates
            result.img = await Helpers.importImage(result.img, zip, adventure);
          }
          if (result.resultId) {
            needRevisit = true;
          }
          src_logger/* default.debug */.Z.debug(`Updating DDB links for ${data.name}`);
          // eslint-disable-next-line require-atomic-updates
          data.text = AdventureMunch._foundryCompendiumReplace(data.text);
        });
      } else if (importType === "JournalEntry" && data.content) {
        const journalImages = Helpers.reMatchAll(/(src|href)="(?!http(?:s*):\/\/)([\w0-9\-._~%!$&'()*+,;=:@/]*)"/, data.content);
        if (journalImages) {
          await Helpers.asyncForEach(journalImages, async (result) => {
            const path = await Helpers.importImage(result[2], zip, adventure);
            data.content = data.content.replace(result[0], `${result[1]}="${path}"`);
          });
        }
        src_logger/* default.debug */.Z.debug(`Updating DDB links for ${data.name}`);
        data.content = AdventureMunch._foundryCompendiumReplace(data.content);
      }

      data.flags.importid = data._id;

      if (importType !== "Playlist" && importType !== "Compendium") {
        if (CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[data.folder]) {
          src_logger/* default.debug */.Z.debug(`Adding data to subfolder importkey = ${data.folder}, folder = ${CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[data.folder]}`);
          data.folder = CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[data.folder];
        } else {
          src_logger/* default.debug */.Z.debug(`Adding data to subfolder importkey = ${data.folder}, folder = ${CONFIG.DDBI.ADVENTURE.TEMPORARY.folders["null"]}`);
          if (adventure?.options?.folders) {
            data.folder = CONFIG.DDBI.ADVENTURE.TEMPORARY.folders["null"];
          } else {
            data.folder = CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[importType];
          }
        }
      }

      await this._importRenderedFile(adventure, importType, data, zip, needRevisit, overwriteIds);

      currentCount += 1;
      AdventureMunch._updateProgress(totalCount, currentCount, importType);
    });


  }

  static _updateProgress(total, count, type) {
    const localizedType = `dbb-importer.label.${type}`;
    $(".import-progress-bar")
      .width(`${Math.trunc((count / total) * 100)}%`)
      .html(`<span>${game.i18n.localize("dbb-importer.label.Working")} (${game.i18n.localize(localizedType)})...</span>`);
  }

  static _progressNote(note) {
    $(".import-progress-bar")
      .html(`<span>${game.i18n.localize("dbb-importer.label.Working")} (${note})...</span>`);
  }
}

;// CONCATENATED MODULE: ./src/muncher/settings.js
// import logger from "../logger.js";





function autoACDisableEffects() {
  const AUTO_AC = src_utils/* default.versionCompare */.Z.versionCompare(game.data.system.data.version, "1.4.0") >= 0;
  if (AUTO_AC) {
    game.settings.set("ddb-importer", "character-update-policy-generate-ac-armor-effects", false);
    game.settings.set("ddb-importer", "character-update-policy-generate-base-ac", false);
    game.settings.set("ddb-importer", "character-update-policy-generate-ac-override-effects", false);
  }
}

function setRecommendedCharacterActiveEffectSettings(html) {
  $(html).find("#character-import-policy-dae-copy").prop("checked", false);
  game.settings.set("ddb-importer", "character-update-policy-dae-copy", false);
  $(html).find("#character-import-policy-dae-effect-copy").prop("checked", true);
  game.settings.set("ddb-importer", "character-update-policy-dae-effect-copy", true);
  $(html).find("#character-import-policy-add-item-effects").prop("checked", true);
  game.settings.set("ddb-importer", "character-update-policy-add-item-effects", true);
  $(html).find("#character-import-policy-add-character-effects").prop("checked", true);
  game.settings.set("ddb-importer", "character-update-policy-add-character-effects", true);
  $(html).find("#character-import-policy-generate-ac-feature-effects").prop("checked", true);
  game.settings.set("ddb-importer", "character-update-policy-generate-ac-feature-effects", true);
  $(html).find("#character-import-policy-active-effect-copy").prop("checked", false);
  game.settings.set("ddb-importer", "character-update-policy-active-effect-copy", false);

  const AUTO_AC = src_utils/* default.versionCompare */.Z.versionCompare(game.data.system.data.version, "1.4.0") >= 0;
  if (AUTO_AC) {
    autoACDisableEffects();
  } else {
    $(html).find("#character-import-policy-generate-ac-armor-effects").prop("checked", true);
    game.settings.set("ddb-importer", "character-update-policy-generate-ac-armor-effects", true);
    $(html).find("#character-import-policy-generate-base-ac").prop("checked", true);
    game.settings.set("ddb-importer", "character-update-policy-generate-base-ac", true);
    $(html).find("#character-import-policy-generate-ac-override-effects").prop("checked", false);
    game.settings.set("ddb-importer", "character-update-policy-generate-ac-override-effects", false);
  }

  ["class", "race", "background", "feat"].forEach((type) => {
    $(html).find(`#character-import-policy-effect-${type}-spell-bonus`).prop("checked", true);
    game.settings.set("ddb-importer", `character-update-policy-effect-${type}-spell-bonus`, true);
    $(html).find(`#character-import-policy-effect-${type}-speed`).prop("checked", false);
    game.settings.set("ddb-importer", `character-update-policy-effect-${type}-speed`, false);
    $(html).find(`#character-import-policy-effect-${type}-senses`).prop("checked", false);
    game.settings.set("ddb-importer", `character-update-policy-effect-${type}-senses`, false);
    $(html).find(`#character-import-policy-effect-${type}-hp`).prop("checked", false);
    game.settings.set("ddb-importer", `character-update-policy-effect-${type}-hp`, false);
    $(html).find(`#character-import-policy-effect-${type}-damages`).prop("checked", false);
    game.settings.set("ddb-importer", `character-update-policy-effect-${type}-damages`, false);
  });
}

function getCharacterImportSettings() {
  const AUTO_AC = src_utils/* default.versionCompare */.Z.versionCompare(game.data.system.data.version, "1.4.0") >= 0;
  autoACDisableEffects();

  const importPolicies = [
    {
      name: "name",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-name"),
      description: "Name",
    },
    {
      name: "hp",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-hp"),
      description: "HP",
    },
    {
      name: "hit-die",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-hit-die"),
      description: "Hit Die",
    },
    {
      name: "class",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-class"),
      description: "Classes",
    },
    {
      name: "feat",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-feat"),
      description: "Features",
    },
    {
      name: "weapon",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-weapon"),
      description: "Weapons",
    },
    {
      name: "equipment",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-equipment"),
      description: "Other Equipment",
    },
    {
      name: "currency",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-currency"),
      description: "Currency",
    },
    {
      name: "spell",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-spell"),
      description: "Spells",
    },
    {
      name: "image",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-image"),
      description: "Image",
    },
    {
      name: "bio",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-bio"),
      description: "Bio",
    },
  ];

  const daeInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("dae");
  const daeSRDInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("Dynamic-Effects-SRD");
  const midiSRDInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("midi-srd");
  const daeSRDContentAvailable = daeSRDInstalled || midiSRDInstalled;

  // const importExtras = game.settings.get("ddb-importer", "character-update-policy-import-extras");

  const importConfig = [
    {
      name: "use-inbuilt-icons",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-use-inbuilt-icons"),
      description: "Use icons from the inbuilt dictionary. (High coverage of items, feats, and spells).",
      enabled: true,
    },
    {
      name: "use-srd-icons",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-use-srd-icons"),
      description: "Use icons from the SRD compendium. (This can take a while).",
      enabled: true,
    },
    {
      name: "use-ddb-spell-icons",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-use-ddb-spell-icons"),
      description: "Use spell school icons from D&DBeyond.",
      enabled: true,
    },
    {
      name: "use-ddb-item-icons",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-use-ddb-item-icons"),
      description: "Use equipment icons from D&DBeyond (where they exist).",
      enabled: true,
    },
    {
      name: "use-ddb-generic-item-icons",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-use-ddb-generic-item-icons"),
      description: "Use D&D Beyond generic item type images, if available (final fallback)",
      enabled: true,
    },
    {
      name: "use-full-description",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-use-full-description"),
      description: "For actions use full description and snippets, else use snippets only.",
      enabled: true,
    },
    {
      name: "use-action-and-feature",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-use-action-and-feature"),
      description:
        "[CAUTION] If a feature is marked as an action, import both the action and the feature. This might lead to some weird behaviour.",
      enabled: true,
    },
  ];

  const advancedImportConfig = [
    {
      name: "use-override",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-use-override"),
      title: "Replace Items using those in your Override compendium",
      description:
        "Use existing items from <i>ddb-import Override compendium</i>, rather than parsing from DDB. This is useful if you want to place customised items into the compendium for use by characters.",
      enabled: true,
    },
    {
      name: "use-existing",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-use-existing"),
      title: "[Caution] Replace Items using ddb-importer compendiums",
      description:
        "Use existing items from <i>ddb-import compendiums</i>, rather than parsing from DDB. This is useful if you have customised the items in the compendium, although you will lose any custom effects applied by this module e.g. Improved Divine Smite. Please consider marking the item you wish to keep as ignored by import instead.",
      enabled: true,
    },
    {
      name: "use-srd",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-use-srd"),
      title: "[Caution] Replace Items using SRD compendiums",
      description:
        "Use the <i>SRD compendiums</i>, rather than DDB. Importing using SRD will not include features like fighting style and divine smite in damage calculations. Please consider marking the item you wish to keep as ignored by import instead.",
      enabled: true,
    },
  ];

  const effectImportConfig1 = [
    {
      name: "add-item-effects",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-add-item-effects") && daeInstalled,
      title: "Generate Active Effects for Equipment",
      description:
        "Dynamically generate active effects for a characters equipment, doesn't include AC effects on armor, but will for things like the Ring of Protection.",
      enabled: daeInstalled,
    },
    {
      name: "add-character-effects",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-add-character-effects") && daeInstalled,
      title: "Generate Active Effects for Character Features/Racial Traits/Feats/Backgrounds",
      description:
        "Dynamically generate active effects for a character. Some effects are always generated, some are optional (see below).",
      enabled: daeInstalled,
    },
  ];
  const effectImportConfig2 = AUTO_AC
  ? []
  : [
    {
      name: "generate-ac-armor-effects",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-generate-ac-armor-effects") && daeInstalled,
      title: "Generate Active Effects ACs for Armor",
      description:
        "Dynamically add AC values as dynamic effects to armor items. If you're using DAE to auto-calculate AC, you don't need this.",
      enabled: daeInstalled && !AUTO_AC,
    },
  ];
  const effectImportConfig3 = [
    {
      name: "generate-ac-feature-effects",
      isChecked:
        game.settings.get("ddb-importer", "character-update-policy-generate-ac-feature-effects") && daeInstalled,
      title: "Generate DAE Active Effects ACs for Character Features & Racial Traits",
      description:
        "Use extras in DAE to Dynamically add AC values as dynamic effects to items, this might not work as expected for some AC calculations. If unticked some ac bonuses will still be generated.",
      enabled: daeInstalled,
    },
  ];
  const effectImportConfig4 = AUTO_AC
  ? []
  : [
    {
      name: "generate-base-ac",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-generate-base-ac"),
      title: "Set AC to base value",
      description:
        "Calculate AC base to base value, e.g. 10 +dex mod/natural armor rating. Useful if you want the AC to be correct when Armor is unequipped.",
      enabled: !AUTO_AC,
    },
    {
      name: "generate-ac-override-effects",
      isChecked:
        game.settings.get("ddb-importer", "character-update-policy-generate-ac-override-effects") && daeInstalled,
      title: "[Caution] Generate DAE Override ACs",
      description:
        "Generate possible AC combinations as dynamic effects, these are high priority effects that override other effects. Useful if you can't calculate your AC correctly using other effects.",
      enabled: daeInstalled && !AUTO_AC,
    },
  ];
  const effectImportConfig5 = [
    {
      name: "dae-effect-copy",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-dae-effect-copy") && daeSRDContentAvailable,
      title: "Copy Active Effect from DAE Compendiums",
      description:
        "<i>Transfer</i> the <i>Dynamic Active Effects Compendiums</i> effect for matching items/features/spells (requires DAE SRD and/or Midi SRD module). This may result in odd character AC's, HP etc. especially if the generate item and character effect options above are unticked. Please try importing the character with this option disabled before logging a bug.",
      enabled: daeInstalled && daeSRDContentAvailable,
    },
    // {
    //   name: "dae-copy",
    //   isChecked: game.settings.get("ddb-importer", "character-update-policy-dae-copy") && daeSRDContentAvailable,
    //   title: "[Caution] Replace Items using DAE compendiums",
    //   description:
    //     "Replace parsed item with <i>Dynamic Active Effects Compendiums</i> for matching items/features/spells (requires DAE SRD and/or Midi SRD module). This will remove any effects applied directly to your character/not via features/items. This may result in odd character AC's, HP etc. especially if the generate options above are unticked. Please try importing the character with this option disabled before logging a bug.",
    //   enabled: daeInstalled && daeSRDContentAvailable,
    // },
    {
      name: "active-effect-copy",
      isChecked: game.settings.get("ddb-importer", "character-update-policy-active-effect-copy"),
      title: "Retain Active Effects",
      description:
        "Retain existing Active Effects, this will try and transfer any existing effects on the actor such as custom effects, effects from conditions or existing spells. Untick this option if you experience <i>odd</i> behaviour, especially around AC.",
      enabled: true,
    },
  ];

  // dae migration function no longer sound
  if (game.settings.get("ddb-importer", "character-update-policy-dae-copy")) {
    game.settings.set("ddb-importer", "character-update-policy-dae-copy", false);
    game.settings.set("ddb-importer", "character-update-policy-dae-effect-copy", true);
  }

  const effectImportConfig = [...effectImportConfig1, ...effectImportConfig2, ...effectImportConfig3, ...effectImportConfig4, ...effectImportConfig5];

  const effectSelectionConfig = {
    class: [
      {
        name: "effect-class-spell-bonus",
        title: "Spell Bonuses",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-class-spell-bonus"),
        enabled: true,
      },
      {
        name: "effect-class-speed",
        title: "Movement",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-class-speed"),
        enabled: true,
      },
      {
        name: "effect-class-senses",
        title: "Senses",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-class-senses"),
        enabled: true,
      },
      {
        name: "effect-class-hp",
        title: "HP",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-class-hp"),
        enabled: true,
      },
      {
        name: "effect-class-damages",
        title: "Imm/Res/Vuln",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-class-damages"),
        enabled: true,
      },
    ],
    race: [
      {
        name: "effect-race-spell-bonus",
        title: "Spell Bonuses",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-race-spell-bonus"),
        enabled: true,
      },
      {
        name: "effect-race-speed",
        title: "Movement",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-race-speed"),
        enabled: true,
      },
      {
        name: "effect-race-senses",
        title: "Senses",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-race-senses"),
        enabled: true,
      },
      {
        name: "effect-race-hp",
        title: "HP",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-race-hp"),
        enabled: true,
      },
      {
        name: "effect-race-damages",
        title: "Imm/Res/Vuln",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-race-damages"),
        enabled: true,
      },
    ],
    background: [
      {
        name: "effect-background-spell-bonus",
        title: "Spell Bonuses",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-background-spell-bonus"),
        enabled: true,
      },
      {
        name: "effect-background-speed",
        title: "Movement",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-background-speed"),
        enabled: true,
      },
      {
        name: "effect-background-senses",
        title: "Senses",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-background-senses"),
        enabled: true,
      },
      {
        name: "effect-background-hp",
        title: "HP",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-background-hp"),
        enabled: true,
      },
      {
        name: "effect-background-damages",
        title: "Imm/Res/Vuln",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-background-damages"),
        enabled: true,
      },
    ],
    feat: [
      {
        name: "effect-feat-spell-bonus",
        title: "Spell Bonuses",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-feat-spell-bonus"),
        enabled: true,
      },
      {
        name: "effect-feat-speed",
        title: "Movement",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-feat-speed"),
        enabled: true,
      },
      {
        name: "effect-feat-senses",
        title: "Senses",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-feat-senses"),
        enabled: true,
      },
      {
        name: "effect-feat-hp",
        title: "HP",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-feat-hp"),
        enabled: true,
      },
      {
        name: "effect-feat-damages",
        title: "Imm/Res/Vuln",
        isChecked: game.settings.get("ddb-importer", "character-update-policy-effect-feat-damages"),
        enabled: true,
      },
    ],
  };

  const syncConfig = [
    {
      name: "action-use",
      isChecked: game.settings.get("ddb-importer", "sync-policy-action-use"),
      description: "Action Uses",
      enabled: true,
    },
    {
      name: "currency",
      isChecked: game.settings.get("ddb-importer", "sync-policy-currency"),
      description: "Currency",
      enabled: true,
    },
    {
      name: "deathsaves",
      isChecked: game.settings.get("ddb-importer", "sync-policy-deathsaves"),
      description: "Death Saves",
      enabled: true,
    },
    {
      name: "equipment",
      isChecked: game.settings.get("ddb-importer", "sync-policy-equipment"),
      description: "Equipment",
      enabled: true,
    },
    {
      name: "condition",
      isChecked: game.settings.get("ddb-importer", "sync-policy-condition"),
      description: "Exhaustion",
      enabled: true,
    },
    {
      name: "hitdice",
      isChecked: game.settings.get("ddb-importer", "sync-policy-hitdice"),
      description: "Hit Dice/Short Rest",
      enabled: true,
    },
    {
      name: "hitpoints",
      isChecked: game.settings.get("ddb-importer", "sync-policy-hitpoints"),
      description: "Hit Points",
      enabled: true,
    },
    {
      name: "inspiration",
      isChecked: game.settings.get("ddb-importer", "sync-policy-inspiration"),
      description: "Inspiration",
      enabled: true,
    },
    {
      name: "spells-prepared",
      isChecked: game.settings.get("ddb-importer", "sync-policy-spells-prepared"),
      description: "Spells Prepared",
      enabled: true,
    },
    {
      name: "spells-slots",
      isChecked: game.settings.get("ddb-importer", "sync-policy-spells-slots"),
      description: "Spell Slots",
      enabled: true,
    },
    {
      name: "spells-sync",
      isChecked: game.settings.get("ddb-importer", "sync-policy-spells-sync"),
      description: "Spells Known",
      enabled: false,
    },
    {
      name: "xp",
      isChecked: game.settings.get("ddb-importer", "sync-policy-xp"),
      description: "XP",
      enabled: true,
    },
  ];

  const extrasConfig = [
    // {
    //   name: "update-existing",
    //   isChecked: game.settings.get("ddb-importer", "munching-policy-update-existing"),
    //   description: "Update existing things.",
    //   enabled: true,
    // },
    // {
    //   name: "use-srd",
    //   isChecked: game.settings.get("ddb-importer", "munching-policy-use-srd"),
    //   description: "Use SRD compendium things instead of importing.",
    //   enabled: true,
    // },
    // {
    //   name: "use-inbuilt-icons",
    //   isChecked: game.settings.get("ddb-importer", "munching-policy-use-inbuilt-icons"),
    //   description: "Use icons from the inbuilt dictionary. (High coverage of items, feats, and spells).",
    //   enabled: true,
    // },
    // {
    //   name: "use-srd-icons",
    //   isChecked: game.settings.get("ddb-importer", "munching-policy-use-srd-icons"),
    //   description: "Use icons from the SRD compendiums.",
    //   enabled: true,
    // },
    // {
    //   name: "download-images",
    //   isChecked: game.settings.get("ddb-importer", "munching-policy-download-images"),
    //   description: "Download D&D Beyond images (takes longer and needs space).",
    //   enabled: true,
    // },
    // {
    //   name: "remote-images",
    //   isChecked: game.settings.get("ddb-importer", "munching-policy-remote-images"),
    //   description: "Use D&D Beyond remote images (a lot quicker)",
    //   enabled: true,
    // },
    // {
    //   name: "use-dae-effects",
    //   isChecked: game.settings.get("ddb-importer", "munching-policy-use-dae-effects"),
    //   description: "Copy effects from DAE (items and spells only). (Requires DAE and SRD module)",
    //   enabled: daeInstalled,
    // },
    // {
    //   name: "hide-description",
    //   isChecked: game.settings.get("ddb-importer", "munching-policy-hide-description"),
    //   description: "Hide description from players?",
    //   enabled: true,
    // },
    // {
    //   name: "monster-items",
    //   isChecked: game.settings.get("ddb-importer", "munching-policy-monster-items"),
    //   description: "[Experimental] Load items from DDB compendium instead of parsing action/attack?",
    //   enabled: true,
    // },
    // {
    //   name: "update-images",
    //   isChecked: game.settings.get("ddb-importer", "munching-policy-update-images"),
    //   description: "Update images on existing items?",
    //   enabled: true,
    // },
    // {
    //   name: "dae-copy",
    //   isChecked: game.settings.get("ddb-importer", "munching-policy-dae-copy"),
    //   description: "Use Dynamic Active Effects Compendiums for matching items/features (requires DAE and SRD module).",
    //   enabled: daeInstalled,
    // },
  ];

  const uploadDir = game.settings.get("ddb-importer", "image-upload-directory");
  const badDirs = ["[data]", "[data] ", "", null];
  const dataDirSet = !badDirs.includes(uploadDir);
  const tier = game.settings.get("ddb-importer", "patreon-tier");
  const tiers = (0,utils/* getPatreonTiers */.A1)(tier);

  const result = {
    importPolicies: importPolicies,
    importConfig: importConfig,
    extrasConfig: extrasConfig,
    advancedImportConfig: advancedImportConfig,
    effectImportConfig: effectImportConfig,
    effectSelectionConfig: effectSelectionConfig,
    dataDirSet: dataDirSet,
    syncConfig: syncConfig,
    tiers: tiers,
  };

  return result;
}

function updateActorSettings(html, event) {
  const selection = event.currentTarget.dataset.section;
  const checked = event.currentTarget.checked;
  const AUTO_AC = src_utils/* default.versionCompare */.Z.versionCompare(game.data.system.data.version, "1.4.0") >= 0;

  src_logger/* default.debug */.Z.debug(`Updating munching-policy-${selection} to ${checked}`);
  game.settings.set("ddb-importer", "character-update-policy-" + selection, checked);

  if (selection === "dae-copy" && checked) {
    $(html).find("#character-import-policy-dae-effect-copy").prop("checked", false);
    game.settings.set("ddb-importer", "character-update-policy-dae-effect-copy", false);
  } else if (selection === "dae-effect-copy" && checked) {
    $(html).find("#character-import-policy-dae-copy").prop("checked", false);
    game.settings.set("ddb-importer", "character-update-policy-dae-copy", false);
    $(html).find("#character-import-policy-add-item-effects").prop("checked", true);
    game.settings.set("ddb-importer", "character-update-policy-add-item-effects", true);
    $(html).find("#character-import-policy-add-character-effects").prop("checked", true);
    game.settings.set("ddb-importer", "character-update-policy-add-character-effects", true);
  } else if (!AUTO_AC && (selection === "generate-ac-armor-effects" || selection === "generate-ac-feature-effects") && checked) {
    game.settings.set("dae", "calculateArmor", false);
    game.settings.set("dae", "applyBaseAC", false);
  }
}

function getCompendiumFolderLookups(type) {
  const compendiumFolderSetting = game.settings.settings.get(`ddb-importer.munching-selection-compendium-folders-${type}`);
  const settingValue = game.settings.get("ddb-importer", `munching-selection-compendium-folders-${type}`);

  let selections = [];
  for (const [key, value] of Object.entries(compendiumFolderSetting.choices)) {
    selections.push({
      key: key,
      label: value,
      selected: key === settingValue,
    });
  }

  return selections;
}

function getMuncherSettings(includeHomebrew = true) {
  const cobalt = getCobalt() != "";
  const betaKey = game.settings.get("ddb-importer", "beta-key") != "";
  const tier = game.settings.get("ddb-importer", "patreon-tier");
  const tiers = (0,utils/* getPatreonTiers */.A1)(tier);
  const daeInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("dae");
  const daeSRDInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("Dynamic-Effects-SRD");
  const midiSRDInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("midi-srd");
  const daeSRDContentAvailable = daeSRDInstalled || midiSRDInstalled;
  const compendiumFolderAdd = game.settings.get("ddb-importer", "munching-policy-use-compendium-folders");
  const compendiumFoldersInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("compendium-folders");
  const compendiumFolderMonsterStyles = getCompendiumFolderLookups("monster");
  const compendiumFolderSpellStyles = getCompendiumFolderLookups("spell");
  const compendiumFolderItemStyles = getCompendiumFolderLookups("item");

  const itemConfig = [
    {
      name: "use-ddb-item-icons",
      isChecked: game.settings.get("ddb-importer", "munching-policy-use-ddb-item-icons"),
      description: "Use D&D Beyond item images, if available",
      enabled: true,
    },
    {
      name: "use-ddb-generic-item-icons",
      isChecked: game.settings.get("ddb-importer", "munching-policy-use-ddb-generic-item-icons"),
      description: "Use D&D Beyond generic item type images, if available (final fallback)",
      enabled: true,
    },
    {
      name: "add-effects",
      isChecked: game.settings.get("ddb-importer", "munching-policy-add-effects"),
      description: "[Experimental] Dynamically generate DAE effects (equipment only). (Requires DAE)",
      enabled: daeInstalled,
    },
    {
      name: "add-ac-armor-effects",
      isChecked: game.settings.get("ddb-importer", "munching-policy-add-ac-armor-effects"),
      description: "[Experimental] Dynamically generate DAE AC effects on armor equipment. (Requires DAE)",
      enabled: daeInstalled,
    },
  ];

  const spellConfig = [
    {
      name: "use-ddb-spell-icons",
      isChecked: game.settings.get("ddb-importer", "munching-policy-use-ddb-spell-icons"),
      description: "If no other icon, use the D&DBeyond spell school icon.",
      enabled: true,
    },
  ];

  const sourcesSelected = game.settings.get("ddb-importer", "munching-policy-monster-sources").flat().length > 0;
  const homebrewDescription = sourcesSelected
      ? "SOURCES SELECTED! You can't import homebrew with a source filter selected"
      : "Include homebrew?";

  const basicMonsterConfig = [
    {
      name: "hide-description",
      isChecked: game.settings.get("ddb-importer", "munching-policy-hide-description"),
      description: "Hide monster action description from players?",
      enabled: true,
    },
    {
      name: "monster-items",
      isChecked: game.settings.get("ddb-importer", "munching-policy-monster-items"),
      description: "[Experimental] Load items from DDB compendium instead of parsing action/attack?",
      enabled: true,
    },
    {
      name: "update-images",
      isChecked: game.settings.get("ddb-importer", "munching-policy-update-images"),
      description: "Update Monster images on existing items?",
      enabled: true,
    },
    {
      name: "use-full-token-image",
      isChecked: game.settings.get("ddb-importer", "munching-policy-use-full-token-image"),
      description: "Use avatar image for token rather than token image",
      enabled: true,
    },
    {
      name: "use-token-avatar-image",
      isChecked: game.settings.get("ddb-importer", "munching-policy-use-token-avatar-image"),
      description: "Use token image for avatar rather than avatar image",
      enabled: true,
    },
    {
      name: "dae-copy",
      isChecked: game.settings.get("ddb-importer", "munching-policy-dae-copy"),
      description: "Use Dynamic Active Effects Compendiums for matching items/features (requires DAE and SRD module).",
      enabled: daeInstalled && daeSRDContentAvailable,
    }
  ];

  const homebrewMonsterConfig = includeHomebrew
    ? [
        {
          name: "monster-homebrew",
          isChecked: game.settings.get("ddb-importer", "munching-policy-monster-homebrew") && !sourcesSelected,
          description: homebrewDescription,
          enabled: tiers.homebrew && !sourcesSelected,
        },
        {
          name: "monster-homebrew-only",
          isChecked: game.settings.get("ddb-importer", "munching-policy-monster-homebrew-only") && !sourcesSelected,
          description: "Homebrew monsters only? (Otherwise both)",
          enabled: tiers.homebrew && !sourcesSelected,
        },
        {
          name: "monster-exact-match",
          isChecked: game.settings.get("ddb-importer", "munching-policy-monster-exact-match"),
          description: "Exact name match?",
          enabled: tiers.homebrew,
        }
      ]
    : [];

  const monsterConfig = basicMonsterConfig.concat(homebrewMonsterConfig);

  const genericConfig = [
    {
      name: "update-existing",
      isChecked: game.settings.get("ddb-importer", "munching-policy-update-existing"),
      description: "Update existing things.",
      enabled: true,
    },
    {
      name: "use-inbuilt-icons",
      isChecked: game.settings.get("ddb-importer", "munching-policy-use-inbuilt-icons"),
      description: "Use icons from the inbuilt dictionary. (High coverage, recommended, fast).",
      enabled: true,
    },
    {
      name: "use-srd-icons",
      isChecked: game.settings.get("ddb-importer", "munching-policy-use-srd-icons"),
      description: "Use icons from the SRD compendiums.",
      enabled: true,
    },
    {
      name: "download-images",
      isChecked: game.settings.get("ddb-importer", "munching-policy-download-images"),
      description: "Download D&D Beyond images (takes longer and needs space).",
      enabled: true,
    },
    {
      name: "remote-images",
      isChecked: game.settings.get("ddb-importer", "munching-policy-remote-images"),
      description: "Use D&D Beyond remote images (a lot quicker)",
      enabled: true,
    },
    {
      name: "use-dae-effects",
      isChecked: game.settings.get("ddb-importer", "munching-policy-use-dae-effects"),
      description: "Copy effects from DAE (items and spells only). (Requires DAE and SRD or Midi content module)",
      enabled: daeInstalled && daeSRDContentAvailable,
    },
    {
      name: "use-compendium-folders",
      isChecked: compendiumFoldersInstalled ? compendiumFolderAdd : false,
      description: "Generate compendium folders. You can migrate an existing import in the Tools tab.",
      enabled: compendiumFoldersInstalled,
    },
    {
      name: "use-srd",
      isChecked: game.settings.get("ddb-importer", "munching-policy-use-srd"),
      description:
        "[CAUTION] Use SRD compendium things instead of importing. This is not recommended, and may break adventure munching functionality.",
      enabled: true,
    },
  ];

  const resultData = {
    cobalt,
    genericConfig,
    monsterConfig,
    spellConfig,
    itemConfig,
    beta: betaKey && cobalt,
    tiers,
    compendiumFoldersInstalled,
    compendiumFolderMonsterStyles,
    compendiumFolderItemStyles,
    compendiumFolderSpellStyles,
  };

  // console.warn(resultData);

  return resultData;
}

function updateMuncherSettings(html, event) {
  const selection = event.currentTarget.dataset.section;
  const checked = event.currentTarget.checked;

  src_logger/* default.debug */.Z.debug(`Updating munching-policy-${selection} to ${checked}`);

  game.settings.set("ddb-importer", "munching-policy-" + selection, checked);

  switch (selection) {
    case "use-full-token-image": {
      if (checked) {
        game.settings.set("ddb-importer", "munching-policy-use-token-avatar-image", false);
        $("#munching-policy-use-token-avatar-image").prop("checked", false);
      }
      break;
    }
    case "use-token-avatar-image": {
      if (checked) {
        game.settings.set("ddb-importer", "munching-policy-use-full-token-image", false);
        $("#munching-policy-use-full-token-image").prop("checked", false);
      }
      break;
    }
    case "monster-homebrew": {
      if (!checked) {
        game.settings.set("ddb-importer", "munching-policy-monster-homebrew-only", false);
        $("#munching-policy-monster-homebrew-only").prop("checked", false);
      }
      break;
    }
    case "monster-homebrew-only": {
      if (checked) {
        game.settings.set("ddb-importer", "munching-policy-monster-homebrew", true);
        $("#munching-policy-monster-homebrew").prop("checked", true);
      }
      break;
    }
    case "remote-images": {
      if (checked) {
        game.settings.set("ddb-importer", "munching-policy-download-images", false);
        $("#munching-generic-policy-download-images").prop("checked", false);
      }
      break;
    }
    case "download-images": {
      if (checked) {
        game.settings.set("ddb-importer", "munching-policy-remote-images", false);
        $("#munching-generic-policy-remote-images").prop("checked", false);
      }
      break;
    }
    // no default
  }
}

;// CONCATENATED MODULE: ./src/muncher/ddb.js
// Main module class

















function getSourcesLookups(selected) {
  const selections = ddbConfig/* DDB_CONFIG.sources.filter */.U.sources.filter((source) => source.isReleased)
  .map((source) => {
    const details = {
      id: source.id,
      acronym: source.name,
      label: source.description,
      selected: selected.includes(source.id),
    };
    return details;
  });

  return selections;
}

class DDBSources extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-sources";
    options.template = "modules/ddb-importer/handlebars/sources.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "Monster Muncher Sauce Selection";
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find("#toggle-sources").click(async (event) => {
      event.preventDefault();
      if ($('.munching-sources input:checked').length && $('.munching-sources input').not(':checked').length) {
        $('.munching-sources input').prop('checked', false);
      } else {
        $('.munching-sources input').each(function() {
          // eslint-disable-next-line no-invalid-this
          $(this).prop('checked', !$(this).prop('checked'));
        });
      }
    });
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const existingSelection = game.settings.get("ddb-importer", "munching-policy-monster-sources").flat();
    const sources = getSourcesLookups(existingSelection);

    return {
      sources: sources.sort((a, b) => {
        return (a.label > b.label) ? 1 : ((b.label > a.label) ? -1 : 0);
      }),
    };
  }

  /** @override */
  // eslint-disable-next-line no-unused-vars
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();
    let sources = [];
    for (const [key, value] of Object.entries(formData)) {
      if (value) sources.push(parseInt(key));
    }
    await game.settings.set("ddb-importer", "munching-policy-monster-sources", sources);
    // eslint-disable-next-line no-use-before-define
    new DDBMuncher().render(true);
  }
}

class DDBMuncher extends Application {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-monsters";
    options.template = "modules/ddb-importer/handlebars/munch.hbs";
    options.resizable = false;
    options.height = "auto";
    options.width = 800;
    options.title = "MrPrimate's Muncher";
    options.classes = ["ddb-muncher", "sheet"];
    options.tabs = [{ navSelector: ".tabs", contentSelector: "div", initial: "settings" }];
    return options;
  }

  static startMunch() {
    (0,utils/* munchNote */.ep)(`Downloading monsters...`, true);
    $('button[id^="munch-"]').prop('disabled', true);
    $('button[id^="adventure-config-start"]').prop('disabled', true);
    DDBMuncher.parseCritters();
  }

  activateListeners(html) {
    super.activateListeners(html);
    html.find("#munch-monsters-start").click(async () => {
      DDBMuncher.startMunch();
    });
    html.find("#munch-source-select").click(async () => {
      DDBMuncher.selectSources();
    });

    html.find("#munch-spells-start").click(async () => {
      (0,utils/* munchNote */.ep)(`Downloading spells...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseSpells();
    });
    html.find("#munch-items-start").click(async () => {
      (0,utils/* munchNote */.ep)(`Downloading items...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseItems();
    });
    html.find("#munch-races-start").click(async () => {
      (0,utils/* munchNote */.ep)(`Downloading races...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseRaces();
    });
    html.find("#munch-feats-start").click(async () => {
      (0,utils/* munchNote */.ep)(`Downloading feats...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseFeats();
    });
    html.find("#munch-classes-start").click(async () => {
      (0,utils/* munchNote */.ep)(`Downloading classes...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseClasses();
    });
    html.find("#munch-frames-start").click(async () => {
      (0,utils/* munchNote */.ep)(`Downloading frames...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseFrames();
    });
    html.find("#munch-adventure-config-start").click(async () => {
      (0,utils/* munchNote */.ep)(`Generating config file...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.generateAdventureConfig();
    });
    html.find("#munch-adventure-import-start").click(async () => {
      DDBMuncher.importAdventure();
    });
    html.find("#munch-migrate-compendium-monster").click(async () => {
      (0,utils/* munchNote */.ep)(`Migrating monster compendium...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.migrateCompendiumFolders("monsters");
    });
    html.find("#munch-migrate-compendium-spell").click(async () => {
      (0,utils/* munchNote */.ep)(`Migrating spell compendium...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.migrateCompendiumFolders("spells");
    });
    html.find("#munch-migrate-compendium-item").click(async () => {
      (0,utils/* munchNote */.ep)(`Migrating item compendium...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.migrateCompendiumFolders("items");
    });

    // watch the change of the import-policy-selector checkboxes
    $(html)
    .find(
      [
        '.munching-generic-config input[type="checkbox"]',
        '.munching-spell-config input[type="checkbox"]',
        '.munching-item-config input[type="checkbox"]',
        '.munching-monster-config input[type="checkbox"]',
      ].join(",")
    )
    .on("change", (event) => {
      updateMuncherSettings(html, event);
    });


    html.find("#monster-munch-filter").on("keyup", (event) => {
      event.preventDefault();
      if (event.key !== "Enter") return; // Use `.key` instead.
      DDBMuncher.startMunch();
    });

    // compendium style migrations
    html.find("#compendium-folder-style-monster").on("change", async () => {
      const style = html.find("#compendium-folder-style-monster");
      const importStyle = style[0].selectedOptions[0] ? style[0].selectedOptions[0].value : "TYPE";
      game.settings.set("ddb-importer", "munching-selection-compendium-folders-monster", importStyle);
    });
    html.find("#compendium-folder-style-spell").on("change", async () => {
      const style = html.find("#compendium-folder-style-spell");
      const importStyle = style[0].selectedOptions[0] ? style[0].selectedOptions[0].value : "SCHOOL";
      game.settings.set("ddb-importer", "munching-selection-compendium-folders-spell", importStyle);
    });
    html.find("#compendium-folder-style-item").on("change", async () => {
      const style = html.find("#compendium-folder-style-item");
      const importStyle = style[0].selectedOptions[0] ? style[0].selectedOptions[0].value : "TYPE";
      game.settings.set("ddb-importer", "munching-selection-compendium-folders-item", importStyle);
    });

    this.close();
  }

  static enableButtons() {
    const cobalt = getCobalt() != "";
    const tier = game.settings.get("ddb-importer", "patreon-tier");
    const tiers = (0,utils/* getPatreonTiers */.A1)(tier);

    if (cobalt) {
      $('button[id^="munch-spells-start"]').prop('disabled', false);
      $('button[id^="munch-items-start"]').prop('disabled', false);
      $('button[id^="munch-adventure-config-start"]').prop('disabled', false);
      $('button[id^="munch-adventure-import-start"]').prop('disabled', false);
      $('button[id^="munch-migrate-compendium-monster"]').prop('disabled', false);
      $('button[id^="munch-migrate-compendium-spell"]').prop('disabled', false);
      $('button[id^="munch-migrate-compendium-item"]').prop('disabled', false);

      if (tiers.all) {
        $('button[id^="munch-monsters-start"]').prop('disabled', false);
      }
      if (tiers.supporter) {
        $('button[id^="munch-races-start"]').prop('disabled', false);
        $('button[id^="munch-feats-start"]').prop('disabled', false);
        $('button[id^="munch-source-select"]').prop('disabled', false);
        $('button[id^="munch-frames-start"]').prop('disabled', false);
      }
      if (tiers.experimentalMid) {
        $('button[id^="munch-classes-start"]').prop('disabled', false);
      }
    }
  }

  static async parseCritters() {
    try {
      src_logger/* default.info */.Z.info("Munching monsters!");
      const result = await parseCritters();
      (0,utils/* munchNote */.ep)(`Finished importing ${result} monsters!`, true);
      (0,utils/* munchNote */.ep)("");
      DDBMuncher.enableButtons();
    } catch (error) {
      src_logger/* default.error */.Z.error(error);
      src_logger/* default.error */.Z.error(error.stack);
    }

  }

  static async parseSpells() {
    try {
      src_logger/* default.info */.Z.info("Munching spells!");
      await parseSpells();
      (0,utils/* munchNote */.ep)(`Finished importing spells!`, true);
      (0,utils/* munchNote */.ep)("");
      DDBMuncher.enableButtons();
    } catch (error) {
      src_logger/* default.error */.Z.error(error);
      src_logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseItems() {
    try {
      src_logger/* default.info */.Z.info("Munching items!");
      await parseItems();
      (0,utils/* munchNote */.ep)(`Finished importing items!`, true);
      (0,utils/* munchNote */.ep)("");
      DDBMuncher.enableButtons();
    } catch (error) {
      src_logger/* default.error */.Z.error(error);
      src_logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseRaces() {
    try {
      src_logger/* default.info */.Z.info("Munching races!");
      const result = await parseRaces();
      (0,utils/* munchNote */.ep)(`Finished importing ${result.length} races and features!`, true);
      (0,utils/* munchNote */.ep)("");
      DDBMuncher.enableButtons();
    } catch (error) {
      src_logger/* default.error */.Z.error(error);
      src_logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseFeats() {
    try {
      src_logger/* default.info */.Z.info("Munching feats!");
      const result = await parseFeats();
      (0,utils/* munchNote */.ep)(`Finished importing ${result.length} feats!`, true);
      (0,utils/* munchNote */.ep)("");
      DDBMuncher.enableButtons();
    } catch (error) {
      src_logger/* default.error */.Z.error(error);
      src_logger/* default.error */.Z.error(error.stack);
    }
  }


  static async parseClasses() {
    try {
      src_logger/* default.info */.Z.info("Munching classes!");
      const result = await parseClasses();
      (0,utils/* munchNote */.ep)(`Finished importing ${result.length} classes and features!`, true);
      (0,utils/* munchNote */.ep)("");
      DDBMuncher.enableButtons();
    } catch (error) {
      src_logger/* default.error */.Z.error(error);
      src_logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseFrames() {
    try {
      src_logger/* default.info */.Z.info("Munching frames!");
      const result = await parseFrames();
      (0,utils/* munchNote */.ep)(`Finished importing ${result.length} frames!`, true);
      (0,utils/* munchNote */.ep)("");
      DDBMuncher.enableButtons();
    } catch (error) {
      src_logger/* default.error */.Z.error(error);
      src_logger/* default.error */.Z.error(error.stack);
    }
  }

  static async generateAdventureConfig() {
    try {
      src_logger/* default.info */.Z.info("Generating adventure config!");
      await downloadAdventureConfig();
      (0,utils/* munchNote */.ep)(`Downloading config file`, true);
      (0,utils/* munchNote */.ep)("");
      DDBMuncher.enableButtons();
    } catch (error) {
      src_logger/* default.error */.Z.error(error);
      src_logger/* default.error */.Z.error(error.stack);
    }
  }

  static async migrateCompendiumFolders(type) {
    src_logger/* default.info */.Z.info(`Migrating ${type} compendium`);
    await (0,compendiumFolders/* migrateExistingCompendium */.W3)(type);
    (0,utils/* munchNote */.ep)(`Migrating complete.`, true);
    DDBMuncher.enableButtons();
  }

  static async selectSources() {
    new DDBSources().render(true);
  }

  static async importAdventure() {
    new AdventureMunch().render(true);
  }

  getData() { // eslint-disable-line class-methods-use-this
    const resultData = getMuncherSettings();

    // console.warn(resultData);

    return resultData;
  }
}

;// CONCATENATED MODULE: ./src/lib/Settings.js






const POPUPS = {
  json: null,
  web: null,
};

function renderPopup(type, url) {
  if (POPUPS[type] && !POPUPS[type].close) {
    POPUPS[type].focus();
    POPUPS[type].location.href = url;
  } else {
    const ratio = window.innerWidth / window.innerHeight;
    const width = Math.round(window.innerWidth * 0.5);
    const height = Math.round(window.innerWidth * 0.5 * ratio);
    POPUPS[type] = window.open(
      url,
      "ddb_sheet_popup",
      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`
    );
  }
  return true;
}

function isSetupComplete(needsCobalt = true) {
  const uploadDir = game.settings.get("ddb-importer", "image-upload-directory");
  const dataDirSet = !utils/* BAD_DIRS.includes */.qd.includes(uploadDir);
  const cobalt = getCobalt() != "";
  const setupComplete = dataDirSet && (cobalt || !needsCobalt);
  return setupComplete;
}

async function linkToPatreon() {

  const proxy = game.settings.get("ddb-importer", "api-endpoint");
  const patreonId = "oXQUxnRAbV6mq2DXlsXY2uDYQpU-Ea2ds0G_5hIdi0Bou33ZRJgvV8Ub3zsEQcHp";
  const patreonAuthUrl = `${proxy}/patreon/auth`;
  const patreonScopes = encodeURI("identity identity[email]");

  const socketOptions = {
    transports: ['websocket', 'polling', 'flashsocket'],
    // reconnection: false,
    // reconnectionAttempts: 10,
  };
  const socket = io(`${proxy}/`, socketOptions);

  socket.on("connect", () => {
    src_logger/* default.debug */.Z.debug("DDB Muncher socketID", socket.id);
    const serverDetails = {
      id: socket.id,
      world: game.world.data.title,
      userId: game.userId,
    };
    socket.emit("register", serverDetails);

  });

  socket.on('registered', (data) => {
    src_logger/* default.info */.Z.info(`Foundry instance registered with DDB Muncher Proxy`);
    src_logger/* default.debug */.Z.debug(data);
    renderPopup("web", `https://www.patreon.com/oauth2/authorize?response_type=code&client_id=${patreonId}&redirect_uri=${patreonAuthUrl}&state=${data.userHash}&scope=${patreonScopes}`);
  });

  socket.on('auth', (data) => {
    src_logger/* default.debug */.Z.debug(`Response from auth socket!`, data);

    POPUPS["web"].close();

    game.settings.set("ddb-importer", "beta-key", data.key);
    game.settings.set("ddb-importer", "patreon-user", data.email);
    game.settings.set("ddb-importer", "patreon-tier", data.tier);

    $('#ddb-patreon-user').text(data.email);
    $('#ddb-patreon-tier').text(data.tier);
    $('#ddb-patreon-valid').text("True");
    $('#ddb-beta-key').val(data.key);

    socket.disconnect();
  });

  socket.on('error', (data) => {
    src_logger/* default.error */.Z.error(`Error Response from socket!`, data);
    socket.disconnect();
  });
}

function getDDBCampaigns(cobalt = null) {
  const cobaltCookie = cobalt ? cobalt : getCobalt();
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const body = { cobalt: cobaltCookie, betaKey: betaKey };

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/campaigns`, {
      method: "POST",
      cache: "no-cache",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => resolve(data.data))
      .catch((error) => {
        src_logger/* default.error */.Z.error(`Cobalt cookie check error`);
        src_logger/* default.error */.Z.error(error);
        src_logger/* default.error */.Z.error(error.stack);
        reject(error);
      });
  });

}

async function checkCobaltCookie(value) {
  const cookieStatus = await checkCobalt("", value);
  if (value !== "" && !cookieStatus.success) {
    $('#munching-task-setup').text(`Your Cobalt Cookie is invalid, please check that you pasted the right information.`);
    $('#ddb-importer-settings').css("height", "auto");
    throw new Error(`Your Cobalt Cookie is invalid, please check that you pasted the right information.`);
  }
  return cookieStatus;
}

async function refreshCampaigns(cobalt = null) {
  await checkCobaltCookie(cobalt);
  CONFIG.DDBI.CAMPAIGNS = await getDDBCampaigns(cobalt);
  return CONFIG.DDBI.CAMPAIGNS;
}

async function getAvailableCampaigns() {
  if (CONFIG.DDBI.CAMPAIGNS) return CONFIG.DDBI.CAMPAIGNS;
  const campaignId = (0,utils/* getCampaignId */.F9)();
  // eslint-disable-next-line require-atomic-updates
  CONFIG.DDBI.CAMPAIGNS = await getDDBCampaigns();

  if (!CONFIG.DDBI.CAMPAIGNS) return [];

  CONFIG.DDBI.CAMPAIGNS.forEach((campaign) => {
    const selected = campaign.id == campaignId;
    campaign.selected = selected;
  });
  return CONFIG.DDBI.CAMPAIGNS;
}

async function setCobaltCookie(value, local) {
  await checkCobaltCookie(value);
  await setCobalt(value);
  await game.settings.set("ddb-importer", "cobalt-cookie-local", local);
  const runCookieMigrate = local != game.settings.get("ddb-importer", "cobalt-cookie-local");
  if (runCookieMigrate && local) {
    moveCobaltToLocal();
  } else if (runCookieMigrate && !local) {
    moveCobaltToSettings();
  }

}

class DDBKeyChange extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-key-change";
    options.template = "modules/ddb-importer/handlebars/key-change.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Key Expiry";
  }

  activateListeners(html) {
    super.activateListeners(html);
    html.find("#patreon-button").click(async (event) => {
      event.preventDefault();
      linkToPatreon();
    });
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const key = game.settings.get("ddb-importer", "beta-key");
    const setupConfig = {
      "beta-key": key,
    };
    const patreonUser = game.settings.get("ddb-importer", "patreon-user");
    const check = await (0,utils/* getPatreonValidity */.my)(key);

    return {
      success: (check && check.success) ? check.success : false,
      message: (check && check.message) ? check.message : "Unable to check patreon key status",
      setupConfig: setupConfig,
      patreonLinked: patreonUser && patreonUser != "",
      patreonUser: patreonUser,
    };
  }

  /** @override */
  // eslint-disable-next-line no-unused-vars
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();
    const currentKey = game.settings.get("ddb-importer", "beta-key");
    if (currentKey !== formData['beta-key']) {
      await game.settings.set("ddb-importer", "beta-key", formData['beta-key']);
      await (0,utils/* setPatreonTier */.Q1)();
    }

    const callMuncher = game.settings.get("ddb-importer", "settings-call-muncher");

    if (callMuncher) {
      game.settings.set("ddb-importer", "settings-call-muncher", false);
      new DDBMuncher().render(true);
    }

  }
}

async function isValidKey() {
  let validKey = false;

  const key = game.settings.get("ddb-importer", "beta-key");
  if (key === "") {
    validKey = true;
  } else {
    const check = await (0,utils/* getPatreonValidity */.my)(key);
    if (check.success && check.data) {
      validKey = true;
    } else {
      validKey = false;
      game.settings.set("ddb-importer", "settings-call-muncher", true);
      new DDBKeyChange().render(true);
    }
  }
  return validKey;
}

class DDBCookie extends FormApplication {

  constructor(options, actor = null, localCobalt = false) {
    super(options);
    this.localCobalt = localCobalt;
    this.actor = actor;
  }

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-cobalt-change";
    options.template = "modules/ddb-importer/handlebars/cobalt.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Cobalt Cookie";
  }

  /** @override */
  async getData() {
    const keyPostFix = this.localCobalt && this.actor ? this.actor.id : null;
    const cobalt = getCobalt(keyPostFix);
    const cobaltStatus = cobalt == "" ? { success: true } : await checkCobalt();
    const expired = !cobaltStatus.success;

    return {
      expired: expired,
      cobaltCookie: cobalt,
      localCobalt: this.localCobalt && this.actor,
      actor: this.actor,
    };
  }

  /** @override */
  async _updateObject(event, formData) {
    event.preventDefault();
    const keyPostFix = this.localCobalt && this.actor ? this.actor.id : null;
    await setCobalt(formData['cobalt-cookie'], keyPostFix);

    const cobaltStatus = await checkCobalt();
    if (!cobaltStatus.success) {
      new DDBCookie().render(true);
    } else {
      const callMuncher = game.settings.get("ddb-importer", "settings-call-muncher");

      if (callMuncher) {
        game.settings.set("ddb-importer", "settings-call-muncher", false);
        new DDBMuncher().render(true);
      }
    }
  }
}


// eslint-disable-next-line no-unused-vars
Hooks.on("renderDDBSetup", (app, html, user) => {
  DirectoryPicker/* DirectoryPicker.processHtml */.B.processHtml(html);
});

// eslint-disable-next-line no-unused-vars
Hooks.on("renderma", (app, html, user) => {
  DirectoryPicker/* DirectoryPicker.processHtml */.B.processHtml(html);
});

class DDBSetup extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-settings";
    options.template = "modules/ddb-importer/handlebars/settings.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Settings";
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const cobalt = getCobalt();
    const isCobalt = cobalt != "";
    const cobaltStatus = await checkCobalt("", cobalt);
    const cobaltLocal = game.settings.get("ddb-importer", "cobalt-cookie-local");
    const hasKey = game.settings.get("ddb-importer", "beta-key") != "";
    const key = game.settings.get("ddb-importer", "beta-key");
    const campaignId = (0,utils/* getCampaignId */.F9)();
    const tier = game.settings.get("ddb-importer", "patreon-tier");
    const uploadDir = game.settings.get("ddb-importer", "image-upload-directory");
    const otherUploadDir = game.settings.get("ddb-importer", "other-image-upload-directory");
    const frameUploadDir = game.settings.get("ddb-importer", "frame-image-upload-directory");
    const dataDirSet = !utils/* BAD_DIRS.includes */.qd.includes(uploadDir) && !utils/* BAD_DIRS.includes */.qd.includes(otherUploadDir);
    const patreonUser = game.settings.get("ddb-importer", "patreon-user");
    const validKeyObject = hasKey ? await (0,utils/* getPatreonValidity */.my)(key) : false;
    const validKey = validKeyObject && validKeyObject.success && validKeyObject.data;
    const availableCampaigns = isCobalt && cobaltStatus.success ? await getAvailableCampaigns() : [];

    availableCampaigns.forEach((campaign) => {
      const selected = campaign.id == campaignId;
      campaign.selected = selected;
    });

    const setupConfig = {
      "image-upload-directory": uploadDir,
      "other-image-upload-directory": otherUploadDir,
      "frame-image-upload-directory": frameUploadDir,
      "cobalt-cookie": cobalt,
      "available-campaigns": availableCampaigns,
      "campaign-id": campaignId,
      "beta-key": key,
    };

    const setupComplete = dataDirSet && isCobalt;

    return {
      cobalt: isCobalt,
      cobaltLocal: cobaltLocal,
      setupConfig: setupConfig,
      setupComplete: setupComplete,
      tier: tier,
      patreonLinked: patreonUser && patreonUser != "",
      patreonUser: patreonUser,
      validKey: validKey,
    };
  }

  activateListeners(html) {
    super.activateListeners(html);
    html.find("#patreon-button").click(async (event) => {
      event.preventDefault();
      linkToPatreon();
    });
    html.find("#campaign-button").click(async (event) => {
      event.preventDefault();
      const cookie = html.find("#cobalt-cookie-input");
      const campaigns = await refreshCampaigns(cookie[0].value);
      let campaignList = `<option value="">Select campaign:</option>`;
      campaigns.forEach((campaign) => {
        campaignList += `<option value="${campaign.id}">${campaign.name} (${campaign.dmUsername}) - ${campaign.id}</option>\n`;
      });
      const list = html.find("#campaign-select");
      list[0].innerHTML = campaignList;
    });
    html.find("#check-cobalt-button").click(async (event) => {
      event.preventDefault();
      const cookie = html.find("#cobalt-cookie-input");
      if (cookie[0].value === undefined) throw new Error("undefined");
      const cobaltStatus = await checkCobalt("", cookie[0].value);
      const button = html.find("#check-cobalt-button");
      if (cobaltStatus.success) {
        button[0].innerHTML = "Check Cobalt Cookie - Success!";
      } else {
        button[0].innerHTML = "Check Cobalt Cookie - Failure!";
      }
    });


  }

  /** @override */
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();
    const imageDir = formData['image-upload-directory'];
    const campaignSelect = formData['campaign-select'];
    // console.warn(formData);
    const campaignId = campaignSelect == 0 ? "" : campaignSelect;
    const cobaltCookie = formData['cobalt-cookie'];
    const cobaltCookieLocal = formData['cobalt-cookie-local'];
    const otherImageDir = formData['other-image-upload-directory'];
    const frameImageDir = formData['frame-image-upload-directory'];
    const currentKey = game.settings.get("ddb-importer", "beta-key");

    if (currentKey !== formData['beta-key']) {
      await game.settings.set("ddb-importer", "beta-key", formData['beta-key']);
      await (0,utils/* setPatreonTier */.Q1)();
    }

    await game.settings.set("ddb-importer", "image-upload-directory", imageDir);
    await game.settings.set("ddb-importer", "other-image-upload-directory", otherImageDir);
    await game.settings.set("ddb-importer", "frame-image-upload-directory", frameImageDir);
    await game.settings.set("ddb-importer", "campaign-id", campaignId);

    await setCobaltCookie(cobaltCookie, cobaltCookieLocal);

    const imageDirSet = !utils/* BAD_DIRS.includes */.qd.includes(imageDir);
    const otherImageDirSet = !utils/* BAD_DIRS.includes */.qd.includes(otherImageDir);

    const callMuncher = game.settings.get("ddb-importer", "settings-call-muncher");

    if (!imageDirSet || !otherImageDirSet || !frameImageDir) {
      $('#munching-task-setup').text(`Please set the image upload directory(s) to something other than the root.`);
      $('#ddb-importer-settings').css("height", "auto");
      throw new Error(`Please set the image upload directory to something other than the root.`);
    } else if (callMuncher && cobaltCookie === "") {
      $('#munching-task-setup').text(`To use Muncher you need to set a Cobalt Cookie value!`);
      $('#ddb-importer-settings').css("height", "auto");
      throw new Error(`To use Muncher you need to set a Cobalt Cookie value!`);
    } else {
      DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(imageDir));
      DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(otherImageDir));
      DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(frameImageDir));

      if (callMuncher) {
        game.settings.set("ddb-importer", "settings-call-muncher", false);
        new DDBMuncher().render(true);
      }
    }
  }
}

function getCompendiumLookups(type, selected) {
  const excludedCompendiumPackages = [
    "dnd5e", "dae", "midiqol", "magicitems",
  ];

  const selections = game.packs
  .filter((pack) =>
    pack.documentClass.documentName === type &&
    !excludedCompendiumPackages.includes(pack.metadata.package)
  )
  .reduce((choices, pack) => {
    choices[pack.collection] = {
      label: `[${pack.metadata.package}] ${pack.metadata.label}`,
      selected: pack.collection === selected,
    };
    return choices;
  }, {});

  return selections;
}


class DDBCompendiumSetup extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-settings-compendium";
    options.template = "modules/ddb-importer/handlebars/compendium.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Compendium Settings";
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const settings = [
      {
        name: "auto-create-compendium",
        isChecked: game.settings.get("ddb-importer", "auto-create-compendium"),
        description: "Create default compendiums if missing?",
        enabled: true,
      },
    ];

    const compendiums = [
      {
        setting: "entity-class-compendium",
        name: "Classes",
        type: "item",
        current: game.settings.get("ddb-importer", "entity-class-compendium"),
        compendiums: getCompendiumLookups("Item", game.settings.get("ddb-importer", "entity-class-compendium")),
      },
      {
        setting: "entity-feature-compendium",
        name: "Class features",
        type: "item",
        current: game.settings.get("ddb-importer", "entity-feature-compendium"),
        compendiums: getCompendiumLookups("Item", game.settings.get("ddb-importer", "entity-feature-compendium")),
      },
      {
        setting: "entity-feat-compendium",
        name: "Feats",
        type: "item",
        current: game.settings.get("ddb-importer", "entity-feat-compendium"),
        compendiums: getCompendiumLookups("Item", game.settings.get("ddb-importer", "entity-feat-compendium")),
      },
      {
        setting: "entity-item-compendium",
        name: "Items",
        type: "item",
        current: game.settings.get("ddb-importer", "entity-item-compendium"),
        compendiums: getCompendiumLookups("Item", game.settings.get("ddb-importer", "entity-item-compendium")),
      },
      {
        setting: "entity-monster-compendium",
        name: "Monsters",
        type: "actor",
        current: game.settings.get("ddb-importer", "entity-monster-compendium"),
        compendiums: getCompendiumLookups("Actor", game.settings.get("ddb-importer", "entity-monster-compendium")),
      },
      {
        setting: "entity-race-compendium",
        name: "Races",
        type: "item",
        current: game.settings.get("ddb-importer", "entity-race-compendium"),
        compendiums: getCompendiumLookups("Item", game.settings.get("ddb-importer", "entity-race-compendium")),
      },
      {
        setting: "entity-trait-compendium",
        name: "Racial traits",
        type: "item",
        current: game.settings.get("ddb-importer", "entity-trait-compendium"),
        compendiums: getCompendiumLookups("Item", game.settings.get("ddb-importer", "entity-trait-compendium")),
      },
      {
        setting: "entity-spell-compendium",
        name: "Spells",
        type: "item",
        current: game.settings.get("ddb-importer", "entity-spell-compendium"),
        compendiums: getCompendiumLookups("Item", game.settings.get("ddb-importer", "entity-spell-compendium")),
      },
      {
        setting: "entity-table-compendium",
        name: "Tables",
        type: "RollTable",
        current: game.settings.get("ddb-importer", "entity-table-compendium"),
        compendiums: getCompendiumLookups("RollTable", game.settings.get("ddb-importer", "entity-table-compendium")),
      },
      {
        setting: "entity-override-compendium",
        name: "Override",
        type: "item",
        current: game.settings.get("ddb-importer", "entity-override-compendium"),
        compendiums: getCompendiumLookups("Item", game.settings.get("ddb-importer", "entity-override-compendium")),
      },
    ];

    return {
      settings: settings,
      compendiums: compendiums,
    };
  }

  /** @override */
  // eslint-disable-next-line no-unused-vars
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();
    for (const [key, value] of Object.entries(formData)) {
      game.settings.set("ddb-importer", key, value);
    }
  }
}


;// CONCATENATED MODULE: ./src/parser/character/filterModifiers.js


/**
 * UTILITY
 * Returns a string representation of friendlyTypename and friendlySubtypeName for an obj[]
 * @param {object[]} arr array of objects
 */
function extractInfo(arr) {
  return arr.map((e) => `${e.friendlyTypeName} (${e.friendlySubtypeName})`);
}

/**
 * Extracts basic character information
 * @param {object} data Character JSON
 * returns information about the classes this character chose, including
 * - {string} name
 * - {number} level
 * - {boolean} isStartingClass
 * - {object[]} modifiers (empty, will be filled later)
 * }
 */
function getClassInfo(data) {
  return data.classes.map((cls) => {
    return {
      name:
        cls.subclassDefinition && cls.subclassDefinition.name
          ? `${cls.definition.name} (${cls.subclassDefinition.name})`
          : cls.definition.name,
      level: cls.level,
      isStartingClass: cls.isStartingClass,
      modifiers: [],
    };
  });
}

/**
 * Gets all class features up to a certain class level
 * @param {obj} cls character.classes[] entry
 * @param {*} classLevel level requirement up to which the class features should be extracted
 */
function filterModifiers_getClassFeatures(cls, classLevel = 20) {
  if (
    cls.subclassDefinition &&
    cls.subclassDefinition.classFeatures &&
    Array.isArray(cls.subclassDefinition.classFeatures)
  ) {
    const subclassFeatures = cls.subclassDefinition.classFeatures.map((subclassFeature) => {
      subclassFeature.className = cls.definition.name;
      subclassFeature.subclassName = cls.subclassDefinition.name;
      return subclassFeature;
    });
    const result = cls.classFeatures
      .map((feature) => {
        const f = feature.definition;
        f.className = cls.definition.name;
        f.subclassName = null;
        return f;
      })
      .concat(subclassFeatures)
      .filter((classFeature) => classFeature.requiredLevel <= classLevel)
      .sort((a, b) => a.requiredLevel - b.requiredLevel);
    return result;
  } else {
    const result = cls.classFeatures
      .map((feature) => {
        const f = feature.definition;
        f.className = cls.definition.name;
        f.subclassName = null;
        return f;
      })
      .filter((classFeature) => classFeature.requiredLevel <= classLevel)
      .sort((a, b) => a.requiredLevel - b.requiredLevel);
    return result;
  }
}

/**
 * Gets all class options chosen
 * @param {obj} optionns character.options.classes entry
 */
// function getChosenOptionIds(options) {
//   return options.map((option) => {
//     return option.definition.id;
//   });
// }

/**
 * Checks if a given class is the starting class of this character
 * @param {object} data character data
 * @param {string} className name of the class to check
 * @returns {boolean} true of the class is a starting class, false otherwise
 */
function isStartingClass(data, className) {
  return data.classes.find((cls) => cls.definition.name === className && cls.isStartingClass);
}

/**
 * Gets all class modifiers for a given character
 * This filters out all modifiers that do not have an entry in the class features passed in
 * For multiclassing characters, it checks if the given class is the starting class or a multiclass,
 *    then the `.availableToMulticlass` is queried if this modifier is enabled or not
 * @param {obj} cls character.classes[] entry
 * @param {*} classLevel level requirement up to which the class features should be extracted
 */
function getClassModifiers(data, classFeatures, isStartingClass = false) {
  const modifiers = data.modifiers.class.filter((classModifier) => {
    // check the class from which this modifier came
    const componentId = classModifier.componentId;
    const feature = classFeatures.find((feature) => feature.id === componentId);
    if (feature !== undefined) {
      const isFeatureAvailable = classModifier.availableToMulticlass ? true : isStartingClass;
      logger.debug(
        `${isFeatureAvailable ? "  [  AVAIL]" : "  [UNAVAIL]"} Modifier found: ${classModifier.friendlyTypeName} (${
          classModifier.friendlySubtypeName
        })`
      );
      return isFeatureAvailable;
    }
    return false;
  });

  return modifiers;
}

function getAllClassFeatures(data) {
  return data.classes
  .map((cls) => {
    return filterModifiers_getClassFeatures(cls, cls.level);
  })
  .flat();
}

function getClassOptionModifiers(data) {
  const classFeatures = getAllClassFeatures(data);

  const modifiers = data.modifiers.class.filter((classModifier) => {
    const componentId = classModifier.componentId;
    const feature = classFeatures.find((feature) => feature.id === componentId);

    if (feature === undefined) {
      logger.debug(`Modifier found: ${classModifier.friendlyTypeName} (${classModifier.friendlySubtypeName})`);
      return true;
    }
    return false;
  });

  return modifiers;
}

/**
 * Filters the modifiers with the utility functions above
 * @param {object} data character data
 * @returns {[object[]]} an array containing an array of filtered modifiers, grouped by class
 */
function filterModifiers(data, classInfo) {
  // get the classFeatures for all classes
  data.classes.forEach((cls, index) => {
    const features = filterModifiers_getClassFeatures(cls, cls.level);
    classInfo[index].modifiers = getClassModifiers(data, features, isStartingClass(data, cls.definition.name));
  });
  return classInfo;
}

function fixCharacterLevels(data) {
  const classInfo = getClassInfo(data.character);
  const filteredClassInfo = filterModifiers(data.character, classInfo);
  let classModifiers = getClassOptionModifiers(data.character, classInfo);

  filteredClassInfo.forEach((cls) => {
    logger.debug(`${cls.isStartingClass ? "Starting Class" : "Multiclass"}: [lvl${cls.level}] ${cls.name} `);
    logger.debug(
      extractInfo(cls.modifiers)
        .map((s) => `    ${s}`)
        .join("\n")
    );
    classModifiers = classModifiers.concat(cls.modifiers);
  });
  data.character.modifiers.class = classModifiers;
  return data;
}

;// CONCATENATED MODULE: ./src/parser/character/ac.js






/**
 * This excludes shields
 * @param {} data
 */
function isArmored(data) {
  return (
    data.character.inventory.filter(
      (item) => item.equipped && item.definition.armorClass && item.definition.armorTypeId !== 4
    ).length >= 1
  );
}

function getMinimumBaseAC(modifiers) {
  let hasBaseArmor = modifiers.filter(
    (modifier) => modifier.type === "set" && modifier.subType === "minimum-base-armor" && modifier.isGranted
  );
  let baseAC = [];
  hasBaseArmor.forEach((base) => {
    baseAC.push(base.value);
  });
  return baseAC;
}

function getBaseArmor(ac, armorType, name = "Racial") {
  return {
    definition: {
      name: `Base Armor - ${name}`,
      type: armorType,
      armorClass: ac,
      armorTypeId: dictionary/* default.equipment.armorType.find */.Z.equipment.armorType.find((id) => id.name === armorType).id,
      grantedModifiers: [],
      canAttune: false,
      filterType: "Armor",
    },
    isAttuned: false,
  };
}

function getEquippedAC(equippedGear) {
  return equippedGear.reduce((prev, item) => {
    let ac = 0;
    // regular armor
    if (item.definition.armorClass) {
      ac += item.definition.armorClass;
    }

    // magical armor
    const usingArmorACEffects = game.settings.get("ddb-importer", "character-update-policy-generate-ac-armor-effects");
    const usingItemEffects = game.settings.get("ddb-importer", "character-update-policy-add-item-effects");

    const daeItemEffects = (usingItemEffects &&
      item.equipped && item.definition.filterType !== "Armor"
    );
    const daeInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("dae");
    const daeArmorACEffects = usingArmorACEffects && daeInstalled;
    if ((!daeArmorACEffects && !daeItemEffects) && item.definition.grantedModifiers) {
      let isAvailable = false;
      // does an item need attuning
      if (item.definition.canAttune === true) {
        if (item.isAttuned === true) {
          isAvailable = true;
        }
      } else {
        isAvailable = true;
      }

      if (isAvailable) {
        item.definition.grantedModifiers.forEach((modifier) => {
          if (modifier.type === "bonus" && modifier.subType === "armor-class") {
            // add this to armor AC
            ac += modifier.value;
          }
        });
      }
    }
    return prev + ac;
  }, 0);
}

// returns an array of ac values from provided array of modifiers
function getUnarmoredAC(modifiers, character) {
  let unarmoredACValues = [];
  let isUnarmored = modifiers.filter(
    (modifier) => modifier.type === "set" && modifier.subType === "unarmored-armor-class" && modifier.isGranted
  );
  // if (isUnarmored.length === 0) {
  //   // Some items will have an unarmoured bonus, but won't set a base, so if we are in this
  //   // situation, we add a default base ac
  //   isUnarmored.push({
  //     statId: 2,
  //     value: 0,
  //   });
  // }

  const maxUnamoredDexMods = modifiers.filter(
    (modifier) => modifier.type === "set" && modifier.subType === "ac-max-dex-modifier" && modifier.isGranted
  ).map((mods) => mods.value);
  const maxUnamoredDexMod = Math.min(...maxUnamoredDexMods, 20);

  // console.log(`Max Dex: ${maxUnamoredDexMod}`);
  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;

  isUnarmored.forEach((unarmored) => {
    let unarmoredACValue = 10;
    // +DEX
    // for a case of setting unarmoured ac, the dex won't detract
    unarmoredACValue += Math.max(0, Math.min(characterAbilities.dex.mod, maxUnamoredDexMod));
    // +WIS or +CON, if monk or barbarian, draconic resilience === null

    // console.log(`Unarmoured AC Value: ${unarmoredACValue}`);
    // console.log(unarmored);

    if (unarmored.statId !== null) {
      let ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === unarmored.statId);
      unarmoredACValue += characterAbilities[ability.value].mod;
    } else {
      // others are picked up here e.g. Draconic Resilience
      unarmoredACValue += unarmored.value;
    }
    unarmoredACValues.push(unarmoredACValue);
  });
  // console.warn(unarmoredACValues);
  return unarmoredACValues;
}

// returns an array of ac values from provided array of modifiers
function getArmoredACBonuses(modifiers, character) {
  let armoredACBonuses = [];
  const armoredBonuses = modifiers.filter(
    (modifier) => modifier.subType === "armored-armor-class" && modifier.isGranted
  );
  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;

  armoredBonuses.forEach((armoredBonus) => {
    let armoredACBonus = 0;
    if (armoredBonus.statId !== null) {
      let ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === armoredBonus.statId);
      armoredACBonus += characterAbilities[ability.value].mod;
    } else {
      armoredACBonus += armoredBonus.value;
    }
    armoredACBonuses.push(armoredACBonus);
  });
  return armoredACBonuses;
}

function getDualWieldAC(data, modifiers) {
  const dualWielding = data.character.characterValues.some((cv) => {
    const equipped = data.character.inventory.some((item) => item.equipped && item.id == cv.valueId);
    const dualWielding = cv.typeId === 18;
    return equipped && dualWielding;
  });
  let dualWieldBonus = 0;

  if (dualWielding) {
    src_utils/* default.filterModifiers */.Z.filterModifiers(modifiers, "bonus", "dual-wield-armor-class", ["", null], true).forEach((bonus) => {
      dualWieldBonus += bonus.value;
    });
  }

  return dualWieldBonus;
}

// eslint-disable-next-line complexity
function calculateACOptions(data, character, calculatedArmor) {
  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;
  let actorBase = 10 + characterAbilities.dex.mod;
  // generated AC effects
  let effects = [];
  // array to assemble possible AC values
  let armorClassValues = [];
  // max holders
  let maxType = "Unarmored";
  let maxValue = actorBase;

  // the presumption here is that you can only wear a shield and a single
  // additional 'armor' piece. in DDB it's possible to equip multiple armor
  // types and it works out the best AC for you
  // we also want to handle unarmored for monks etc.
  // we might have multiple shields "equipped" by accident, so work out
  // the best one
  for (var armor = 0; armor < calculatedArmor.armors.length; armor++) {
    // getEquippedAC fetches any magical AC boost on the items passed
    let armorAC = getEquippedAC([calculatedArmor.armors[armor]]);
    let shieldMod = 0;

    if (calculatedArmor.shields.length !== 0) {
      let maxAC = armorAC;
      for (var shield = 0; shield < calculatedArmor.shields.length; shield++) {
        const combinedAC = getEquippedAC([calculatedArmor.armors[armor], calculatedArmor.shields[shield]]);
        if (combinedAC > maxAC) {
          shieldMod = combinedAC - armorAC;
          maxAC = combinedAC;
        }
      }
      armorAC = maxAC;
    }

    // Determine final AC values based on AC Type
    // Light Armor: AC + DEX
    // Medium Armor: AC + DEX (max 2)
    // Heavy Armor: AC only
    // Unarmored Defense: Dex mod already included in calculation

    // sometimes the type field can be blank in DDB
    if (!calculatedArmor.armors[armor].definition.type || calculatedArmor.armors[armor].definition.type === "") {
      const armourTypeId = calculatedArmor.armors[armor].definition.armorTypeId;
      const acType = dictionary/* default.equipment.armorType.find */.Z.equipment.armorType.find((a) => a.id === armourTypeId);
      if (acType) calculatedArmor.armors[armor].definition.type = acType.name;
    }
    let effect = null;
    let acValue;

    switch (calculatedArmor.armors[armor].definition.type) {
      case "Natural Armor": {
        let acCalc = 0;
        // Tortles don't get to add an unarmored ac bonus for their shell
        const ignoreUnarmouredACBonus = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "ignore", "unarmored-dex-ac-bonus");
        if (ignoreUnarmouredACBonus) {
          acCalc = armorAC + calculatedArmor.miscACBonus;
          // console.log(armorAC);
          // console.log(gearAC);
          // console.log(miscACBonus);
        } else {
          acCalc = armorAC + calculatedArmor.miscACBonus + calculatedArmor.unarmoredACBonus;
        }
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + calculatedArmor.gearAC,
          type: "Natural",
          acCalc,
          shieldMod,
        };
        if (acCalc > actorBase) actorBase = acCalc - shieldMod;
        effect = (0,acEffects/* generateFixedACEffect */.LY)(acValue.value, `AC ${calculatedArmor.armors[armor].definition.name} (Natural): ${acValue.value}`, true);
        break;
      }
      case "Unarmored Defense": {
        const acCalc = armorAC + calculatedArmor.miscACBonus + calculatedArmor.unarmoredACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + calculatedArmor.gearAC,
          type: "Unarmored Defense",
          acCalc,
          shieldMod,
        };
        if (acCalc > actorBase) actorBase = acCalc - shieldMod;
        effect = (0,acEffects/* generateFixedACEffect */.LY)(acValue.value, `AC ${calculatedArmor.armors[armor].definition.name} (Unarmored Defense): ${acValue.value}`);
        break;
      }
      case "Unarmored": {
        const base = armorAC + calculatedArmor.miscACBonus + calculatedArmor.unarmoredACBonus;
        const acCalc = base + characterAbilities.dex.mod;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + calculatedArmor.gearAC,
          type: "Unarmored",
          acCalc,
          shieldMod,
        };
        if (acCalc > actorBase) actorBase = acCalc - shieldMod;
        effect = (0,acEffects/* generateFixedACEffect */.LY)(`${acValue.value} + @abilities.dex.mod`, `AC ${calculatedArmor.armors[armor].definition.name} (Unarmored): ${acValue.value}`, true, 15);
        break;
      }
      case "Heavy Armor": {
        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc,
          type: "Heavy",
          acCalc,
          shieldMod,
        };
        effect = (0,acEffects/* generateFixedACEffect */.LY)(acValue.value, `AC ${calculatedArmor.armors[armor].definition.name} (Heavy): ${acValue.value}`);
        break;
      }
      case "Medium Armor": {
        const maxDexMedium = Math.max(...src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "set", "ac-max-dex-armored-modifier", ["", null], true)
          .map((mod) => mod.value), 2);
        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + Math.min(maxDexMedium, characterAbilities.dex.mod),
          type: "Medium",
          acCalc,
          shieldMod,
        };
        effect = (0,acEffects/* generateFixedACEffect */.LY)(`${acCalc} + {@abilities.dex.mod, ${maxDexMedium}}kl`, `AC ${calculatedArmor.armors[armor].definition.name} (Medium): ${acValue.value}`);
        break;
      }
      case "Light Armor": {
        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + characterAbilities.dex.mod,
          type: "Light",
          acCalc,
          shieldMod,
        };
        effect = (0,acEffects/* generateFixedACEffect */.LY)(`${acCalc} + @abilities.dex.mod`, `AC ${calculatedArmor.armors[armor].definition.name} (Light): ${acValue.value}`);
        break;
      }
      default: {
        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + characterAbilities.dex.mod,
          type: "Other",
          acCalc,
          shieldMod,
        };
        effects = (0,acEffects/* generateFixedACEffect */.LY)(`${acCalc} + @abilities.dex.mod`, `AC ${calculatedArmor.armors[armor].definition.name}: ${acValue.value}`, false, 22);
        break;
      }
    }
    if (effect) {
      effect.flags.ddbimporter.itemId = calculatedArmor.armors[armor].id;
      effect.flags.ddbimporter.entityTypeId = calculatedArmor.armors[armor].entityTypeId;
      effects.push(effect);
    }
    armorClassValues.push(acValue);
    if (acValue.value >= maxValue) {
      maxType = acValue.type;
      maxValue = acValue.value;
    }
  }

  src_logger/* default.debug */.Z.debug("Final AC Choices:", armorClassValues);
  return {
    actorBase,
    armorClassValues,
    effects,
    maxType,
    maxValue,
  };
}

function getArmorClass(ddb, character) {
  const overRideAC = ddb.character.characterValues.find((val) => val.typeId === 1);

  if (overRideAC) {
    const overRideEffect = (0,acEffects/* generateFixedACEffect */.LY)(overRideAC.value, `AC Override: ${overRideAC.value}`);
    return {
      fixed: {
        type: "Number",
        label: "Armor Class",
        value: overRideAC.value,
      },
      base: overRideAC.value,
      effects: [overRideEffect],
      override: {
        flat: overRideAC.value,
        calc: "default",
        formula: "",
      },
      auto: {
        flat: overRideAC.value,
        calc: "default",
        formula: "",
      },
    };
  }

  const usingEffects = game.settings.get("ddb-importer", "character-update-policy-generate-ac-armor-effects");
  const daeInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("dae");
  const daeEffects = usingEffects && daeInstalled;

  // get a list of equipped armor
  // we make a distinction so we can loop over armor
  let equippedArmor = ddb.character.inventory.filter(
    (item) => item.equipped && item.definition.filterType === "Armor"
  );
  let baseAC = 10;
  // for things like fighters fighting style
  let miscACBonus = 0;
  // lets get equipped gear
  const equippedGear = ddb.character.inventory.filter(
    (item) => item.equipped && item.definition.filterType !== "Armor"
  );
  const unarmoredACBonus = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "bonus", "unarmored-armor-class")
    .reduce((prev, cur) => prev + cur.value, 0);

  // lets get the AC for all our non-armored gear, we'll add this later
  const gearAC = getEquippedAC(equippedGear);

  // While not wearing armor, lets see if we have special abilities
  if (!isArmored(ddb)) {
    // unarmored abilities from Class/Race?
    const unarmoredSources = [
      src_utils/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(ddb),
      ddb.character.modifiers.race,
      ddb.character.modifiers.feat,
      src_utils/* default.getActiveItemModifiers */.Z.getActiveItemModifiers(ddb, !daeEffects),
    ];
    unarmoredSources.forEach((modifiers) => {
      const unarmoredAC = Math.max(getUnarmoredAC(modifiers, character));
      if (unarmoredAC) {
        // we add this as an armored type so we can get magical item bonuses
        // e.g. ring of protection
        equippedArmor.push(getBaseArmor(unarmoredAC, "Unarmored Defense", "Unarmored defense"));
      }
    });
  } else {
    // check for things like fighters fighting style defense
    const armorBonusSources = [src_utils/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(ddb), ddb.character.modifiers.race];
    armorBonusSources.forEach((modifiers) => {
      const armoredACBonuses = getArmoredACBonuses(modifiers, character);
      miscACBonus += armoredACBonuses.reduce((a, b) => a + b, 0);
    });
  }

  // Generic AC bonuses like Warforfed Integrated Protection
  // item modifiers are loaded by ac calcs
  const miscModifiers = [
    src_utils/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(ddb),
    ddb.character.modifiers.race,
    ddb.character.modifiers.background,
    ddb.character.modifiers.feat,
  ];

  src_utils/* default.filterModifiers */.Z.filterModifiers(miscModifiers, "bonus", "armor-class", ["", null], true).forEach((bonus) => {
    miscACBonus += bonus.value;
  });

  miscACBonus += ddb.character.characterValues.filter((value) =>
    value.typeId === 3 || value.typeId === 2
  ).map((val) => val.value).reduce((a, b) => a + b, 0);

  miscACBonus += getDualWieldAC(ddb, miscModifiers);

  // Each racial armor appears to be slightly different!
  // We care about Tortles and Lizardfolk here as they can use shields, but their
  // modifier is set differently
  switch (ddb.character.race.fullName) {
    case "Lizardfolk":
      baseAC = Math.max(getUnarmoredAC(ddb.character.modifiers.race, character));
      equippedArmor.push(getBaseArmor(baseAC, "Natural Armor", "Lizardfolk"));
      break;
    case "Tortle":
      baseAC = Math.max(getMinimumBaseAC(ddb.character.modifiers.race, character), getUnarmoredAC(ddb.character.modifiers.race, character));
      equippedArmor.push(getBaseArmor(baseAC, "Natural Armor", "Tortle"));
      break;
    default:
      equippedArmor.push(getBaseArmor(baseAC, "Unarmored"));
  }

  const shields = equippedArmor.filter((shield) => shield.definition.armorTypeId === 4);
  const armors = equippedArmor.filter((armour) => armour.definition.armorTypeId !== 4);

  src_logger/* default.debug */.Z.debug("Calculated GearAC: " + gearAC);
  src_logger/* default.debug */.Z.debug("Unarmoured AC Bonus:" + unarmoredACBonus);
  src_logger/* default.debug */.Z.debug("Calculated MiscACBonus: " + miscACBonus);
  src_logger/* default.debug */.Z.debug("Equipped AC Options: ", equippedArmor);
  src_logger/* default.debug */.Z.debug("Armors: ", armors);
  src_logger/* default.debug */.Z.debug("Shields: ", shields);

  const calculatedArmor = {
    gearAC,
    unarmoredACBonus,
    miscACBonus,
    equippedArmor,
    armors,
    shields,
  };
  const results = calculateACOptions(ddb, character, calculatedArmor);

  src_logger/* default.debug */.Z.debug("Final AC Results:", results);
  // get the max AC we can use from our various computed values
  // const max = Math.max(...results.armorClassValues.map((type) => type.value));

  //
  // DND5E.armorClasses = {
  //   "default": {


  // const draconic = ddb.classes[0].classFeatures[1].definition
  const classFeatures = getAllClassFeatures(ddb.character);
  src_logger/* default.debug */.Z.debug("Class features", classFeatures);

  let calc = "default";
  let flat = null;
  if (classFeatures.some((kf) =>
    kf.className === "Sorcerer" &&
    kf.subclassName === "Draconic Bloodline" &&
    kf.name === "Draconic Resilience"
  )) calc = "draconic";

  if (classFeatures.some((kf) =>
    kf.className === "Monk" &&
    kf.subclassName === null &&
    kf.name === "Unarmored Defense"
  )) calc = "unarmoredMonk";

  if (classFeatures.some((kf) =>
    kf.className === "Barbarian" &&
    kf.subclassName === null &&
    kf.name === "Unarmored Defense"
  )) calc = "unarmoredBarb";

  const naturalACAllowed = src_utils/* default.versionCompare */.Z.versionCompare(game.data.system.data.version, "1.4.2") >= 0;
  if (naturalACAllowed && results.maxType === "Natural") {
    calc = "natural";
    flat = results.actorBase;
  }

  const acResults = {
    fixed: {
      type: "Number",
      label: "Armor Class",
      value: results.maxValue,
    },
    base: results.actorBase,
    effects: results.effects,
    override: {
      flat: results.maxValue,
      calc: "default",
      formula: "",
    },
    auto: {
      flat,
      calc,
      formula: "",
    },
  };
  src_logger/* default.debug */.Z.debug("AC Results:", acResults);

  return acResults;
}

;// CONCATENATED MODULE: ./src/parser/character/specialTraits.js


function getSpecialTraits(data) {
  let results = {
    powerfulBuild: false,
    savageAttacks: false,
    elvenAccuracy: false,
    halflingLucky: false,
    initiativeAdv: false,
    initiativeAlert: false,
    jackOfAllTrades: false,
    weaponCriticalThreshold: 20,
    observantFeat: false,
    remarkableAthlete: false,
    reliableTalent: false,
    diamondSoul: false,
    meleeCriticalDamageDice: 0,
  };

  // powerful build/equine build
  results.powerfulBuild = data.character.race.racialTraits.some(
    (trait) => trait.definition.name === "Equine Build" || trait.definition.name === "Powerful Build"
  );

  // savage attacks
  const savageAttacks = data.character.race.racialTraits.some((trait) => trait.definition.name === "Savage Attacks");
  results.savageAttacks = savageAttacks;
  if (savageAttacks) results.meleeCriticalDamageDice += 1;

  // halfling lucky
  results.halflingLucky = data.character.race.racialTraits.some((trait) => trait.definition.name === "Lucky");

  // elven accuracy
  results.elvenAccuracy = data.character.feats.some((feat) => feat.definition.name === "Elven Accuracy");

  // alert feat
  results.initiativeAlert = data.character.feats.some((feat) => feat.definition.name === "Alert");

  // advantage on initiative
  results.initiativeAdv = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "advantage", "initiative").length > 0;

  // initiative half prof
  results.initiativeHalfProf = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "half-proficiency", "initiative").length > 0;

  // observant
  results.observantFeat = data.character.feats.some((feat) => feat.definition.name === "Observant");

  // weapon critical threshold
  // fighter improved crit
  // remarkable athlete
  data.character.classes.forEach((cls) => {
    if (cls.subclassDefinition) {
      // Improved Critical
      const improvedCritical = cls.subclassDefinition.classFeatures.some(
        (feature) => feature.name === "Improved Critical" && cls.level >= feature.requiredLevel
      );
      const superiorCritical = cls.subclassDefinition.classFeatures.some(
        (feature) => feature.name === "Superior Critical" && cls.level >= feature.requiredLevel
      );

      if (superiorCritical) {
        results.weaponCriticalThreshold = 18;
      } else if (improvedCritical && results.weaponCriticalThreshold > 19) {
        results.weaponCriticalThreshold = 19;
      }

      // Remarkable Athlete
      results.remarkableAthlete = results.remarkableAthlete || cls.subclassDefinition.classFeatures.some(
        (feature) => feature.name === "Remarkable Athlete" && cls.level >= feature.requiredLevel
      );
    }

    // Brutal Critical
    results.meleeCriticalDamageDice += cls.definition.classFeatures.filter(
      (feature) => feature.name === "Brutal Critical" && cls.level >= feature.requiredLevel
    ).length;

    // Diamond Soul
    results.diamondSoul = results.diamondSoul || cls.definition.classFeatures.some(
      (feature) => feature.name === "Diamond Soul" && cls.level >= feature.requiredLevel
    );

    // Jack of All Trades
    results.jackOfAllTrades = results.jackOfAllTrades || cls.definition.classFeatures.some(
      (feature) => feature.name === "Jack of All Trades" && cls.level >= feature.requiredLevel
    );

    // Reliable Talent
    results.reliableTalent = results.reliableTalent || cls.definition.classFeatures.some(
      (feature) => feature.name === "Reliable Talent" && cls.level >= feature.requiredLevel
    );
  });

  return results;
}

// EXTERNAL MODULE: ./src/parser/character/skills.js
var skills = __webpack_require__(597);
;// CONCATENATED MODULE: ./src/parser/character/spellCasting.js



// is there a spell casting ability?
let hasSpellCastingAbility = (spellCastingAbilityId) => {
  return dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === spellCastingAbilityId) !== undefined;
};

// convert spellcasting ability id to string used by foundry
let convertSpellCastingAbilityId = (spellCastingAbilityId) => {
  return dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === spellCastingAbilityId).value;
};

function getSpellCasting(data, character) {
  let result = [];
  data.character.classSpells.forEach((playerClass) => {
    let classInfo = data.character.classes.find((cls) => cls.id === playerClass.characterClassId);
    let spellCastingAbility = undefined;
    if (hasSpellCastingAbility(classInfo.definition.spellCastingAbilityId)) {
      // check to see if class has a spell casting ability
      spellCastingAbility = convertSpellCastingAbilityId(classInfo.definition.spellCastingAbilityId);
    } else if (
      classInfo.subclassDefinition &&
      hasSpellCastingAbility(classInfo.subclassDefinition.spellCastingAbilityId)
    ) {
      // some subclasses attach a spellcasting ability, e.g. Arcane Trickster
      spellCastingAbility = convertSpellCastingAbilityId(classInfo.subclassDefinition.spellCastingAbilityId);
    }
    if (spellCastingAbility !== undefined) {
      const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;
      let abilityModifier = src_utils/* default.calculateModifier */.Z.calculateModifier(characterAbilities[spellCastingAbility].value);
      result.push({ label: spellCastingAbility, value: abilityModifier });
    }
  });
  // we need to decide on one spellcasting ability, so we take the one with the highest modifier
  if (result.length === 0) {
    return "";
  } else {
    return result
      .sort((a, b) => {
        if (a.value > b.value) return -1;
        if (a.value < b.value) return 1;
        return 0;
      })
      .map((entry) => entry.label)[0];
  }
}

function getSpellDC(data, character) {
  if (character.data.attributes.spellcasting === "") {
    return 10;
  } else {
    const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;
    return 8 + characterAbilities[character.data.attributes.spellcasting].mod + character.data.attributes.prof;
  }
}

function getSpellSlots(data) {
  let spellSlots = {};
  // get the caster information from all classes and subclasses
  let getCasterInfo = () => {
    return data.character.classes
      .filter((cls) => {
        return cls.definition.canCastSpells || (cls.subclassDefinition && cls.subclassDefinition.canCastSpells);
      })
      .map((cls) => {
        // the class total level
        let casterLevel = cls.level;
        // class name
        const name = cls.definition.name;

        // get the casting level if the character is a multiclassed spellcaster
        if (cls.definition.spellRules && cls.definition.spellRules.multiClassSpellSlotDivisor) {
          casterLevel = Math.floor(casterLevel / cls.definition.spellRules.multiClassSpellSlotDivisor);
        } else {
          casterLevel = 0;
        }
        // Blood hunters are weird
        if (["Blood Hunter"].includes(name)) {
          casterLevel = cls.level;
        }

        const cantrips =
          cls.definition.spellRules &&
          cls.definition.spellRules.levelCantripsKnownMaxes &&
          Array.isArray(cls.definition.spellRules.levelCantripsKnownMaxes)
            ? cls.definition.spellRules.levelCantripsKnownMaxes[casterLevel + 1]
            : 0;

        if (["Warlock", "Blood Hunter"].includes(name)) {
          // pact casting doesn't count towards multiclass spells casting
          // we still add an entry to get cantrip info
          const levelSpellSlots = cls.definition.spellRules.levelSpellSlots[casterLevel];
          const maxLevel = levelSpellSlots.indexOf(Math.max(...levelSpellSlots)) + 1;
          const maxSlots = Math.max(...levelSpellSlots);
          const currentSlots = data.character.pactMagic.find((pact) => pact.level === maxLevel).used;
          if (["Blood Hunter"].includes(name)) {
            spellSlots.pact = { value: maxSlots - currentSlots, max: maxSlots, override: maxSlots };
          } else {
            spellSlots.pact = { value: maxSlots - currentSlots, max: maxSlots };
          }
          return {
            name: name,
            casterLevel: 0,
            slots: cls.definition.spellRules.levelSpellSlots[0],
            cantrips: cantrips,
          };
        } else {
          return {
            name: name,
            casterLevel: casterLevel,
            slots: cls.definition.spellRules.levelSpellSlots[cls.level],
            cantrips: cantrips,
          };
        }
      });
  };

  let casterInfo = getCasterInfo(data);

  let result = null;
  if (casterInfo.length !== 1) {
    const multiClassSpellSlots = [
      [0, 0, 0, 0, 0, 0, 0, 0, 0], // 0
      [2, 0, 0, 0, 0, 0, 0, 0, 0], // 1
      [3, 0, 0, 0, 0, 0, 0, 0, 0], // 2
      [4, 2, 0, 0, 0, 0, 0, 0, 0], // 3
      [4, 3, 0, 0, 0, 0, 0, 0, 0], // 4
      [4, 3, 2, 0, 0, 0, 0, 0, 0], // 5
      [4, 3, 3, 0, 0, 0, 0, 0, 0], // 6
      [4, 3, 3, 1, 0, 0, 0, 0, 0], // 7
      [4, 3, 3, 2, 0, 0, 0, 0, 0], // 8
      [4, 3, 3, 3, 1, 0, 0, 0, 0], // 9
      [4, 3, 3, 3, 2, 0, 0, 0, 0], // 10
      [4, 3, 3, 3, 2, 1, 0, 0, 0], // 11
      [4, 3, 3, 3, 2, 1, 0, 0, 0], // 12
      [4, 3, 3, 3, 2, 1, 1, 0, 0], // 13
      [4, 3, 3, 3, 2, 1, 1, 0, 0], // 14
      [4, 3, 3, 3, 2, 1, 1, 1, 0], // 15
      [4, 3, 3, 3, 2, 1, 1, 1, 0], // 16
      [4, 3, 3, 3, 2, 1, 1, 1, 1], // 17
      [4, 3, 3, 3, 3, 1, 1, 1, 1], // 18
      [4, 3, 3, 3, 3, 2, 1, 1, 1], // 19
      [4, 3, 3, 3, 3, 2, 2, 1, 1], // 20
    ];
    const casterLevelTotal = casterInfo.reduce((prev, cur) => prev + cur.casterLevel, 0);
    const cantripsTotal = casterInfo.reduce((prev, cur) => prev + cur.cantrips, 0);
    result = [cantripsTotal, ...multiClassSpellSlots[casterLevelTotal]];
  } else {
    result = [casterInfo[0].cantrips, ...casterInfo[0].slots];
  }

  for (let i = 0; i < result.length; i++) {
    const currentSlots = data.character.spellSlots.filter((slot) => slot.level === i).map((slot) => slot.used) || 0;
    spellSlots["spell" + i] = {
      value: result[i] - currentSlots,
      max: result[i],
    };
  }
  return spellSlots;
}

;// CONCATENATED MODULE: ./src/parser/character/hp.js


function getHitpoints(data, character) {
  const constitutionHP = character.flags.ddbimporter.dndbeyond.effectAbilities.con.mod * character.flags.ddbimporter.dndbeyond.totalLevels;
  let baseHitPoints = data.character.baseHitPoints || 0;
  const bonusHitPoints = data.character.bonusHitPoints || 0;
  const overrideHitPoints = data.character.overrideHitPoints || 0;
  const removedHitPoints = data.character.removedHitPoints || 0;
  const temporaryHitPoints = data.character.temporaryHitPoints || 0;

  // get all hit points features
  const bonusHitPointFeatures = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "bonus", "hit-points-per-level");
  const bonusHitPointFeaturesWithEffects = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "bonus", "hit-points-per-level", ["", null], true);

  // get their values
  const bonusHitPointValues = bonusHitPointFeatures.map((bonus) => {
    const cls = src_utils/* default.findClassByFeatureId */.Z.findClassByFeatureId(data, bonus.componentId);
    if (cls) {
      return cls.level * bonus.value;
    } else {
      return character.flags.ddbimporter.dndbeyond.totalLevels * bonus.value;
    }
  });

  const bonusHitPointValuesWithEffects = bonusHitPointFeaturesWithEffects.map((bonus) => {
    const cls = src_utils/* default.findClassByFeatureId */.Z.findClassByFeatureId(data, bonus.componentId);
    if (cls) {
      return cls.level * bonus.value;
    } else {
      return character.flags.ddbimporter.dndbeyond.totalLevels * bonus.value;
    }
  });

  // sum up the bonus HP per class level
  const totalBonusHitPoints = bonusHitPointValues.reduce((prev, cur) => prev + cur, 0);
  const totalBonusHPWithEffects = bonusHitPointValuesWithEffects.reduce((prev, cur) => prev + cur, 0);
  const bonusHPEffectDiff = totalBonusHPWithEffects - totalBonusHitPoints;

  // add the result to the base hitpoints
  baseHitPoints += totalBonusHitPoints;

  const totalHitPoints = overrideHitPoints === 0
    ? constitutionHP + baseHitPoints + bonusHitPoints
    : overrideHitPoints;

  return {
    value: totalHitPoints - removedHitPoints + bonusHPEffectDiff,
    min: 0,
    max: totalHitPoints,
    temp: temporaryHitPoints,
    tempmax: bonusHitPoints,
  };
}

function getHitDice(data) {
  let used = data.character.classes.reduce((prev, cls) => prev + cls.hitDiceUsed, 0);
  let total = data.character.classes.reduce((prev, cls) => prev + cls.level, 0);
  return total - used;
}

;// CONCATENATED MODULE: ./src/parser/character/speed.js




function getSpeed(data) {
  // For all processing, we take into account the regular movement types of this character
  let movementTypes = {};
  for (let type in data.character.race.weightSpeeds.normal) {
    // if (data.character.race.weightSpeeds.normal[type] !== 0) {
      movementTypes[type] = data.character.race.weightSpeeds.normal[type];
    // }
  }

  // get bonus speed mods
  let restriction = ["", null, "unless your speed is already higher"];
  // Check for equipped Heavy Armor
  const wearingHeavy = data.character.inventory.some((item) => item.equipped && item.definition.type === "Heavy Armor");
  // Accounts for Barbarian Class Feature - Fast Movement
  if (!wearingHeavy) restriction.push("while you arenâ€™t wearing heavy armor");

  // build base speeds
  for (let type in movementTypes) {
    // is there a 'inntate-speed-[type]ing' race/class modifier?
    const innateType = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.type === type).innate;
    let innateSpeeds = data.character.modifiers.race.filter(
      (modifier) => modifier.type === "set" && modifier.subType === `innate-speed-${innateType}`
    );
    let base = movementTypes[type];

    innateSpeeds.forEach((speed) => {
      // take the highest value
      if (speed.value > base) {
        base = speed.value;
      }
    });

    // overwrite the (perhaps) changed value
    movementTypes[type] = base;
  }

  const bonusSpeed = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "bonus", "speed", restriction)
    .reduce((speed, feat) => speed + feat.value, 0);

  // speed bonuses
  for (let type in movementTypes) {
    let innateBonus = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "bonus", `speed-${type}ing`, restriction)
      .reduce((speed, feat) => speed + feat.value, 0);

    // overwrite the (perhaps) changed value
    if (movementTypes[type] !== 0) movementTypes[type] += bonusSpeed + innateBonus;
  }

  // unarmored movement for barbarians and monks
  if (!isArmored(data)) {
    src_utils/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(data)
      .filter((modifier) => modifier.type === "bonus" && modifier.subType === "unarmored-movement")
      .forEach((bonusSpeed) => {
        for (let type in movementTypes) {
          if (movementTypes[type] !== 0) movementTypes[type] += bonusSpeed.value;
        }
      });
  }

  // new ranger deft explorer sets speeds, leaves value null, use walking
  for (let type in movementTypes) {
    const innateType = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.type === type).innate;
    // is there a 'inntate-speed-[type]ing' race/class modifier?
    let innateSpeeds = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "set", `innate-speed-${innateType}`, restriction);
    let base = movementTypes[type];

    innateSpeeds.forEach((speed) => {
      // take the highest value
      if (speed.value > base) {
        base = speed.value;
      } else if (!speed.value && movementTypes['walk']) {
        base = movementTypes['walk'];
      }
    });

    // overwrite the (perhaps) changed value
    movementTypes[type] = base;
  }


  // is there a custom seed over-ride?
  if (data.character.customSpeeds) {
    data.character.customSpeeds.forEach((speed) => {
      const type = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.id === speed.movementId).type;
      if (speed.distance) {
        movementTypes[type] = speed.distance;
      }
    });
  }

  let special = "";
  for (let type in movementTypes) {
    if (type !== "walk") {
      special += src_utils/* default.capitalize */.Z.capitalize(type) + " " + movementTypes[type] + " ft, ";
    }
  }
  special = special.substr(0, special.length - 2);

  const movement = {
    burrow: movementTypes['burrow'] || 0,
    climb: movementTypes['climb'] || 0,
    fly: movementTypes['fly'] || 0,
    swim: movementTypes['swim'] || 0,
    walk: movementTypes['walk'] || 0,
    units: "ft",
    hover: false,
  };

  return {
    speed: {
      value: movementTypes.walk + " ft",
      special: special,
    },
    movement: movement,
  };
}

;// CONCATENATED MODULE: ./src/parser/character/bio.js


function getBackground(data) {
  if (data.character.background.hasCustomBackground === false) {
    if (data.character.background.definition !== null) {
      return data.character.background.definition.name || "";
    } else {
      return "";
    }
  } else {
    return data.character.background.customBackground.name || "";
  }
}

function getTrait(data) {
  let result = data.character.traits.personalityTraits;
  if (result !== null) {
    return result;
  } else {
    result = "";
  }
  return result;
}

function getIdeal(data) {
  let result = data.character.traits.ideals;
  if (result !== null) {
    return result;
  } else {
    result = "";
  }
  return result;
}

function getCharacteristics(data) {
  let characteristicBlurb = "";
  if (data.character.gender) characteristicBlurb += `Gender: ${data.character.gender}\n`;
  if (data.character.eyes) characteristicBlurb += `Eyes: ${data.character.eyes}\n`;
  if (data.character.height) characteristicBlurb += `Height: ${data.character.height}\n`;
  if (data.character.faith) characteristicBlurb += `Faith: ${data.character.faith}\n`;
  if (data.character.hair) characteristicBlurb += `Hair: ${data.character.hair}\n`;
  if (data.character.skin) characteristicBlurb += `Skin: ${data.character.skin}\n`;
  if (data.character.age) characteristicBlurb += `Age: ${data.character.age}\n`;
  if (data.character.weight) characteristicBlurb += `Weight: ${data.character.weight}\n`;
  return characteristicBlurb;
}

function getAppearance(data) {
  let result = getCharacteristics(data);
  if (result && result !== "") result += "\n";
  result += data.character.traits.appearance;
  if (result !== null) {
    return result;
  } else {
    result = "";
  }
  return result;
}

function getBond(data) {
  let result = data.character.traits.bonds;
  if (result !== null) {
    return result;
  } else {
    result = "";
  }
  return result;
}

function getFlaw(data) {
  let result = data.character.traits.flaws;
  if (result !== null) {
    return result;
  } else {
    result = "";
  }
  return result;
}

/**
 * Gets the character's alignment
 * Defaults to Neutral, if not set in DDB
 * @todo: returns .name right now, should switch to .value once the DND5E options are fully implemented
 */
function getAlignment(data) {
  let alignmentID = data.character.alignmentId || 5;
  let alignment = dictionary/* default.character.alignments.find */.Z.character.alignments.find((alignment) => alignment.id === alignmentID); // DDBUtils.alignmentIdtoAlignment(alignmentID);
  return alignment.name;
}

function getBackgroundData(data) {
  let result = {
    name: "Background",
    description: "",
    id: null,
    entityTypeId: null,
    featuresId: null,
    featuresEntityTypeId: null,
    characteristicsId: null,
    characteristicsEntityTypeId: null,
    definition: {
      name: "Background",
      description: "",
      id: null,
      entityTypeId: null,
    },
  };

  let bg = null;
  if (data.character.background.hasCustomBackground === true) {
    bg = data.character.background.customBackground;
  } else if (data.character.background.definition !== null) {
    bg = data.character.background.definition;
  } else {
    bg = data.character.background.customBackground;
    if (bg.id) result.id = bg.id;
    if (bg.entityTypeId) result.entityTypeId = bg.entityTypeId;
    return result;
  }


  if (bg.id) result.id = bg.id;
  if (bg.entityTypeId) result.entityTypeId = bg.entityTypeId;

  if (bg.name) {
    result.name = `Background: ${bg.name}`;
    result.description = `<h1>Background: ${bg.name}</h1>`;
  }

  if (bg.description) {
    result.description += `<p>${bg.description}</p>`;
  } else if (bg.shortDescription) {
    result.description += bg.shortDescription.replace("\r\n", "");
  }
  if (bg.definition) result.definition = bg.definition;

  if (data.character.background.hasCustomBackground === true) {
    if (bg.featuresBackground) {
      result.description += `<h2>${bg.featuresBackground.name}</h2>`;
      result.description += bg.featuresBackground.shortDescription.replace("\r\n", "");
      result.description += `<h3>${bg.featuresBackground.featureName}</h3>`;
      result.description += bg.featuresBackground.featureDescription.replace("\r\n", "");
      result.featuresId = bg.featuresBackground.id;
      result.id = bg.featuresBackground.id;
      result.featuresEntityTypeId = bg.featuresBackground.entityTypeId;
      result.definition = bg.featuresBackground;
    }
    if (
      bg.characteristicsBackground &&
      bg.featuresBackground &&
      bg.featuresBackground.entityTypeId != bg.characteristicsBackground.entityTypeId
    ) {
      result.description += `<h2>${bg.characteristicsBackground.name}</h2>`;
      result.description += bg.characteristicsBackground.shortDescription.replace("\r\n", "");
      result.description += `<h3>${bg.characteristicsBackground.featureName}</h3>`;
      result.description += bg.characteristicsBackground.featureDescription.replace("\r\n", "");
      result.characteristicsId = bg.characteristicsBackground.id;
      result.characteristicsEntityTypeId = bg.characteristicsBackground.entityTypeId;
    }
  }
  if (bg.featureName) {
    result.description += `<h2>${bg.featureName}</h2>`;
    result.description += bg.featureDescription.replace("\r\n", "");
  }
  // if (bg.skillProficienciesDescription && bg.skillProficienciesDescription !== "") {
  //   result.description += `<h2>Skill Proficiencies</h2>`;
  //   result.description += bg.skillProficienciesDescription.replace("\r\n", "");
  // }
  // if (bg.languagesDescription && bg.languagesDescription !== "") {
  //   result.description += `<h2>Languages</h2>`;
  //   result.description += bg.languagesDescription.replace("\r\n", "");
  // }
  // if (bg.toolProficienciesDescription && bg.toolProficienciesDescription !== "") {
  //   result.description += `<h2>Tool Proficiencies</h2>`;
  //   result.description += bg.toolProficienciesDescription.replace("\r\n", "");
  // }
  // if (bg.equipmentDescription && bg.equipmentDescription !== "") {
  //   result.description += `<h2>Starting Equipment</h2>`;
  //   result.description += bg.equipmentDescription.replace("\r\n", "");
  // }
  // if (bg.organization && bg.organization !== "") {
  //   result.description += `<h2>Organization</h2>`;
  //   result.description += bg.organization.replace("\r\n", "");
  // }
  // if (bg.contractsDescription && bg.contractsDescription !== "") {
  //   result.description += `<h2>Contracts</h2>`;
  //   result.description += bg.contractsDescription.replace("\r\n", "");
  // }
  // if (bg.spellsPreDescription && bg.spellsPreDescription !== "") {
  //   result.description += `<h2>Spells</h2>`;
  //   result.description += bg.spellsPreDescription.replace("\r\n", "");
  // }
  // if (bg.suggestedCharacteristicsDescription && bg.suggestedCharacteristicsDescription !== "") {
  //   result.description += `<h2>Suggested Characteristics</h2>`;
  //   result.description += bg.suggestedCharacteristicsDescription.replace("\r\n", "");
  // }
  // if (bg.personalityTraits && bg.personalityTraits.length > 0) {
  //   result.description += `<h>Suggested Personality Traits</h2>`;
  //   result.description += bg.personalityTraits.map((trait) => `<p>${trait}</p>`).join("");
  // }
  // if (bg.ideals && bg.ideals.length > 0) {
  //   result.description += `<h>Suggested Ideals</h2>`;
  //   result.description += bg.ideals.map((trait) => `<p>${trait}</p>`);
  // }
  // if (bg.bonds && bg.bonds.length > 0) {
  //   result.description += `<h>Suggested Bonds</h2>`;
  //   result.description += bg.bonds.map((trait) => `<p>${trait}</p>`);
  // }
  // if (bg.flaws && bg.flaws.length > 0) {
  //   result.description += `<h>Suggested Flaws</h2>`;
  //   result.description += bg.flaws.map((trait) => `<p>${trait}</p>`);
  // }
  if (bg.spellListIds) result.spellListIds = bg.spellListIds;
  result.definition.name = result.name;
  result.definition.description = result.description;
  return result;
}

function getBiography(data) {
  // let format = (heading, text) => {
  //   text = text
  //     .split("\n")
  //     .map((text) => `<p>${text}</p>`)
  //     .join("");
  //   return `<h2>${heading}</h2>${text}`;
  // };

  let backstory =
    data.character.notes.backstory !== null ? "<h1>Backstory</h1><p>" + data.character.notes.backstory + "</p>" : "";

  // if (data.character.background.hasCustomBackground === true) {
  //   let bg = data.character.background.customBackground;

  //   let result = bg.name ? "<h1>Background: " + bg.name + "</h1>" : "";
  //   result += bg.description ? "<p>" + bg.description + "</p>" : "";
  //   if (bg.featuresBackground) {
  //     result += "<h2>" + bg.featuresBackground.name + "</h2>";
  //     result += bg.featuresBackground.shortDescription.replace("\r\n", "");
  //     result += "<h3>" + bg.featuresBackground.featureName + "</h3>";
  //     result += bg.featuresBackground.featureDescription.replace("\r\n", "");
  //   }
  //   if (
  //     bg.characteristicsBackground &&
  //     bg.featuresBackground &&
  //     bg.featuresBackground.entityTypeId != bg.characteristicsBackground.entityTypeId
  //   ) {
  //     result += "<h2>" + bg.characteristicsBackground.name + "</h2>";
  //     result += bg.characteristicsBackground.shortDescription.replace("\r\n", "");
  //     result += "<h3>" + bg.characteristicsBackground.featureName + "</h3>";
  //     result += bg.characteristicsBackground.featureDescription.replace("\r\n", "");
  //   }

  //   return {
  //     public: result + backstory,
  //     value: result + backstory,
  //   };
  // } else if (data.character.background.definition !== null) {
  //   let bg = data.character.background.definition;

  //   let result = "<h1>Background: " + bg.name + "</h1>";
  //   result += bg.shortDescription.replace("\r\n", "");
  //   if (bg.featureName) {
  //     result += "<h2>" + bg.featureName + "</h2>";
  //     result += bg.featureDescription.replace("\r\n", "");
  //   }
  //   return {
  //     public: result + backstory,
  //     value: result + backstory,
  //   };
  // } else {
  //   return {
  //     public: "" + backstory,
  //     value: "" + backstory,
  //   };
  // }

  let background = getBackgroundData(data);
  return {
    public: background.description + backstory,
    value: background.description + backstory,
  };
}

function getDescription(data) {
  const result = {
    "gender": data.character.gender || "",
    "age": data.character.age || "",
    "height": data.character.height || "",
    "weight": data.character.weight || "",
    "eyes": data.character.eyes || "",
    "skin": data.character.skin || "",
    "hair": data.character.hair || "",
  };

  return result;
}


// "attunedItemsMax": "3",
// "attunedItemsCount": 0,
// "maxPreparedSpells": null,

;// CONCATENATED MODULE: ./src/parser/character/globalBonuses.js


/**
 * Gets global bonuses to attacks and damage
 * Supply a list of maps that have the fvtt tyoe and ddb sub type, e,g,
 * { fvttType: "attack", ddbSubType: "magic" }
  {
    "attack": "",
    "damage": "",
  },
 * @param {*} lookupTable
 * @param {*} data
 * @param {*} character
 */
function getGlobalBonusAttackModifiers(lookupTable, data, character) {
  let result = {
    attack: "",
    damage: "",
  };
  const diceFormula = /\d*d\d*/;

  let lookupResults = {
    attack: {
      sum: 0,
      diceString: "",
    },
    damage: {
      sum: 0,
      diceString: "",
    },
  };

  lookupTable.forEach((b) => {
    const lookupResult = src_utils/* default.getModifierSum */.Z.getModifierSum(src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "bonus", b.ddbSubType), character);
    const lookupMatch = diceFormula.test(lookupResult);

    // if a match then a dice string
    if (lookupMatch) {
      lookupResults[b.fvttType].diceString += lookupResult === "" ? lookupResult : " + " + lookupResult;
    } else {
      lookupResults[b.fvttType].sum += lookupResult;
    }
  });

  // loop through outputs from lookups and build a response
  ["attack", "damage"].forEach((fvttType) => {
    if (lookupResults[fvttType].diceString === "") {
      if (lookupResults[fvttType].sum !== 0) {
        result[fvttType] = lookupResults[fvttType].sum;
      }
    } else {
      result[fvttType] = lookupResults[fvttType].diceString;
      if (lookupResults[fvttType].sum !== 0) {
        result[fvttType] += " + " + lookupResults[fvttType].sum;
      }
    }
  });

  return result;
}

/**
 * Gets global bonuses to spell attacks and damage
 * Most likely from items such as wand of the warmage
 * supply type as 'ranged' or 'melee'
  {
    "attack": "",
    "damage": "",
  },
 * @param {*} data
 * @param {*} character
 * @param {*} type
 */
function getBonusSpellAttacks(data, character, type) {
  // I haven't found any matching global spell damage boosting mods in ddb
  const bonusLookups = [
    { fvttType: "attack", ddbSubType: "spell-attacks" },
    { fvttType: "attack", ddbSubType: `${type}-spell-attacks` },
  ];

  return getGlobalBonusAttackModifiers(bonusLookups, data, character);
}

/**
 * Gets global bonuses to weapon attacks and damage
 * Most likely from items such as wand of the warmage
 * supply type as 'ranged' or 'melee'
  {
    "attack": "",
    "damage": "",
  },
 * @param {*} data
 * @param {*} character
 * @param {*} type
 */
function getBonusWeaponAttacks(data, character, type) {
  // global melee damage is not a ddb type, in that it's likely to be
  // type specific. The only class one I know of is the Paladin Improved Smite
  // which will be handled in the weapon import later.
  const bonusLookups = [
    { fvttType: "attack", ddbSubType: `${type}-attacks` },
    { fvttType: "attack", ddbSubType: "weapon-attacks" },
    { fvttType: "attack", ddbSubType: `${type}-weapon-attacks` },
  ];

  return getGlobalBonusAttackModifiers(bonusLookups, data, character);
}

/**
 * Gets global bonuses to ability checks, saves and skills
 * These can come from Paladin auras or items etc
  "abilities": {
    "check": "",
    "save": "",
    "skill": ""
  },
 * @param {*} data
 * @param {*} character
 */
function getBonusAbilities(data, character) {
  let result = {};
  const bonusLookup = [
    { fvttType: "check", ddbSubType: "ability-checks" },
    { fvttType: "save", ddbSubType: "saving-throws" },
    { fvttType: "skill", ddbSubType: "skill-checks" },
  ];

  bonusLookup.forEach((b) => {
    const bonus = src_utils/* default.getModifierSum */.Z.getModifierSum(src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "bonus", b.ddbSubType), character);
    result[b.fvttType] = bonus === 0 ? "" : bonus;
  });
  return result;
}

function getBonusSpellDC(data, character) {
  let result = {};
  const bonusLookup = [{ fvttType: "dc", ddbSubType: "spell-save-dc" }];

  bonusLookup.forEach((b) => {
    result[b.fvttType] = src_utils/* default.getModifierSum */.Z.getModifierSum(src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "bonus", b.ddbSubType), character);
  });

  return result;
}

// EXTERNAL MODULE: ./src/parser/character/proficiencies.js
var proficiencies = __webpack_require__(248);
;// CONCATENATED MODULE: ./src/parser/character/abilities.js

// import logger from "../../logger.js";


function getOverrides(data) {
  let result = {};
  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
    result[ability.value] = data.character.overrideStats.find((stat) => stat.id === ability.id).value || 0;
  });
  return result;
}

/**
 * Retrieves character abilities, including proficiency on saving throws
 * @param {obj} data JSON Import
 * @param {obj} includeExcludedEffects Include effects from dae added items?
 */
function parseAbilities(data, includeExcludedEffects = false) {
  // go through every ability
  // console.error(`Abilities effects: ${includeExcludedEffects}`);

  let result = {};
  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
    result[ability.value] = {
      value: 0,
      min: 3,
      max: 20,
      proficient: 0,
    };
    // console.warn(ability.value);

    const stat = data.character.stats.find((stat) => stat.id === ability.id).value || 0;
    const abilityScoreMaxBonus = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "bonus", "ability-score-maximum", [null, ""], includeExcludedEffects)
      .filter((mod) => mod.statId === ability.id)
      .reduce((prev, cur) => prev + cur.value, 0);
    const bonus = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "bonus", `${ability.long}-score`, [null, "", "+2 to score maximum", "+4 to score maximum", "+2 to maximum score", "+4 to maximum score"], includeExcludedEffects)
      .filter((mod) => mod.entityId === ability.id)
      .reduce((prev, cur) => prev + cur.value, 0);
    const setAbilities = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "set", `${ability.long}-score`, [null, "", "if not already higher"], includeExcludedEffects)
      .map((mod) => mod.value);
    const modRestrictions = [
      "Your maximum is now ",
      "Maximum of ",
    ];
    const cappedBonusExp = new RegExp(`(?:${modRestrictions.join("|")})(\\d*)`);
    const cappedBonus = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "bonus", `${ability.long}-score`, false, includeExcludedEffects)
      .filter((mod) =>
        mod.entityId === ability.id && mod.restriction &&
        modRestrictions.some((m) => mod.restriction.startsWith(m))
      )
      .reduce(
        (prev, cur) => {
          const restricted = cur.restriction ? cappedBonusExp.exec(cur.restriction) : undefined;
          const max = restricted ? restricted[1] : 20;
          return {
            value: prev.value + cur.value,
            cap: Math.max(prev.cap, max),
          };
        },
        { value: 0, cap: 20 + abilityScoreMaxBonus }
      );
    // applied regardless of cap
    const bonusStat = data.character.bonusStats.find((stat) => stat.id === ability.id).value || 0;
    // over rides all other calculations if present
    const overrideStat = data.character.overrideStats.find((stat) => stat.id === ability.id).value || 0;

    // console.warn(`${ability.value} - Include active effects: ${includeExcludedEffects}`);
    // console.log(`stat ${stat}`);
    // console.log(`bonus ${bonus}`);
    // console.log(`bonusStat ${bonusStat}`);
    // console.log(`overrideStat ${overrideStat}`);
    // console.log(`abilityScoreMaxBonus ${abilityScoreMaxBonus}`);
    // console.log(`setAbilities ${setAbilities}`);
    // console.log(setAbilities);
    // console.log(`cappedBonus ${cappedBonus}`);
    // console.log(cappedBonus);

    const setAbility = Math.max(...[0, ...setAbilities]);
    const calculatedStat = stat + bonus + cappedBonus.value;
    // bonus gets added regardlesss of normal caps
    const maxAdjustedStat = Math.min(cappedBonus.cap, calculatedStat) + bonusStat;
    // some items will set the ability score if lower
    const setAbilityState = maxAdjustedStat > setAbility ? maxAdjustedStat : setAbility;
    // Is there a hard over ride?
    const overRiddenStat = overrideStat === 0 ? setAbilityState : overrideStat;

    // console.log(`setAbility ${setAbility}`);
    // console.log(`calculatedStat ${calculatedStat}`);
    // console.log(`maxAdjustedStat ${maxAdjustedStat}`);
    // console.log(`setAbilityState ${setAbilityState}`);
    // console.log(`overRiddenStat ${overRiddenStat}`);

    const proficient = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "proficiency", `${ability.long}-saving-throws`, [null, ""], includeExcludedEffects).length > 0
        ? 1
        : 0;

    // update value, mod and proficiency
    result[ability.value].value = overRiddenStat;
    result[ability.value].mod = src_utils/* default.calculateModifier */.Z.calculateModifier(result[ability.value].value);
    result[ability.value].proficient = proficient;
    result[ability.value].max = Math.max(cappedBonus.cap, overRiddenStat);

  });

  const character = {
    data: {
      abilities: result,
    },
  };

  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {

    const checkBonusModifiers = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "bonus", `${ability.long}-ability-checks`, [null, ""], includeExcludedEffects);
    const checkBonus = src_utils/* default.getModifierSum */.Z.getModifierSum(checkBonusModifiers, character);

    const saveBonusModifiers = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "bonus", `${ability.long}-saving-throws`, [null, ""], includeExcludedEffects);
    const saveBonus = src_utils/* default.getModifierSum */.Z.getModifierSum(saveBonusModifiers, character);

    const bonuses = {
      check: checkBonus,
      save: saveBonus,
    };

    result[ability.value].bonuses = bonuses;

  });

  return result;
}

/**
 * Retrieves character abilities, including proficiency on saving throws
 * @param {obj} data JSON Import
 */
function getAbilities(data) {
  // go through every ability

  const result = {
    base: parseAbilities(data, false),
    withEffects: parseAbilities(data, true),
    overrides: getOverrides(data),
  };
  return result;
}

;// CONCATENATED MODULE: ./src/parser/character/senses.js




function getSensesMap(data) {
  let senses = {
    darkvision: 0,
    blindsight: 0,
    tremorsense: 0,
    truesight: 0,
    units: "ft",
    special: ""
  };

  // custom senses
  if (data.character.customSenses) {
    data.character.customSenses
      .filter((sense) => sense.distance)
      .forEach((sense) => {
        const s = dictionary/* default.character.senses.find */.Z.character.senses.find((s) => s.id === sense.senseId);
        if (s && sense.distance) {
          senses[s.name.toLowerCase()] = sense.distance;
        } else {
          senses.special += `${sense.distance}; `;
        }
      });
  }

  // Base senses
  for (const senseName in senses) {
    src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "set-base", senseName).forEach((sense) => {
      if (sense.value > senses[senseName]) {
        senses[senseName] = sense.value;
      }
    });
  }

  // Devils Sight gives bright light to 120 foot instead of normal darkvision
  src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "set-base", "darkvision", [
      "You can see normally in darkness, both magical and nonmagical",
    ])
    .forEach((sense) => {
      if (sense.value > senses['darkvision']) {
        senses['darkvision'] = sense.value;
        senses.special += "You can see normally in darkness, both magical and nonmagical.";
      }
    });

  // Magical bonuses and additional, e.g. Gloom Stalker
  src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "sense", "darkvision", ["", null, "plus 60 feet if wearer already has Darkvision"])
    .forEach((mod) => {
      const hasSense = mod.subType in senses;
      if (hasSense) {
        senses[mod.subType] += mod.value;
      } else {
        senses.special += ` ${mod.value},`;
      }
    });

  return senses;

}

function getSensesLookup(data) {
  // const low = "1.1.0";
  // const high = "1.2.0"

  // const compareLowHigh = utils.versionCompare(low, high);
  // const compareSame = utils.versionCompare(high, high);
  // const compareHighLow = utils.versionCompare(high, low);
  // console.warn(`${compareLowHigh}-${compareSame}-${compareHighLow}`);
  // // -1-0-1

  // dnd5e 1.2.0 introduced a different sense system
  let senses;

  try {
    senses = getSensesMap(data);
  } catch (err) {
    src_logger/* default.error */.Z.error(err);
    src_logger/* default.error */.Z.error(err.stack);
    throw new Error("Sense parsing failed. You might need to update your D&D 5e system to a newer version");
  }

  return senses;
}

function getSenses(data) {
  return getSensesMap(data);
}

;// CONCATENATED MODULE: ./src/parser/character/token.js




function getTokenSensesNew(data) {
  // Default to the most basic token setup.
  // everything else can be handled by the user / Token Mold
  let tokenData = {
    actorLink: true,
    name: data.character.name,
  };

  const senses = getSensesLookup(data);
  // darkvision: 0,
  // blindsight: 0,
  // tremorsense: 0,
  // truesight: 0,

  // These values in senses grant bright sight
  const devilSight = senses.special.includes("You can see normally in darkness");
  let brightSights = [senses.truesight, senses.blindsight];
  if (devilSight) brightSights.push(senses.darkvision);
  tokenData['brightSight'] = Math.max(...brightSights);

  // Darkvision
  tokenData['dimSight'] = senses.darkvision;

  return tokenData;
}

function getTokenSensesOld(data) {
  // Default to the most basic token setup.
  // everything else can be handled by the user / Token Mold
  let tokenData = {
    actorLink: true,
    name: data.character.name,
  };

  const senses = getSensesLookup(data);

  // These values in senses grant bright sight
  const brightSightValues = ["Truesight", "Blindsight", "Devils Sight"];

  if (senses.some((sense) => brightSightValues.includes(sense.name))) {
    let value = senses
      .filter((sense) => brightSightValues.includes(sense.name))
      .reduce((prev, cur) => (prev > cur.value ? prev : cur.value), 0);
    if (value) tokenData.brightSight = value;
  }

  // Darkvision
  if (senses.some((sense) => sense.name === "Darkvision")) {
    tokenData.dimSight = senses.find((sense) => sense.name === "Darkvision").value;
  }

  // finally, if no dimsight set, set to 0 as default is 30
  if (!tokenData.dimSight) tokenData.dimSight = 0;

  return tokenData;
}


function getToken(data) {
  try {
    const versionCompare = src_utils/* default.versionCompare */.Z.versionCompare(game.system.data.version, "1.2.0");

    return (versionCompare >= 0)
      ? getTokenSensesNew(data)
      : getTokenSensesOld(data);
  } catch (err) {
    src_logger/* default.error */.Z.error(err);
    src_logger/* default.error */.Z.error(err.stack);
    throw new Error("Please update your D&D 5e system to a newer version");
  }
}

;// CONCATENATED MODULE: ./src/parser/character/effects.js



function getDeathSaves (data) {
  return {
    success: data.character.deathSaves.successCount || 0,
    failure: data.character.deathSaves.failCount || 0,
  };
}

function getExhaustion(data) {
  let condition = data.character.conditions.find((condition) => (condition.id = 4));
  let level = condition ? condition.level : 0;
  return level;
}

let getGenericConditionAffect = (data, condition, typeId) => {
  const damageTypes = dictionary/* default.character.damageTypes.filter */.Z.character.damageTypes.filter((type) => type.kind === condition && type.type === typeId)
    .map((type) => type.value);

  let result = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, condition)
    .filter((modifier) => modifier.isGranted && damageTypes.includes(modifier.subType) &&
      (modifier.restriction === "" || !modifier.restriction))
    .map((modifier) => {
      const entry = dictionary/* default.character.damageTypes.find */.Z.character.damageTypes.find(
        (type) => type.type === typeId && type.kind === modifier.type && type.value === modifier.subType
      );
      return entry ? entry.foundryValue || entry.value : undefined;
    });

  result = result.concat(
    data.character.customDefenseAdjustments
      .filter((adjustment) => adjustment.type === typeId)
      .map((adjustment) => {
        const entry = dictionary/* default.character.damageTypes.find */.Z.character.damageTypes.find(
          (type) =>
            (type.id === adjustment.id || type.id === adjustment.adjustmentId) &&
            type.type === adjustment.type &&
            type.kind === condition
        );
        return entry ? entry.foundryValue || entry.value : undefined;
      })
      .filter((adjustment) => adjustment !== undefined)
  );

  return result;
};

function getDamageImmunities(data) {
  return {
    custom: "",
    value: getGenericConditionAffect(data, "immunity", 2),
  };
}

function getDamageResistances(data) {
  return {
    custom: "",
    value: getGenericConditionAffect(data, "resistance", 2),
  };
}

function getDamageVulnerabilities(data) {
  return {
    custom: "",
    value: getGenericConditionAffect(data, "vulnerability", 2),
  };
}

function getConditionImmunities(data) {
  // get Condition Immunities
  return {
    custom: "",
    value: getGenericConditionAffect(data, "immunity", 1),
  };
}

;// CONCATENATED MODULE: ./src/parser/character/resources.js


function getResources(data, character) {
  // get all resources
  let resources = [data.character.actions.race, data.character.actions.class, data.character.actions.feat]
    .flat()
    // let resources = data.character.actions.class
    .filter((action) =>
      action.limitedUse &&
      (action.limitedUse.maxUses || action.limitedUse.statModifierUsesId || action.limitedUse.useProficiencyBonus))
    .map((action) => {
      let maxUses = (action.limitedUse.maxUses && action.limitedUse.maxUses !== -1) ? action.limitedUse.maxUses : 0;

      if (action.limitedUse.statModifierUsesId) {
        const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find(
          (ability) => ability.id === action.limitedUse.statModifierUsesId
        ).value;

        switch (action.limitedUse.operator) {
          case 2: {
            maxUses *= character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
            break;
          }
          case 1:
          default:
            maxUses += character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
        }
      }

      if (action.limitedUse.useProficiencyBonus) {
        switch (action.limitedUse.proficiencyBonusOperator) {
          case 2: {
            maxUses *= character.data.attributes.prof;
            break;
          }
          case 1:
          default:
            maxUses += character.data.attributes.prof;
        }
      }

      return {
        label: action.name,
        value: maxUses - action.limitedUse.numberUsed,
        max: maxUses,
        sr: action.limitedUse.resetType === 1,
        lr: action.limitedUse.resetType === 1 || action.limitedUse.resetType === 2,
      };
    })
    // sort by maxUses, I guess one wants to track the most uses first, because it's used more often
    .sort((a, b) => {
      if (a.max > b.max) return -1;
      if (a.max < b.max) return 1;
      return 0;
    })
    // get only the first three
    .slice(0, 3);

  let result = {
    primary: resources.length >= 1 ? resources[0] : { value: 0, max: 0, sr: false, lr: false, label: "" },
    secondary: resources.length >= 2 ? resources[1] : { value: 0, max: 0, sr: false, lr: false, label: "" },
    tertiary: resources.length >= 3 ? resources[2] : { value: 0, max: 0, sr: false, lr: false, label: "" },
  };
  return result;
}

;// CONCATENATED MODULE: ./src/parser/character/size.js


function getSize(data) {
  let size = dictionary/* default.character.actorSizes.find */.Z.character.actorSizes.find(
    (size) => size.name === data.character.race.size || size.id === data.character.race.sizeId
  );
  return size ? size.value : "med";
}

;// CONCATENATED MODULE: ./src/parser/character/initiative.js


function getInitiative(data, character) {
  const initiativeBonus = src_utils/* default.getModifierSum */.Z.getModifierSum(src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "bonus", "initiative"), character);
  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;

  // If we have the alert Feat set, lets sub 5 so it's correct
  const initiative = character.flags.dnd5e.initiativeAlert
    ? {
        value: initiativeBonus - 5,
        bonus: 5, // used by FVTT internally
        mod: characterAbilities.dex.mod,
      }
    : {
        value: initiativeBonus,
        bonus: 0, // used by FVTT internally
        mod: characterAbilities.dex.mod,
      };

  return initiative;
}

;// CONCATENATED MODULE: ./src/parser/character/currency.js
function getCurrency(data) {
  return {
    pp: data.character.currencies.pp,
    gp: data.character.currencies.gp,
    ep: data.character.currencies.ep,
    sp: data.character.currencies.sp,
    cp: data.character.currencies.cp,
  };
}

;// CONCATENATED MODULE: ./src/parser/character/index.js


















// import { fixCharacterLevels } from "./filterModifiers.js";

function getCharacter(ddb) {
  // *************************************
  // PARSING THE CHARACTER
  // **************************************
  //
  // ddb = fixCharacterLevels(ddb);
  let character = {
    data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("character")),
    type: "character",
    effects: [],
    name: (ddb.character.name === "") ? "Hero With No Name" : ddb.character.name,
    // items: [],  // modified to check inventory analysis on update
    token: getToken(ddb),
    flags: {
      ddbimporter: {
        compendium: false,
        acEffects: [],
        baseAC: 10,
        dndbeyond: {
          totalLevels: ddb.character.classes.reduce((prev, cur) => prev + cur.level, 0),
          proficiencies: (0,proficiencies/* getProficiencies */.xg)(ddb),
          proficienciesIncludingEffects: (0,proficiencies/* getProficiencies */.xg)(ddb, true),
          roUrl: ddb.character.readonlyUrl,
          characterValues: ddb.character.characterValues,
          templateStrings: [],
        },
      },
    },
  };

    // proficiency
  // prettier-ignore
  character.data.attributes.prof = Math.ceil(1 + (0.25 * character.flags.ddbimporter.dndbeyond.totalLevels));

  // Get supported 5e feats and abilities
  // We do this first so we can check for them later
  character.flags.dnd5e = getSpecialTraits(ddb);

  // character abilities
  const abilityData = getAbilities(ddb);
  character.data.abilities = abilityData.base;
  character.flags.ddbimporter.dndbeyond.effectAbilities = abilityData.withEffects;
  character.flags.ddbimporter.dndbeyond.abilityOverrides = abilityData.overrides;

  // Hit Dice
  character.data.attributes.hd = getHitDice(ddb);

  // Death saves
  character.data.attributes.death = getDeathSaves(ddb);

  // exhaustion
  character.data.attributes.exhaustion = getExhaustion(ddb);

  // inspiration
  character.data.attributes.inspiration = ddb.character.inspiration;

  // armor class
  const autoAC = src_utils/* default.versionCompare */.Z.versionCompare(game.data.system.data.version, "1.4.0") >= 0;
  const ac = getArmorClass(ddb, character);
  // D&D5e v1.4.0 AC features
  if (autoAC) {
    character.data.attributes.ac = ac.auto;
  } else {
    character.data.attributes.ac = ac.fixed;
  }
  character.flags.ddbimporter.acEffects = ac.effects;
  character.flags.ddbimporter.baseAC = ac.base;
  character.flags.ddbimporter.autoAC = ac.auto;
  character.flags.ddbimporter.overrideAC = ac.override;

  // hitpoints
  character.data.attributes.hp = getHitpoints(ddb, character);

  // initiative
  character.data.attributes.init = getInitiative(ddb, character);

  // speeds
  const movement = getSpeed(ddb);
  character.data.attributes.movement = movement['movement'];
  character.data.attributes.senses = getSensesMap(ddb);

  // spellcasting
  character.data.attributes.spellcasting = getSpellCasting(ddb, character);

  // spelldc
  character.data.attributes.spelldc = getSpellDC(ddb, character);

  // resources
  character.data.resources = getResources(ddb, character);

  // details
  character.data.details.background = getBackground(ddb);

  // xp
  character.data.details.xp.value = ddb.character.currentXp;

  // Character Traits/Ideal/Bond and Flaw
  character.data.details.trait = getTrait(ddb);
  character.data.details.ideal = getIdeal(ddb);
  character.data.details.bond = getBond(ddb);
  character.data.details.flaw = getFlaw(ddb);
  character.data.details.appearance = getAppearance(ddb);

  Object.assign(character.data.details, getDescription(ddb));

  character.data.details.alignment = getAlignment(ddb);

  // bio
  character.data.details.biography = getBiography(ddb);
  character.data.details.race = ddb.character.race.fullName;

  // traits
  character.data.traits.weaponProf = (0,proficiencies/* getWeaponProficiencies */.JN)(ddb, character.flags.ddbimporter.dndbeyond.proficiencies);
  character.data.traits.armorProf = (0,proficiencies/* getArmorProficiencies */.jZ)(ddb, character.flags.ddbimporter.dndbeyond.proficiencies);
  character.data.traits.toolProf = (0,proficiencies/* getToolProficiencies */.bX)(ddb, character.flags.ddbimporter.dndbeyond.proficiencies);
  character.data.traits.size = getSize(ddb);
  character.data.traits.senses = getSenses(ddb);
  character.data.traits.languages = (0,proficiencies/* getLanguages */.Vb)(ddb);
  character.data.traits.di = getDamageImmunities(ddb);
  character.data.traits.dr = getDamageResistances(ddb);
  character.data.traits.dv = getDamageVulnerabilities(ddb);
  character.data.traits.ci = getConditionImmunities(ddb);

  character.data.currency = getCurrency(ddb);
  character.data.skills = (0,skills/* getSkills */.S)(ddb, character);
  character.data.spells = getSpellSlots(ddb);

  // Extra global bonuses
  // Extra bonuses
  character.data.bonuses.abilities = getBonusAbilities(ddb, character);
  // spell attacks
  character.data.bonuses.rsak = getBonusSpellAttacks(ddb, character, "ranged");
  character.data.bonuses.msak = getBonusSpellAttacks(ddb, character, "melee");
  // spell dc
  character.data.bonuses.spell = getBonusSpellDC(ddb, character);
  // melee weapon attacks
  character.data.bonuses.mwak = getBonusWeaponAttacks(ddb, character, "melee");
  // ranged weapon attacks
  // e.g. ranged fighting style
  character.data.bonuses.rwak = getBonusWeaponAttacks(ddb, character, "ranged");

  return character;
}

// EXTERNAL MODULE: ./src/parser/templateStrings.js
var templateStrings = __webpack_require__(959);
;// CONCATENATED MODULE: ./src/parser/features/special.js
// import DICTIONARY from "../../dictionary.js";
// import logger from "../../logger.js";





function generateFeatModifiers(ddb, ddbItem, choice, type) {
  // console.warn(ddbItem);
  // console.log(choice);
  if (ddbItem.grantedModifiers) return ddbItem;
  let modifierItem = JSON.parse(JSON.stringify(ddbItem));
  const modifiers = [
    src_utils/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(ddb, true, true),
    src_utils/* default.getModifiers */.Z.getModifiers(ddb, "race", true, true),
    src_utils/* default.getModifiers */.Z.getModifiers(ddb, "background", true, true),
    src_utils/* default.getModifiers */.Z.getModifiers(ddb, "feat", true, true),
  ].flat();

  // console.warn(modifiers);
  // console.log(ddb.character.options[type]);
  // console.warn("Adding modifiers");
  // console.log(type);
  // if (type === "race") console.log(modifiers);

  if (!modifierItem.definition) modifierItem.definition = {};
  modifierItem.definition.grantedModifiers = modifiers.filter((mod) => {
    if (mod.componentId === ddbItem.definition?.id && mod.componentTypeId === ddbItem.definition?.entityTypeId)
      return true;
    if (choice && ddb.character.options[type]?.length > 0) {
      // if it is a choice option, try and see if the mod matches
      const choiceMatch = ddb.character.options[type].some(
        (option) =>
          // id match
          choice.componentId == option.componentId && // the choice id matches the option componentID
          option.definition.id == mod.componentId && // option id and mod id match
          (choice.componentTypeId == option.componentTypeId || // either the choice componenttype and optiontype match or
            choice.componentTypeId == option.definition.entityTypeId) && // the choice componentID matches the option definition entitytypeid
          option.definition.entityTypeId == mod.componentTypeId && // mod componentId matches option entity type id
          choice.id == mod.componentId // choice id and mod id match
      );
      // console.log(`choiceMatch ${choiceMatch}`);
      if (choiceMatch) return true;
    } else if (choice) {
      // && choice.parentChoiceId
      const choiceIdSplit = choice.choiceId.split("-").pop();
      if (mod.id == choiceIdSplit) return true;
    } else if (mod.componentId === ddbItem.id || mod.componentId === ddbItem.definition?.id) {
      if (type === "class") {
        // logger.log("Class check - feature effect parsing");
        const classFeatureMatch = ddb.character.classes.some((klass) =>
          klass.classFeatures.some(
            (f) => f.definition.entityTypeId == mod.componentTypeId && f.definition.id == ddbItem.id
          )
        );
        if (classFeatureMatch) return true;
      } else if (type === "feat") {
        const featMatch = ddb.character.feats.some(
          (f) => f.definition.entityTypeId == mod.componentTypeId && f.definition.id == ddbItem.id
        );
        if (featMatch) return true;
      } else if (type === "race") {
        const traitMatch = ddb.character.race.racialTraits.some(
          (t) =>
            t.definition.entityTypeId == mod.componentTypeId &&
            t.definition.id == mod.componentId &&
            t.definition.id == ddbItem.definition.id
        );
        if (traitMatch) return true;
      }
    }
    return false;
  });
  // console.warn(modifierItem);
  return modifierItem;
}

function addFeatEffects(ddb, character, ddbItem, item, choice, type) {
  // can we apply any effects to this feature
  const daeInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("dae");
  const AUTO_AC = src_utils/* default.versionCompare */.Z.versionCompare(game.data.system.data.version, "1.4.0") >= 0;
  const compendiumItem = character.flags.ddbimporter.compendium;
  const addCharacterEffects = compendiumItem
    ? game.settings.get("ddb-importer", "munching-policy-add-effects")
    : game.settings.get("ddb-importer", "character-update-policy-add-character-effects");
  const addACEffects = compendiumItem
    ? game.settings.get("ddb-importer", "munching-policy-add-effects")
    : game.settings.get("ddb-importer", "character-update-policy-generate-ac-feature-effects");
  const modifierItem = generateFeatModifiers(ddb, ddbItem, choice, type);
  if (daeInstalled && addCharacterEffects) {
    item = (0,effects_effects/* generateEffects */.K7)(ddb, character, modifierItem, item, compendiumItem, "feat");
    // console.log(item);
  }
  if ((daeInstalled && addACEffects) || AUTO_AC) {
    item = (0,acEffects/* generateBaseACItemEffect */.se)(ddb, character, modifierItem, item, compendiumItem);
    // console.log(item);
  }
  return item;
}

function removeActionFeatures(actions, features) {
  const actionAndFeature = game.settings.get("ddb-importer", "character-update-policy-use-action-and-feature");

  actions = actions.map((action) => {
    const featureMatch = features.find((feature) => feature.name === action.name);
    if (featureMatch &&
      action.effects && action.effects.length === 0 &&
      featureMatch.effects && featureMatch.effects.length > 0
    ) {
      action.effects = featureMatch.effects;
    }
    return action;
  });

  features = features
  .filter((feature) => actionAndFeature || !actions.some((action) => feature.name === action.name))
  .map((feature) => {
    const actionMatch = actionAndFeature && actions.some((action) => feature.name === action.name);
    if (actionMatch) feature.effects = [];
    return feature;
  });

  return [actions, features];
}

function stripHtml(html) {
  let tmp = document.createElement("DIV");
  tmp.innerHTML = html;
  return tmp.textContent || tmp.innerText || "";
}

/**
 * Some features we need to fix up or massage because they are modified
 * in interesting ways
 * @param {*} ddb
 * @param {*} features
 */
function fixFeatures(features) {
  // eslint-disable-next-line complexity
  features.forEach((feature) => {
    switch (feature.name) {
      case "Channel Divinity: Radiance of the Dawn":
        feature.data.damage = {
          parts: [["2d10[radiant] + @classes.cleric.levels", "radiant"]],
          versatile: "",
          value: "",
        };
        break;
      case "Surprise Attack":
        feature.data.damage = { parts: [["2d6", ""]], versatile: "", value: "" };
        feature.data.activation["type"] = "special";
        break;
      case "Eldritch Cannon: Force Ballista":
        feature.data["target"]["value"] = 1;
        feature.data["target"]["type"] = "creature";
        feature.data["range"]["value"] = 120;
        feature.data["range"]["units"] = "ft";
        feature.data.ability = "int";
        feature.data.actionType = "rsak";
        feature.data.chatFlavor = "On hit pushed 5 ft away.";
        feature.data.damage = { parts: [["2d8[force]", "force"]], versatile: "", value: "" };
        break;
      case "Eldritch Cannon: Protector":
        feature.data["target"]["units"] = "any";
        feature.data["target"]["type"] = "ally";
        feature.data["range"]["value"] = 10;
        feature.data.ability = "int";
        feature.data.actionType = "heal";
        feature.data.damage = { parts: [["1d8 + @mod", "temphp"]], versatile: "", value: "" };
        break;
      case "Eldritch Cannon: Flamethrower":
        feature.data.damage = { parts: [["2d8[fire]", "fire"]], versatile: "", value: "" };
        break;
      case "Second Wind":
        feature.data.damage = {
          parts: [["1d10[healing] + @classes.fighter.levels", "healing"]],
          versatile: "",
          value: "",
        };
        feature.data.actionType = "heal";
        feature.data["target"]["type"] = "self";
        feature.data["range"]["type"] = "self";
        break;
      case "Healing Hands": {
        feature.data.damage = {
          parts: [["@details.level[healing]", "healing"]],
          versatile: "",
          value: "",
        };
        feature.data.actionType = "heal";
        feature.data["target"]["type"] = "creature";
        feature.data["range"] = {
          type: "touch",
          value: null,
          long: null,
          units: "touch"
        };
        break;
      }
      case "Stone's Endurance":
      case "Stoneâ€™s Endurance":
        feature.data.damage = { parts: [["1d12 + @mod", ""]], versatile: "", value: "" };
        feature.data.actionType = "other";
        feature.data.ability = "con";
        feature.data["target"]["type"] = "self";
        feature.data["range"]["type"] = "self";
        break;
      case "Fighting Style: Interception":
        feature.data.damage = { parts: [["1d10 + @prof", ""]], versatile: "", value: "" };
        feature.data["target"]["type"] = "self";
        feature.data["range"]["type"] = "self";
        break;
      case "Stunning Strike":
        feature.data.actionType = "save";
        feature.data.save = { ability: "con", dc: null, scaling: "wis" };
        feature.data.target = { value: null, width: null, units: "touch", type: "creature" };
        feature.data.range.units = "ft";
        break;
      case "Divine Intervention":
        feature.data.damage = { parts: [["1d100", ""]], versatile: "", value: "" };
        feature.data.actionType = "other";
        break;
      // add a rage effect
      case "Starry Form: Archer":
        feature.data.actionType = "rsak";
        feature.data["target"]["value"] = 1;
        feature.data["target"]["type"] = "creature";
        feature.data["range"]["units"] = "ft";
        break;
      case "Starry Form: Chalice":
        feature.data.damage.parts[0][1] = "healing";
        feature.data.actionType = "heal";
        feature.data["target"]["value"] = 1;
        feature.data["target"]["type"] = "ally";
        feature.data["range"]["value"] = 30;
        feature.data["range"]["units"] = "ft";
        feature.data.activation.type = "special";
        break;
      case "Starry Form: Dragon":
        break;
      case "Rage": {
        feature.data.target = {
          value: null,
          width: null,
          units: "",
          type: "self",
        };
        feature.data.duration = {
          value: 1,
          units: "minute",
        };
        break;
      }
      case "Sneak Attack": {
        feature.data.damage = { parts: [["(ceil(@classes.rogue.levels /2))d6", ""]], versatile: "", value: "" };
        if (!feature.flags.ddbimporter.action) {
          feature.data.actionType = "other";
        }
        break;
      }
      case "Bardic Inspiration": {
        feature.data.actionType = "util";
        break;
      }
      case "Superiority Dice": {
        // feature parses as all available dice, rather than 1 per use
        feature.data.damage.parts[0][0] = `1d${feature.data.damage.parts[0][0].split("d").pop()}`;
        break;
      }
      case "Deflect Missiles": {
        feature.data.damage = { parts: [["1d10 + @mod + @classes.monk.levels"]], versatile: "", value: "" };
        break;
      }
      case "Polearm Master - Bonus Attack": {
        feature.data.actionType = "mwak";
        feature.data.range = { value: 10, long: null, units: "ft" };
        break;
      }
      case "Healing Light": {
        feature.data.damage = { parts: [["1d6"]], versatile: "", value: "" };
        break;
      }
      case "Arcane Propulsion Armor Gauntlet": {
        feature.data.damage.parts[0][0] += " + @mod";
        break;
      }
      // no default
    }

    const tableDescription = (0,table/* generateTable */.p)(feature.name, feature.data.description.value, true);
    feature.data.description.value = tableDescription;
    feature.data.description.chat = tableDescription;
  });
}

;// CONCATENATED MODULE: ./src/parser/features/actions.js







// get actions from ddb.character.customActions
function getCustomActions(ddb, displayedAsAttack) {
  const customActions = ddb.character.customActions
    .filter((action) => action.displayAsAttack === displayedAsAttack)
    .map((action) => {
      action.dice = {
        diceString: action.diceCount && action.diceType ? `${action.diceCount}d${action.diceType}` : null,
        fixedValue: action.fixedValue,
      };

      const range = {
        aoeType: action.aoeType,
        aoeSize: action.aoeSize,
        range: action.range,
        long: action.longRange,
      };
      action.range = range;

      if (action.statId) action.abilityModifierStatId = action.statId;

      action.activation = {
        activationTime: action.activationTime,
        activationType: action.activationType,
      };

      return action;
    });

  return customActions;
}

function actions_isMartialArtists(classes) {
  return classes.some((cls) => cls.classFeatures.some((feature) => feature.definition.name === "Martial Arts"));
}

function actions_getDamage(action) {
  let damage = {};
  const damageType = action.damageTypeId
    ? dictionary/* default.actions.damageType.find */.Z.actions.damageType.find((type) => type.id === action.damageTypeId).name
    : null;

  // when the action type is not set to melee or ranged we don't apply the mod to damage
  const meleeOrRangedAction = action.attackTypeRange || action.rangeId;
  const modBonus = (action.statId || action.abilityModifierStatId) && !action.isOffhand && meleeOrRangedAction ? " + @mod" : "";
  const fixedBonus = action.dice?.fixedValue ? ` + ${action.dice.fixedValue}` : "";
  const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");

  if (action.dice) {
    if (action.dice.diceString) {
      const damageTag = (globalDamageHints && damageType) ? `[${damageType}]` : "";
      const damageString = src_utils/* default.parseDiceString */.Z.parseDiceString(action.dice.diceString, modBonus + fixedBonus, damageTag).diceString;
      damage = {
        parts: [[damageString, damageType]],
        versatile: "",
      };
    } else if (fixedBonus) {
      damage = {
        parts: [[fixedBonus + modBonus, damageType]],
        versatile: "",
      };
    }
  }

  return damage;
}

/**
 * Some features have actions that use dice and mods that are defined on the character class feature
 * this attempts to parse out the damage dice and any ability modifier.
 * This relies on the parsing of templateStrings for the ability modifier detection.
 * @param {*} ddb
 * @param {*} character
 * @param {*} action
 * @param {*} feat
 */
function getLevelScaleDice(ddb, character, action, feat) {
  let parts = ddb.character.classes
    .filter((cls) => cls.classFeatures.some((feature) =>
      feature.definition.id == action.componentId &&
      feature.definition.entityTypeId == action.componentTypeId &&
      feature.levelScale?.dice?.diceString
    ))
    .map((cls) => {
      const feature = cls.classFeatures.find((feature) =>
        feature.definition.id == action.componentId &&
        feature.definition.entityTypeId == action.componentTypeId
      );
      const parsedString = character.flags.ddbimporter.dndbeyond.templateStrings.find((templateString) =>
        templateString.id == action.id &&
        templateString.entityTypeId == action.entityTypeId
      );
      let part = feature.levelScale.dice.diceString;
      if (parsedString) {
        const modifier = parsedString.definitions.find((definition) => definition.type === "modifier");
        if (modifier) {
          feat.data.ability = modifier.subType;
          part = `${part} + @mod`;
        }
      }
      return [part, ""];
    });

  feat.data.damage = {
    parts: parts,
    versatile: "",
  };

  return feat;
}

function martialArtsDamage(ddb, action) {
  const damageType = dictionary/* default.actions.damageType.find */.Z.actions.damageType.find((type) => type.id === action.damageTypeId).name;
  const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");

  let damageBonus = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "damage", "unarmed-attacks").reduce((prev, cur) => prev + cur.value, 0);
  if (damageBonus === 0) {
    damageBonus = "";
  } else {
    damageBonus = ` + ${damageBonus}`;
  }

  // are we dealing with martial arts?
  if (actions_isMartialArtists(ddb.character.classes)) {
    const die = ddb.character.classes
      .filter((cls) => actions_isMartialArtists([cls]))
      .map((cls) => {
        const feature = cls.classFeatures.find((feature) => feature.definition.name === "Martial Arts");

        if (feature && feature.levelScale && feature.levelScale.dice && feature.levelScale.dice.diceString) {
          if (action.dice?.diceValue > feature.levelScale.dice.diceValue) {
            return action.dice.diceString;
          }
          return feature.levelScale.dice.diceString;
        } else if (action.dice !== null) {
          // On some races bite is considered a martial art, damage
          // is different and on the action itself
          return action.dice.diceString;
        } else {
          return "1";
        }
      });

    const damageTag = (globalDamageHints && damageType) ? `[${damageType}]` : "";
    const damageString = src_utils/* default.parseDiceString */.Z.parseDiceString(die, `${damageBonus} + @mod`, damageTag).diceString;

    // set the weapon damage
    return {
      parts: [[damageString, damageType]],
      versatile: "",
    };
  } else if (action.dice !== null) {
    // The Lizardfolk jaws have a different base damage, its' detailed in
    // dice so lets capture that for actions if it exists
    const damageTag = (globalDamageHints && damageType) ? `[${damageType}]` : "";
    const damageString = src_utils/* default.parseDiceString */.Z.parseDiceString(action.dice.diceString, `${damageBonus} + @mod`, damageTag).diceString;
    return {
      parts: [[damageString, damageType]],
      versatile: "",
    };
  } else {
    // default to basics
    return {
      parts: [[`1${damageBonus} + @mod`, damageType]],
      versatile: "",
    };
  }
}

function getLimitedUse(action, character) {
  if (
    action.limitedUse &&
    (action.limitedUse.maxUses || action.limitedUse.statModifierUsesId || action.limitedUse.useProficiencyBonus)
  ) {
    const resetType = dictionary/* default.resets.find */.Z.resets.find((type) => type.id === action.limitedUse.resetType);
    let maxUses = (action.limitedUse.maxUses && action.limitedUse.maxUses !== -1) ? action.limitedUse.maxUses : 0;

    if (action.limitedUse.statModifierUsesId) {
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find(
        (ability) => ability.id === action.limitedUse.statModifierUsesId
      ).value;

      switch (action.limitedUse.operator) {
        case 2: {
          maxUses *= character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
          break;
        }
        case 1:
        default:
          maxUses += character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
      }
    }

    if (action.limitedUse.useProficiencyBonus) {
      switch (action.limitedUse.proficiencyBonusOperator) {
        case 2: {
          maxUses *= character.data.attributes.prof;
          break;
        }
        case 1:
        default:
          maxUses += character.data.attributes.prof;
      }
    }

    const finalMaxUses = (maxUses) ? parseInt(maxUses) : null;

    return {
      value: (finalMaxUses !== null && finalMaxUses != 0) ? maxUses - action.limitedUse.numberUsed : null,
      max: (finalMaxUses != 0) ? finalMaxUses : null,
      per: resetType ? resetType.value : "",
    };
  } else {
    return {
      value: null,
      max: null,
      per: "",
    };
  }
}

function actions_getDescription(ddb, character, action) {
  const useFull = game.settings.get("ddb-importer", "character-update-policy-use-full-description");
  let snippet = action.snippet ? (0,templateStrings/* default */.Z)(ddb, character, action.snippet, action).text : "";
  const description = action.description ? (0,templateStrings/* default */.Z)(ddb, character, action.description, action).text : "";
  if (stripHtml(description) === snippet) snippet = "";
  const fullDescription = description !== "" ? description + (snippet !== "" ? "<h3>Summary</h3>" + snippet : "") : snippet;
  const value = !useFull && snippet.trim() !== "" ? snippet : fullDescription;
  return {
    value: value,
    chat: snippet,
    unidentified: "",
  };
}

function actions_getActivation(action) {
  if (action.activation) {
    const actionType = dictionary/* default.actions.activationTypes.find */.Z.actions.activationTypes.find((type) => type.id === action.activation.activationType);
    const activation = !actionType
      ? {}
      : {
          type: actionType.value,
          cost: action.activation.activationTime || 1,
          condition: "",
        };
    return activation;
  }
  return {};
}

function getResource(character, action) {
  let consume = {
    "type": "",
    "target": "",
    "amount": null
  };
  Object.keys(character.data.resources).forEach((resource) => {
    const detail = character.data.resources[resource];
    if (action.name === detail.label) {
      consume = {
        type: "attribute",
        target: `resources.${resource}.value`,
        amount: null,
      };
    }
  });
  return consume;
}

function actions_getWeaponType(action) {
  const entry = dictionary/* default.actions.attackTypes.find */.Z.actions.attackTypes.find((type) => type.attackSubtype === action.attackSubtype);
  const range = dictionary/* default.weapon.weaponRange.find */.Z.weapon.weaponRange.find((type) => type.attackType === action.attackTypeRange);
  return entry ? entry.value : range ? `simple${range.value}` : "simpleM";
}

function calculateRange(action, weapon) {
  if (action.range && action.range.aoeType && action.range.aoeSize) {
    weapon.data.range = { value: null, units: "self", long: "" };
    weapon.data.target = {
      value: action.range.aoeSize,
      type: dictionary/* default.actions.aoeType.find */.Z.actions.aoeType.find((type) => type.id === action.range.aoeType)?.value,
      units: "ft",
    };
  } else if (action.range && action.range.range) {
    weapon.data.range = {
      value: action.range.range,
      units: "ft.",
      long: action.range.long || "",
    };
  } else {
    weapon.data.range = { value: 5, units: "ft.", long: "" };
  }
  return weapon;
}

function calculateSaveAttack(action, weapon) {
  weapon.data.actionType = "save";
  weapon.data.damage = actions_getDamage(action);

  const fixedDC = (action.fixedSaveDc) ? action.fixedSaveDc : null;
  const scaling = (fixedDC) ? fixedDC : (action.abilityModifierStatId) ? dictionary/* default.character.abilities.find */.Z.character.abilities.find((stat) => stat.id === action.abilityModifierStatId).value : "spell";

  const saveAbility = (action.saveStatId)
    ? dictionary/* default.character.abilities.find */.Z.character.abilities.find((stat) => stat.id === action.saveStatId).value
    : "";

  weapon.data.save = {
    ability: saveAbility,
    dc: fixedDC,
    scaling: scaling,
  };
  if (action.abilityModifierStatId) {
    weapon.data.ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((stat) => stat.id === action.abilityModifierStatId).value;
  }
  return weapon;
}


function calculateActionAttackAbilities(ddb, character, action, weapon) {
  let defaultAbility;

  if (action.abilityModifierStatId && !([1, 2].includes(action.abilityModifierStatId) && action.isMartialArts)) {
    defaultAbility = dictionary/* default.character.abilities.find */.Z.character.abilities.find(
      (stat) => stat.id === action.abilityModifierStatId
    ).value;
    weapon.data.ability = defaultAbility;
  } else if (action.isMartialArts) {
    weapon.data.ability =
      action.isMartialArts && actions_isMartialArtists(ddb.character.classes)
        ? character.flags.ddbimporter.dndbeyond.effectAbilities.dex.value >= character.flags.ddbimporter.dndbeyond.effectAbilities.str.value
          ? "dex"
          : "str"
        : "str";
  } else {
    weapon.data.ability = "";
  }
  if (action.isMartialArts) {
    weapon.data.damage = martialArtsDamage(ddb, action);
    weapon.data.attackBonus = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "bonus", "unarmed-attacks").reduce((prev, cur) => prev + cur.value, 0);
  } else {
    weapon.data.damage = actions_getDamage(action);
  }
  return weapon;
}

function getAttackType(ddb, character, action, weapon) {
  // lets see if we have a save stat for things like Dragon born Breath Weapon
  if (action.saveStatId) {
    weapon = calculateSaveAttack(action, weapon);
  } else if (action.actionType === 1) {
    weapon.data.actionType = "mwak";
    weapon = calculateActionAttackAbilities(ddb, character, action, weapon);
  } else {
    if (action.rangeId && action.rangeId === 1) {
      weapon.data.actionType = "mwak";
    } else if (action.rangeId && action.rangeId === 2) {
      weapon.data.actionType = "rwak";
    } else {
      weapon.data.actionType = "other";
    }
    weapon = calculateActionAttackAbilities(ddb, character, action, weapon);
  }
  return weapon;
}

function getAttackAction(ddb, character, action) {
  let weapon = {
    name: src_utils/* default.getName */.Z.getName(action, character),
    type: "weapon",
    data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("weapon")),
    flags: {
      ddbimporter: {
        id: action.id,
        entityTypeId: action.entityTypeId,
        action: true,
        componentId: action.componentId,
        componentTypeId: action.componentTypeId,
      },
      infusions: { infused: false },
    },
  };
  if (action.infusionFlags) {
    setProperty(weapon, "flags.infusions", action.infusionFlags);
  }
  src_logger/* default.debug */.Z.debug(`Getting Attack Action ${action.name}`);

  try {
    if (action.isMartialArts) {
      weapon.flags.ddbimporter.dndbeyond = {
        type: "Martial Arts",
      };
    }

    weapon.data.proficient = action.isProficient ? 1 : 0;
    weapon.data.description = actions_getDescription(ddb, character, action);
    weapon.data.equipped = true;
    weapon.data.rarity = "common";
    weapon.data.identified = true;
    weapon.data.activation = actions_getActivation(action);
    weapon = calculateRange(action, weapon);
    weapon = getAttackType(ddb, character, action, weapon);
    weapon.data.weaponType = actions_getWeaponType(action);
    weapon.data.uses = getLimitedUse(action, character);
    weapon.data.consume = getResource(character, action);

    // class action
    const klassAction = src_utils/* default.findComponentByComponentId */.Z.findComponentByComponentId(ddb, action.id);
    if (klassAction) {
      setProperty(weapon.flags, "ddbimporter.dndbeyond.levelScale", klassAction.levelScale);
      setProperty(weapon.flags, "ddbimporter.dndbeyond.levelScales", klassAction.definition?.levelScales);
      setProperty(weapon.flags, "ddbimporter.dndbeyond.limitedUse", klassAction.definition?.limitedUse);
    }

    weapon = addFeatEffects(ddb, character, action, weapon);

    if (weapon.data.uses?.max) {
      weapon.flags.betterRolls5e = {
        "quickCharges": {
          "value": {
            "use": true,
            "resource": true
          },
          "altValue": {
            "use": true,
            "resource": true
          }
        }
      };
    }
  } catch (err) {
    src_logger/* default.warn */.Z.warn(
      `Unable to Import Attack Action: ${action.name}, please log a bug report. Err: ${err.message}`,
      "extension"
    );
  }

  return weapon;
}

/**
 * Everyone has an Unarmed Strike
 * @param {*} ddb
 */
function getUnarmedStrike(ddb, character) {
  const unarmedStrikeMock = {
    limitedUse: null,
    name: "Unarmed Strike",
    description: null,
    snippet:
      "Instead of using a weapon to make a melee weapon attack, you can use an unarmed strike: a punch, kick, head-butt, or similar forceful blow (none of which count as weapons). On a hit, an unarmed strike deals bludgeoning damage equal to 1 + your Strength modifier. You are proficient with your unarmed strikes.",
    abilityModifierStatId: null,
    attackTypeRange: 1,
    actionType: 1,
    attackSubtype: 3,
    dice: null,
    value: 1,
    damageTypeId: 1,
    isMartialArts: true,
    isProficient: true,
    displayAsAttack: true,
    range: {
      range: null,
      longRange: null,
      aoeType: null,
      aoeSize: null,
      hasAoeSpecialDescription: false,
    },
    activation: {
      activationTime: 1,
      activationType: 1,
    },
    id: "unarmedStrike",
  };
  const unarmedStrike = getAttackAction(ddb, character, unarmedStrikeMock);
  return unarmedStrike;
}

/**
 * Try and parse attack actions - this will at the moment only really support basic melee attacks
 * @param {*} ddb
 * @param {*} character
 */
function getAttackActions(ddb, character) {
  return [
    // do class options here have a class id, needed for optional class features
    ddb.character.actions.class.filter((action) => src_utils/* default.findClassByFeatureId */.Z.findClassByFeatureId(ddb, action.componentId)),
    ddb.character.actions.race,
    ddb.character.actions.feat,
    getCustomActions(ddb, true),
    getInfusionActionData(ddb),
  ]
    .flat()
    .filter((action) => action.displayAsAttack)
    .map((action) => {
      return getAttackAction(ddb, character, action);
    });
}

/**
 * Lets Parse remaining actions
 * @param {*} ddb
 * @param {*} items
 */
function getOtherActions(ddb, character, items) {
  const actions = [
    // do class options here have a class id, needed for optional class features
    ddb.character.actions.class.filter((action) => src_utils/* default.findClassByFeatureId */.Z.findClassByFeatureId(ddb, action.componentId)),
    ddb.character.actions.race,
    ddb.character.actions.feat,
    getCustomActions(ddb, false),
    getInfusionActionData(ddb),
  ]
    .flat()
    .filter((action) => action.name && action.name !== "")
    .filter(
      (action) =>
        // lets grab other actions and add, make sure we don't get attack based ones that haven't parsed
        !action.displayAsAttack ||
        (action.displayAsAttack === true && !items.some((attack) => attack.name === action.name))
    )
    .map((action) => {
      src_logger/* default.debug */.Z.debug(`Getting Other Action ${action.name}`);
      let feat = {
        name: src_utils/* default.getName */.Z.getName(action, character),
        type: "feat",
        data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("feat")),
        flags: {
          ddbimporter: {
            id: action.id,
            entityTypeId: action.entityTypeId,
            componentId: action.componentId,
            componentTypeId: action.componentTypeId,
          },
          infusions: { infused: false },
        },
      };
      if (action.infusionFlags) {
        setProperty(feat, "flags.infusions", action.infusionFlags);
      }
      feat.data.activation = actions_getActivation(action);
      feat.data.description = actions_getDescription(ddb, character, action);
      feat.data.uses = getLimitedUse(action, character);
      feat.data.consume = getResource(character, action);

      feat = calculateRange(action, feat);
      feat = getAttackType(ddb, character, action, feat);

      if (feat.data.uses?.max) {
        feat.flags.betterRolls5e = {
          quickCharges: {
            value: {
              use: true,
              resource: true
            },
            altValue: {
              use: true,
              resource: true
            }
          }
        };
      }

      if (!feat.data.damage?.parts) {
        src_logger/* default.debug */.Z.debug("Running level scale parser");
        feat = getLevelScaleDice(ddb, character, action, feat);
      }

      // class action
      const klassAction = src_utils/* default.findComponentByComponentId */.Z.findComponentByComponentId(ddb, action.id);
      if (klassAction) {
        setProperty(feat.flags, "ddbimporter.dndbeyond.levelScale", klassAction.levelScale);
        setProperty(feat.flags, "ddbimporter.dndbeyond.levelScales", klassAction.definition?.levelScales);
        setProperty(feat.flags, "ddbimporter.dndbeyond.limitedUse", klassAction.definition?.limitedUse);
      } else {
        const klassByComponentId = src_utils/* default.findComponentByComponentId */.Z.findComponentByComponentId(ddb, action.componentId);
        if (klassByComponentId) {
          setProperty(feat.flags, "ddbimporter.dndbeyond.levelScale", klassByComponentId.levelScale);
          setProperty(feat.flags, "ddbimporter.dndbeyond.levelScales", klassByComponentId.definition?.levelScales);
          setProperty(feat.flags, "ddbimporter.dndbeyond.limitedUse", klassByComponentId.definition?.limitedUse);
        }
      }

      feat = addFeatEffects(ddb, character, action, feat);

      return feat;
    });

  // FUTURE ENHANCEMENT: We maybe able to look up other entities here to get details for things like Sneak Attack
  return actions;
}

function parseActions(ddb, character) {
  let actions = [
    // Get Attack Actions that we know about, typically natural attacks etc
    ...getAttackActions(ddb, character),
    // Everyone has an Unarmed Strike
    getUnarmedStrike(ddb, character),
  ];
  actions = [
    ...actions,
    // Try and parse other relevant actions
    ...getOtherActions(ddb, character, actions),
  ];

  // sort alphabetically, then by action type
  actions.sort().sort((a, b) => {
    if (!a.data.activation.activationType) {
      return 1;
    } else if (!b.data.activation.activationType) {
      return -1;
    } else {
      const aActionTypeID = dictionary/* default.actions.activationTypes.find */.Z.actions.activationTypes.find(
        (type) => type.value === a.data.activation.activationType
      ).id;
      const bActionTypeID = dictionary/* default.actions.activationTypes.find */.Z.actions.activationTypes.find(
        (type) => type.value === b.data.activation.activationType
      ).id;
      if (aActionTypeID > bActionTypeID) {
        return 1;
      } else if (aActionTypeID < bActionTypeID) {
        return -1;
      } else {
        return 0;
      }
    }
  });

  fixFeatures(actions);
  // console.log("ACTIONS");
  // console.error(JSON.parse(JSON.stringify(actions)));
  return actions;
}

;// CONCATENATED MODULE: ./src/parser/features/features.js






function features_getDescription(ddb, character, feat) {
  // for now none actions probably always want the full text
  // const useFull = game.settings.get("ddb-importer", "character-update-policy-use-full-description");
  const useFull = true;
  let snippet = "";
  let description = "";

  if (feat.definition?.snippet) {
    snippet = (0,templateStrings/* default */.Z)(ddb, character, feat.definition.snippet, feat).text;
  } else if (feat.snippet) {
    snippet = (0,templateStrings/* default */.Z)(ddb, character, feat.snippet, feat).text;
  } else {
    snippet = "";
  }

  if (feat.definition?.description) {
    description = (0,templateStrings/* default */.Z)(ddb, character, feat.definition.description, feat).text;
  } else if (feat.description) {
    description = (0,templateStrings/* default */.Z)(ddb, character, feat.description, feat).text;
  } else {
    description = "";
  }

  if (stripHtml(description) === snippet) snippet = "";

  const fullDescription = description !== "" ? description + (snippet !== "" ? "<h3>Summary</h3>" + snippet : "") : snippet;
  const value = !useFull && snippet.trim() !== "" ? snippet : fullDescription;

  return {
    value: value,
    chat: snippet,
    unidentified: "",
  };
}

function parseFeature(feat, ddb, character, source, type) {
  let features = [];
  // filter proficiencies and Ability Score Improvement
  const name = feat.definition ? feat.definition.name : feat.name;
  let item = {
    name: name,
    type: "feat",
    data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate("feat")),
    flags: {
      ddbimporter: {
        id: feat.id,
        entityTypeId: feat.entityTypeId,
        dndbeyond: {
          requiredLevel: feat.requiredLevel,
          displayOrder:
            feat.definition && feat.definition.displayOrder ? feat.definition.displayOrder : feat.displayOrder,
        },
      },
    },
  };

  src_logger/* default.debug */.Z.debug(`Getting Feature ${item.name}`);

  const klassAction = src_utils/* default.findComponentByComponentId */.Z.findComponentByComponentId(ddb, feat.id);
  if (klassAction) {
    setProperty(item.flags, "ddbimporter.dndbeyond.levelScale", klassAction.levelScale);
    setProperty(item.flags, "ddbimporter.dndbeyond.levelScales", klassAction.definition?.levelScales);
    setProperty(item.flags, "ddbimporter.dndbeyond.limitedUse", klassAction.definition?.limitedUse);
  }

  if (feat?.requiredLevel) {
    const klass = ddb.character.classes.find((klass) => klass.definition.id === feat.classId);
    if (klass && feat.requiredLevel > klass.level) return [];
  }

  src_logger/* default.debug */.Z.debug(`Searching for ${name} choices`);

  // Add choices to the textual description of that feat
  let choices = src_utils/* default.getChoices */.Z.getChoices(ddb, type, feat);

  if (choices.length > 0) {
    src_logger/* default.debug */.Z.debug(`Found ${choices.map((c) => c.label).join(",")}`);
    choices.forEach((choice) => {
      src_logger/* default.debug */.Z.debug(`Adding choice ${choice.label}`);
      let choiceItem = JSON.parse(JSON.stringify(item));
      let choiceFeat = feat.definition ? JSON.parse(JSON.stringify(feat.definition)) : JSON.parse(JSON.stringify(feat));

      if (item.name === choice.label) return;

      choiceItem.name = choice.label ? `${choiceItem.name}: ${choice.label}` : choiceItem.name;
      if (choiceFeat.description) {
        choiceFeat.description = choice.description
          ? choiceFeat.description + "<h3>" + choice.label + "</h3>" + choice.description
          : choiceFeat.description;
      }
      if (choiceFeat.snippet) {
        choiceFeat.snippet = choice.description
          ? choiceFeat.snippet + "<h3>" + choice.label + "</h3>" + choice.description
          : choiceFeat.snippet;
      }
      choiceItem.data.description = features_getDescription(ddb, character, choiceFeat);
      choiceItem.data.source = source;

      choiceItem = addFeatEffects(ddb, character, feat, choiceItem, choice, type);
      features.push(choiceItem);
    });
  } else {
    item.data.description = features_getDescription(ddb, character, feat);
    item.data.source = source;
    item = addFeatEffects(ddb, character, feat, item, undefined, type);

    features.push(item);
  }

  return features;
}

function isDuplicateFeature(items, item) {
  return items.some((dup) => dup.name === item.name && dup.data.description.value === item.data.description.value);
}

function getNameMatchedFeature(items, item) {
  return items.find((dup) => dup.name === item.name);
}

function includedFeatureNameCheck(featName, addEffects) {
  // we add all features when parsing active effects
  if (addEffects) {
    const nameAllowed = !featName.startsWith("Ability Score");
    return nameAllowed;
  }

  const nameAllowed = !featName.startsWith("Proficiencies") &&
    !featName.startsWith("Ability Score") &&
    featName !== "Bonus Proficiency";

  return nameAllowed;
}


function parseClassFeatures(ddb, character, addEffects, actionAndFeature) {
  // class and subclass traits
  let classItems = [];
  let classesFeatureList = [];
  let subClassesFeatureList = [];
  let processedClassesFeatureList = [];
  const excludedFeatures = ddb.character.optionalClassFeatures
    .filter((f) => f.affectedClassFeatureId)
    .map((f) => f.affectedClassFeatureId);

  // subclass features can often be duplicates of class features.
  ddb.character.classes.forEach((klass) => {
    const classFeatures = klass.definition.classFeatures.filter(
      (feat) =>
        includedFeatureNameCheck(feat.name, addEffects) &&
        feat.requiredLevel <= klass.level
    );
    const klassName = klass.definition.name;
    const klassFeatureList = classFeatures
      .filter((feat) => !excludedFeatures.includes(feat.id))
      .map((feat) => {
        let items = parseFeature(feat, ddb, character, klassName, "class");
        return items.map((item) => {
          item.flags.ddbimporter.dndbeyond.class = klassName;
          // add feature to all features list
          classesFeatureList.push(JSON.parse(JSON.stringify(item)));
          return item;
        });
      })
      .flat()
      .sort((a, b) => {
        return a.flags.ddbimporter.dndbeyond.displayOrder - b.flags.ddbimporter.dndbeyond.displayOrder;
      });

    klassFeatureList.forEach((item) => {
      // have we already processed an identical item?
      if (!isDuplicateFeature(processedClassesFeatureList, item)) {
        const existingFeature = getNameMatchedFeature(classItems, item);
        const duplicateFeature = isDuplicateFeature(classItems, item);
        if (existingFeature && !duplicateFeature) {
          const levelAdjustment = `<h3>${klassName}: Level ${item.flags.ddbimporter.dndbeyond.requiredLevel}</h3>${item.data.description.value}`;
          existingFeature.data.description.value += levelAdjustment;
        } else if (!existingFeature) {
          classItems.push(item);
        }
      }
    });
    processedClassesFeatureList = processedClassesFeatureList.concat(classesFeatureList, klassFeatureList);

    // subclasses
    if (klass.subclassDefinition && klass.subclassDefinition.classFeatures) {
      let subClassItems = [];
      const subFeatures = klass.subclassDefinition.classFeatures.filter(
        (feat) =>
          includedFeatureNameCheck(feat.name, addEffects) &&
          feat.requiredLevel <= klass.level &&
          (actionAndFeature || !ddb.character.actions.class.some((action) => action.name === feat.name)) &&
          !excludedFeatures.includes(feat.id)
      );
      const subKlassName = `${klassName} : ${klass.subclassDefinition.name}`;
      const subKlassFeatureList = subFeatures
        .map((feat) => {
          let subClassItems = parseFeature(feat, ddb, character, subKlassName, "class");
          return subClassItems.map((item) => {
            item.flags.ddbimporter.dndbeyond.class = subKlassName;
            // add feature to all features list
            subClassesFeatureList.push(JSON.parse(JSON.stringify(item)));
            return item;
          });
        })
        .flat()
        .sort((a, b) => {
          return a.flags.ddbimporter.dndbeyond.displayOrder - b.flags.ddbimporter.dndbeyond.displayOrder;
        });

      // parse out duplicate features from class features
      subKlassFeatureList.forEach((item) => {
        if (!isDuplicateFeature(classesFeatureList, item)) {
          const existingFeature = getNameMatchedFeature(subClassItems, item);
          const duplicateFeature = isDuplicateFeature(subClassItems, item);
          if (existingFeature && !duplicateFeature) {
            const levelAdjustment = `<h3>${subKlassName}: At Level ${item.flags.ddbimporter.dndbeyond.requiredLevel}</h3>${item.data.description.value}`;
            existingFeature.data.description.value += levelAdjustment;
          } else if (!existingFeature) {
            subClassItems.push(item);
          }
        }
      });
      // add features to list to indicate processed
      processedClassesFeatureList = processedClassesFeatureList.concat(subClassesFeatureList, subKlassFeatureList);

      // now we take the unique subclass features and add to class
      subClassItems.forEach((item) => {
        const existingFeature = getNameMatchedFeature(classItems, item);
        const duplicateFeature = isDuplicateFeature(classItems, item);
        if (existingFeature && !duplicateFeature) {
          const levelAdjustment = `<h3>${subKlassName}: At Level ${item.flags.ddbimporter.dndbeyond.requiredLevel}</h3>${item.data.description.value}`;
          existingFeature.data.description.value += levelAdjustment;
        } else if (!existingFeature) {
          classItems.push(item);
        }
      });
    }
  });
  return classItems;
}

function parseFeatures(ddb, character) {
  const daeInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("dae");
  const compendiumItem = character.flags.ddbimporter.compendium;
  const addEffects = (daeInstalled && compendiumItem)
    ? game.settings.get("ddb-importer", "munching-policy-add-effects")
    : game.settings.get("ddb-importer", "character-update-policy-add-character-effects");

  let items = [];

  const excludedOriginFeatures = ddb.character.optionalOrigins
    .filter((f) => f.affectedRacialTraitId)
    .map((f) => f.affectedRacialTraitId);

  // racial traits
  ddb.character.race.racialTraits
    .filter(
      (trait) => !trait.definition.hideInSheet && !excludedOriginFeatures.includes(trait.definition.id))
    .forEach((feat) => {
      const source = src_utils/* default.parseSource */.Z.parseSource(feat.definition);
      const features = parseFeature(feat, ddb, character, source, "race");
      features.forEach((item) => {
        const existingFeature = getNameMatchedFeature(items, item);
        const duplicateFeature = isDuplicateFeature(items, item);
        if (existingFeature && !duplicateFeature) {
          existingFeature.data.description.value += `<h3>Racial Trait Addition</h3>${item.data.description.value}`;
        } else if (!existingFeature) {
          items.push(item);
        }
      });
    });

  // class and subclass traits
  let classItems = parseClassFeatures(ddb, character, addEffects);

  // optional class features
  if (ddb.classOptions) {
    ddb.classOptions
    .forEach((feat) => {
      src_logger/* default.debug */.Z.debug(`Parsing Optional Feature ${feat.name}`);
      const source = src_utils/* default.parseSource */.Z.parseSource(feat);
      const feats = parseFeature(feat, ddb, character, source, "feat");
      feats.forEach((item) => {
        items.push(item);
      });
    });
  }

  // now we loop over class features and add to list, removing any that match racial traits, e.g. Darkvision
  classItems
    .forEach((item) => {
      const existingFeature = getNameMatchedFeature(items, item);
      const duplicateFeature = isDuplicateFeature(items, item);
      if (existingFeature && !duplicateFeature) {
        const klassAdjustment = `<h3>${item.flags.ddbimporter.dndbeyond.class}</h3>${item.data.description.value}`;
        existingFeature.data.description.value += klassAdjustment;
      } else if (!existingFeature) {
        items.push(item);
      }
    });

  // add feats
  ddb.character.feats
    .forEach((feat) => {
      const source = src_utils/* default.parseSource */.Z.parseSource(feat.definition);
      const feats = parseFeature(feat, ddb, character, source, "feat");
      feats.forEach((item) => {
        items.push(item);
      });
    });

  const backgroundFeature = getBackgroundData(ddb);
  const backgroundSource = src_utils/* default.parseSource */.Z.parseSource(backgroundFeature.definition);
  const backgroundFeat = parseFeature(backgroundFeature, ddb, character, backgroundSource, "background");
  backgroundFeat.forEach((item) => {
    items.push(item);
  });

  fixFeatures(items);
  // console.log("FEATURES");
  // console.error(JSON.parse(JSON.stringify(items)));
  return items;
}

;// CONCATENATED MODULE: ./src/parser/spells/ability.js


// is there a spell casting ability?
function ability_hasSpellCastingAbility(spellCastingAbilityId) {
  return dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === spellCastingAbilityId) !== undefined;
}

// convert spellcasting ability id to string used by foundry
function ability_convertSpellCastingAbilityId(spellCastingAbilityId) {
  return dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === spellCastingAbilityId).value;
}

// search through classinfo and determine spellcasting ability
function getSpellCastingAbility(classInfo) {
  let spellCastingAbility = undefined;
  if (ability_hasSpellCastingAbility(classInfo.definition.spellCastingAbilityId)) {
    spellCastingAbility = ability_convertSpellCastingAbilityId(classInfo.definition.spellCastingAbilityId);
  } else if (
    classInfo.subclassDefinition &&
    ability_hasSpellCastingAbility(classInfo.subclassDefinition.spellCastingAbilityId)
  ) {
    // Arcane Trickster has spellcasting ID granted here
    spellCastingAbility = ability_convertSpellCastingAbilityId(classInfo.subclassDefinition.spellCastingAbilityId);
  } else {
    // special cases: No spellcaster, but can cast spells like totem barbarian, default to wis
    spellCastingAbility = "wis";
  }
  return spellCastingAbility;
}

;// CONCATENATED MODULE: ./src/parser/classes/index.js




/**
 * Fetches the sources and pages for class and subclass
 * @param {obj} data item
 */
let getSources = (data) => {
  const classSource = src_utils/* default.getSourceData */.Z.getSourceData(data.definition);

  let sources = classSource.name;
  if (classSource.page) sources += ` (pg. ${classSource.page})`;

  if (data.subclassDefinition) {
    const subclassSource = src_utils/* default.getSourceData */.Z.getSourceData(data.subclassDefinition);
    if (subclassSource.name && classSource.name !== subclassSource.name) {
      sources += `, ${subclassSource.name}`;
    }
    if (subclassSource.page && classSource.page !== subclassSource.page) {
      sources += ` (pg. ${subclassSource.page})`;
    }
  }

  return sources;
};

function classes_parseClasses(ddb) {
  let items = [];

  ddb.character.classes.forEach((characterClass) => {
    let item = {
      name: characterClass.definition.name,
      type: 'class',
      data: JSON.parse(src_utils/* default.getTemplate */.Z.getTemplate('class')),
      flags: {
        ddbimporter: {
          id: characterClass.id,
          definitionId: characterClass.definition.id,
          entityTypeId: characterClass.entityTypeId,
        },
      },
    };

    item.data.description = {
      value: characterClass.definition.description,
      chat: characterClass.definition.description,
      unidentified: false,
    };
    item.data.levels = characterClass.level;
    item.data.source = getSources(characterClass);

    if (
      characterClass.subclassDefinition &&
      characterClass.subclassDefinition.name
    ) {
      item.data.subclass = characterClass.subclassDefinition.name;

      // update the description
      item.data.description.value +=
        '<p><strong>' + item.data.subclass + '</strong></p>';
      item.data.description.value +=
        characterClass.subclassDefinition.description;
    }

    item.data.hitDice = `d${characterClass.definition.hitDice}`;
    item.data.hitDiceUsed = characterClass.hitDiceUsed;

    // There class object supports skills granted by the class.
    // Lets find and add them for future compatibility.
    // const classFeatureIds = characterClass.definition.classFeatures
    //   .map((feature) => feature.id)
    //   .concat((characterClass.subclassDefinition)
    //     ? characterClass.subclassDefinition.classFeatures.map((feature) => feature.id)
    //     : []);

    const classProficiencyFeatureIds = characterClass.definition.classFeatures
    .filter((feature) => feature.name === "Proficiencies")
    .map((feature) => feature.id)
    .concat((characterClass.subclassDefinition)
      ? characterClass.subclassDefinition.classFeatures
        .filter((feature) => feature.name === "Proficiencies")
        .map((feature) => feature.id)
      : []);

    // const classSkillSubType = `choose-a-${characterClass.definition.name.toLowerCase()}-skill`;
    // const skillIds = utils.getChosenClassModifiers(ddb)
    //   .filter((mod) => mod.subType === classSkillSubType && mod.type === "proficiency")
    //   .map((mod) => mod.componentId);

    // "subType": 1,
    // "type": 2,

    let skillsChosen = [];
    let skillChoices = [];
    const choiceDefinitions = ddb.character.choices.choiceDefinitions;
    ddb.character.choices.class.filter((choice) =>
      classProficiencyFeatureIds.includes(choice.componentId) &&
      choice.subType === 1 &&
      choice.type === 2
    ).forEach((choice) => {
      const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);
      if (!optionChoice) return;
      const option = optionChoice.options.find((option) => option.id === choice.optionValue);
      if (!option) return;
      const smallChosen = dictionary/* default.character.skills.find */.Z.character.skills.find((skill) => skill.label === option.label);
      if (smallChosen && !skillsChosen.includes(smallChosen.name)) {
        skillsChosen.push(smallChosen.name);
      }
      const optionNames = optionChoice.options.filter((option) =>
        dictionary/* default.character.skills.some */.Z.character.skills.some((skill) => skill.label === option.label) &&
        choice.optionIds.includes(option.id)
      ).map((option) =>
        dictionary/* default.character.skills.find */.Z.character.skills.find((skill) => skill.label === option.label).name
      );
      optionNames.forEach((skill) => {
        if (!skillChoices.includes(skill)) {
          skillChoices.push(skill);
        }
      });
    });

    item.data.skills = {
      value: skillsChosen,
      number: skillsChosen.length,
      choices: skillChoices,
    };

    item.data.saves = [];
    dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
      const mods = src_utils/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(ddb, true);
      const save = src_utils/* default.filterModifiers */.Z.filterModifiers(mods, "proficiency", `${ability.long}-saving-throws`, [null, ""], true).length > 0;
      if (save) item.data.saves.push(ability.value);
    });

    const castSpells = (characterClass.definition.canCastSpells ||
      (characterClass.subclassDefinition && characterClass.subclassDefinition.canCastSpells));

    if (castSpells) {
      const spellProgression = dictionary/* default.spell.progression.find */.Z.spell.progression.find((cls) => cls.name === characterClass.definition.name);
      const spellCastingAbility = getSpellCastingAbility(characterClass);
      if (spellProgression) {
        item.data.spellcasting = {
          progression: spellProgression.value,
          ability: spellCastingAbility,
        };
      }
    }

    items.push(item);
  });

  return items;
}

;// CONCATENATED MODULE: ./src/parser/spells/metadata.js
/**
 * Generates some meta data for a character to use to determine what to do
 * with a spell.
 * We use this like a quick lookup table
 * @param {*} character
 */
function getLookups(character) {
  // racialTraits
  let lookups = {
    race: [],
    feat: [],
    class: [],
    classFeature: [],
    item: [],
  };
  character.race.racialTraits.forEach((trait) => {
    lookups.race.push({
      id: trait.definition.id,
      name: trait.definition.name,
    });
  });

  character.classes.forEach((playerClass) => {
    lookups.class.push({
      id: playerClass.definition.id,
      name: playerClass.definition.name,
    });

    if (playerClass.subclassDefinition) {
      lookups.class.push({
        id: playerClass.subclassDefinition.id,
        name: playerClass.subclassDefinition.name,
      });
    }

    if (playerClass.classFeatures) {
      playerClass.classFeatures.forEach((trait) => {
        lookups.classFeature.push({
          id: trait.definition.id,
          name: trait.definition.name,
          classId: trait.definition.classId,
          componentId: trait.definition.componentId,
        });
      });
    }
  });

  character.options.class.forEach((trait) => {
    lookups.classFeature.push({
      id: trait.definition.id,
      name: trait.definition.name,
      componentId: trait.componentId,
    });
  });

  character.feats.forEach((trait) => {
    lookups.feat.push({
      id: trait.definition.id,
      name: trait.definition.name,
      componentId: trait.componentId,
    });
  });

  character.inventory.forEach((trait) => {
    lookups.item.push({
      id: trait.definition.id,
      name: trait.definition.name,
      limitedUse: trait.limitedUse,
      equipped: trait.equipped,
      isAttuned: trait.isAttuned,
      canAttune: trait.definition.canAttune,
      canEquip: trait.definition.canEquip,
    });
  });

  return lookups;
}

;// CONCATENATED MODULE: ./src/parser/spells/name.js
function getCustomName(data, character) {
  const characterValues = character.flags.ddbimporter.dndbeyond.characterValues;
  const customValue = characterValues.filter((value) => value.valueId == data.id && value.valueTypeId == data.entityTypeId);

  if (customValue) {
    const customName = customValue.find((value) => value.typeId == 8);

    if (customName) {
      data.name = customName.vale;
      return customName.value;
    }
    if (customName) return customName.value;
  }
  return null;
}


function getName(data, character) {
  // spell name
  const customName = getCustomName(data, character);
  if (customName) {
    return customName;
  } else if (data.flags.ddbimporter.dndbeyond.nameOverride !== undefined) {
    return data.flags.ddbimporter.dndbeyond.nameOverride;
  } else {
    return data.definition.name;
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/getCharacterSpells.js


// Import parsing functions







function getCharacterSpells(ddb, character) {
  let items = [];
  const proficiencyModifier = character.data.attributes.prof;
  const lookups = getLookups(ddb.character);

  src_logger/* default.debug */.Z.debug("Character spell lookups", lookups);
  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;

  const healingBoost = src_utils/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "bonus", "spell-group-healing").reduce((a, b) => a + b.value, 0);

  // each class has an entry here, each entry has spells
  // we loop through each class and process
  ddb.character.classSpells.forEach((playerClass) => {
    const classInfo = ddb.character.classes.find((cls) => cls.id === playerClass.characterClassId);
    const spellCastingAbility = getSpellCastingAbility(classInfo);
    const abilityModifier = src_utils/* default.calculateModifier */.Z.calculateModifier(characterAbilities[spellCastingAbility].value);

    src_logger/* default.debug */.Z.debug("Spell parsing, class info", classInfo);

    const cantripBoost =
      src_utils/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(ddb).filter(
        (mod) =>
          mod.type === "bonus" &&
          mod.subType === `${classInfo.definition.name.toLowerCase()}-cantrip-damage` &&
          (mod.restriction === null || mod.restriction === "")
      ).length > 0;

    // parse spells chosen as spellcasting (playerClass.spells)
    playerClass.spells.forEach((spell) => {
      if (!spell.definition) return;
      // add some data for the parsing of the spells into the data structure
      spell.flags = {
        ddbimporter: {
          dndbeyond: {
            lookup: "classSpell",
            class: classInfo.definition.name,
            level: classInfo.level,
            characterClassId: playerClass.characterClassId,
            spellLevel: spell.definition.level,
            // spellSlots: character.data.spells,
            ability: spellCastingAbility,
            mod: abilityModifier,
            dc: 8 + proficiencyModifier + abilityModifier,
            cantripBoost: cantripBoost,
            overrideDC: false,
            id: spell.id,
            entityTypeId: spell.entityTypeId,
            healingBoost: healingBoost,
            usesSpellSlot: spell.usesSpellSlot,
          },
        }
      };

      spell.definition.name = getName(spell, character);

      // Check for duplicate spells, normally domain ones
      // We will import spells from a different class that are the same though
      // as they may come from with different spell casting mods
      const duplicateSpell = items.findIndex(
        (existingSpell) =>
          existingSpell.name === spell.definition.name &&
          classInfo.definition.name === existingSpell.flags.ddbimporter.dndbeyond.class
      );
      if (!items[duplicateSpell]) {
        items.push(parseSpell(spell, character));
      } else if (spell.alwaysPrepared) {
        // if our new spell is always known we overwrite!
        // it's probably domain
        items[duplicateSpell] = parseSpell(spell, character);
      } else {
        // we'll emit a console message if it doesn't match this case for future debugging
        src_logger/* default.info */.Z.info(`Duplicate Spell ${spell.definition.name} detected in class ${classInfo.definition.name}.`);
      }
    });
  });

  // Parse any spells granted by class features, such as Barbarian Totem
  ddb.character.spells.class.forEach((spell) => {
    if (!spell.definition) return;
    // If the spell has an ability attached, use that
    let spellCastingAbility = undefined;
    const featureId = src_utils/* default.determineActualFeatureId */.Z.determineActualFeatureId(ddb, spell.componentId);
    const classInfo = lookups.classFeature.find((clsFeature) => clsFeature.id == featureId);

    src_logger/* default.debug */.Z.debug("Class spell parsing, class info", classInfo);
    // Sometimes there are spells here which don't have an class Info
    // this seems to be part of the optional tasha's rules, lets not parse for now
    // as ddb implementation is not yet finished
    // / options.class.[].definition.id
    if (!classInfo) {
      src_logger/* default.warn */.Z.warn(`Unable to add ${spell.definition.name}`);
    }
    if (!classInfo) return;
    let klass = src_utils/* default.getClassFromOptionID */.Z.getClassFromOptionID(ddb, spell.componentId);

    if (!klass) klass = src_utils/* default.findClassByFeatureId */.Z.findClassByFeatureId(ddb, spell.componentId);

    src_logger/* default.debug */.Z.debug("Class spell, class found?", klass);

    if (ability_hasSpellCastingAbility(spell.spellCastingAbilityId)) {
      spellCastingAbility = ability_convertSpellCastingAbilityId(spell.spellCastingAbilityId);
    } else if (klass) {
      spellCastingAbility = getSpellCastingAbility(klass);
      // force these spells to always be prepared
      spell.alwaysPrepared = true;
    } else {
      // if there is no ability on spell, we default to wis
      spellCastingAbility = "wis";
    }

    const abilityModifier = src_utils/* default.calculateModifier */.Z.calculateModifier(characterAbilities[spellCastingAbility].value);

    // add some data for the parsing of the spells into the data structure
    spell.flags = {
      ddbimporter: {
        dndbeyond: {
          class: (klass) ? klass.definition.name : undefined,
          lookup: "classFeature",
          lookupName: classInfo.name,
          lookupId: classInfo.id,
          level: character.flags.ddbimporter.dndbeyond.totalLevels,
          ability: spellCastingAbility,
          mod: abilityModifier,
          dc: 8 + proficiencyModifier + abilityModifier,
          overrideDC: false,
          id: spell.id,
          entityTypeId: spell.entityTypeId,
          healingBoost: healingBoost,
          usesSpellSlot: spell.usesSpellSlot,
        },
      },
    };

    spell.definition.name = getName(spell, character);

    // Check for duplicate spells, normally domain ones
    // We will import spells from a different class that are the same though
    // as they may come from with different spell casting mods
    const duplicateSpell = items.findIndex(
      (existingSpell) =>
        existingSpell.name === spell.definition.name &&
        klass &&
        klass.definition.name === existingSpell.flags.ddbimporter.dndbeyond.class &&
        spell.usesSpellSlot && existingSpell.flags.ddbimporter.dndbeyond.usesSpellSlot
    );
    if (!items[duplicateSpell]) {
      items.push(parseSpell(spell, character));
    } else if (spell.alwaysPrepared) {
      // if our new spell is always known we overwrite!
      // it's probably domain
      items[duplicateSpell] = parseSpell(spell, character);
    } else {
      // we'll emit a console message if it doesn't match this case for future debugging
      src_logger/* default.info */.Z.info(`Duplicate Spell ${spell.definition.name} detected in class ${classInfo.name}.`);
    }
  });

  // Race spells are handled slightly differently
  ddb.character.spells.race.forEach((spell) => {
    if (!spell.definition) return;
    // for race spells the spell spellCastingAbilityId is on the spell
    // if there is no ability on spell, we default to wis
    let spellCastingAbility = "wis";
    if (ability_hasSpellCastingAbility(spell.spellCastingAbilityId)) {
      spellCastingAbility = ability_convertSpellCastingAbilityId(spell.spellCastingAbilityId);
    }

    const abilityModifier = src_utils/* default.calculateModifier */.Z.calculateModifier(characterAbilities[spellCastingAbility].value);

    let raceInfo = lookups.race.find((rc) => rc.id === spell.componentId);

    if (!raceInfo) {
      // for some reason we haven't matched the race option id with the spell
      // this happens with at least the SCAG optional spells casting half elf
      raceInfo = {
        name: "Racial spell",
        id: spell.componentId,
      };
    }

    // add some data for the parsing of the spells into the data structure
    spell.flags = {
      ddbimporter: {
        dndbeyond: {
          lookup: "race",
          lookupName: raceInfo.name,
          lookupId: raceInfo.id,
          race: ddb.character.race.fullName,
          level: spell.castAtLevel,
          ability: spellCastingAbility,
          mod: abilityModifier,
          dc: 8 + proficiencyModifier + abilityModifier,
          overrideDC: false,
          id: spell.id,
          entityTypeId: spell.entityTypeId,
          healingBoost: healingBoost,
          usesSpellSlot: spell.usesSpellSlot,
        },
      },
    };

    spell.definition.name = getName(spell, character);

    items.push(parseSpell(spell, character));
  });

  // feat spells are handled slightly differently
  ddb.character.spells.feat.forEach((spell) => {
    if (!spell.definition) return;
    // If the spell has an ability attached, use that
    // if there is no ability on spell, we default to wis
    let spellCastingAbility = "wis";
    if (ability_hasSpellCastingAbility(spell.spellCastingAbilityId)) {
      spellCastingAbility = ability_convertSpellCastingAbilityId(spell.spellCastingAbilityId);
    }

    const abilityModifier = src_utils/* default.calculateModifier */.Z.calculateModifier(characterAbilities[spellCastingAbility].value);

    let featInfo = lookups.feat.find((ft) => ft.id === spell.componentId);

    if (!featInfo) {
      // for some reason we haven't matched the feat option id with the spell
      // we fiddle the result
      featInfo = {
        name: "Feat option spell",
        id: spell.componentId,
      };
    }

    // add some data for the parsing of the spells into the data structure
    spell.flags = {
      ddbimporter: {
        dndbeyond: {
          lookup: "feat",
          lookupName: featInfo.name,
          lookupId: featInfo.id,
          level: spell.castAtLevel,
          ability: spellCastingAbility,
          mod: abilityModifier,
          dc: 8 + proficiencyModifier + abilityModifier,
          overrideDC: false,
          id: spell.id,
          entityTypeId: spell.entityTypeId,
          healingBoost: healingBoost,
          usesSpellSlot: spell.usesSpellSlot,
        },
      },
    };

    spell.definition.name = getName(spell, character);

    items.push(parseSpell(spell, character));
  });

  if (items) fixSpells(ddb, items);

  return items;
}


;// CONCATENATED MODULE: ./src/parser/spells/getItemSpells.js


// Import parsing functions






function getItemSpells_getItemSpells(ddb, character) {
  let items = [];
  const proficiencyModifier = character.data.attributes.prof;
  const lookups = getLookups(ddb.character);

  // feat spells are handled slightly differently
  ddb.character.spells.item.forEach((spell) => {
    if (!spell.definition) return;

    const itemInfo = lookups.item.find((it) => it.id === spell.componentId);
    if (!itemInfo) return;

    const active =
      (!itemInfo.canEquip && !itemInfo.canAttune) || // if item just gives a thing
      itemInfo.isAttuned || // if it is attuned (assume equipped)
      (!itemInfo.canAttune && itemInfo.equipped); // can't attune but is equipped
    // for item spells the spell dc is often on the item spell
    let spellDC = 8;
    if (spell.overrideSaveDc) {
      spellDC = spell.overrideSaveDc;
    } else if (spell.spellCastingAbilityId) {
      // If the spell has an ability attached, use that
      // if there is no ability on spell, we default to wis
      let spellCastingAbility = "wis";
      if (ability_hasSpellCastingAbility(spell.spellCastingAbilityId)) {
        spellCastingAbility = ability_convertSpellCastingAbilityId(spell.spellCastingAbilityId);
      }

      const abilityModifier = src_utils/* default.calculateModifier */.Z.calculateModifier(character.flags.ddbimporter.dndbeyond.effectAbilities[spellCastingAbility].value);
      spellDC = 8 + proficiencyModifier + abilityModifier;
    } else {
      spellDC = null;
    }

    // add some data for the parsing of the spells into the data structure
    spell.flags = {
      ddbimporter: {
        dndbeyond: {
          lookup: "item",
          lookupName: itemInfo.name,
          lookupId: itemInfo.id,
          level: spell.castAtLevel,
          dc: spellDC,
          limitedUse: itemInfo.limitedUse,
          nameOverride: `${spell.definition.name} (${itemInfo.name})`,
          overrideDC: !!spell.overrideSaveDc,
          spellLimitedUse: spell.limitedUse,
          castAtLevel: spell.castAtLevel,
          active: active,
        },
      },
    };

    items.push(parseSpell(spell, character));
  });

  if (items) fixSpells(ddb, items);

  return items;
}

;// CONCATENATED MODULE: ./src/parser/special/index.js
// import DICTIONARY from '../dictionary.js';
// import utils from '../../utils.js';


function getDivineSmite() {
    return {
        "flags": {
            "betterRolls5e": {
                "quickDamage": {
                    "context": {
                        "0": "",
                        "1": "Undead or Fiend"
                    },
                    "value": {
                        "0": true,
                        "1": true
                    },
                    "altValue": {
                        "0": true,
                        "1": true
                    }
                }
            }
        },
        "name": "Divine Smite",
        "type": "spell",
        "img": "systems/dnd5e/icons/skills/light_05.jpg",
        "data": {
            "description": {
                "value": "<p>Starting at 2nd level, when you hit a creature with a melee weapon attack, you can expend one spell slot to deal radiant damage to the target, in addition to the weapon&rsquo;s damage.</p>\n<p>The extra damage is 2d8 for a 1st-level spell slot, plus 1d8 for each spell level higher than 1st, to a maximum of 5d8. The damage increases by 1d8 if the target is an undead or a fiend.</p>",
                "chat": "",
                "unidentified": ""
            },
            "source": "PHB PG. 85",
            "activation": {
                "type": "special",
                "cost": null,
                "condition": ""
            },
            "duration": {
                "value": null,
                "units": ""
            },
            "target": {
                "value": 1,
                "units": "",
                "type": "enemy"
            },
            "range": {
                "value": null,
                "long": null,
                "units": ""
            },
            "uses": {
                "value": 0,
                "max": 0,
                "per": ""
            },
            "consume": {
                "type": "",
                "target": "",
                "amount": null
            },
            "ability": "",
            "actionType": "other",
            "attackBonus": 0,
            "chatFlavor": "Smote.",
            "critical": null,
            "damage": {
                "parts": [
                    ["2d8", "radiant"],
                    ["1d8", "radiant"]
                ],
                "versatile": ""
            },
            "formula": "",
            "save": {
                "ability": "",
                "dc": null,
                "scaling": "spell"
            },
            "level": 1,
            "school": "",
            "components": {
                "value": "",
                "vocal": false,
                "somatic": false,
                "material": false,
                "ritual": false,
                "concentration": false
            },
            "materials": {
                "value": "",
                "consumed": false,
                "cost": 0,
                "supply": 0
            },
            "preparation": {
                "mode": "always",
                "prepared": true
            },
            "scaling": {
                "mode": "level",
                "formula": "1d8"
            }
        }
    };
}

/**
 * {
 *  character: character,
 *  features: features,
 *  classes: classes,
 *  inventory: inventory,
 *  spells: spells,
 *  actions: actions,
 *  itemSpells: itemSpells,
 * };
 *
 * @param {*} ddb
 * @param {*} characterJSON
 */
function special(characterJSON) {
  const divineSmite = characterJSON.features.concat(characterJSON.actions)
    .some((f) => f.name === "Divine Smite" && f.type === "feat");
  if (divineSmite) {
      characterJSON.spells.push(getDivineSmite());
  }
}

;// CONCATENATED MODULE: ./src/parser/character.js











function parseJson(ddb) {
  try {
    src_logger/* default.debug */.Z.debug("Starting core character parse");
    let character = getCharacter(ddb);
    src_logger/* default.debug */.Z.debug("Character parse complete");
    let features = parseFeatures(ddb, character);
    src_logger/* default.debug */.Z.debug("Feature parse complete");
    let classes = classes_parseClasses(ddb);
    src_logger/* default.debug */.Z.debug("Classes parse complete");
    let spells = getCharacterSpells(ddb, character);
    src_logger/* default.debug */.Z.debug("Character Spells parse complete");
    let actions = parseActions(ddb, character);
    src_logger/* default.debug */.Z.debug("Action parse complete");
    let itemSpells = getItemSpells_getItemSpells(ddb, character);
    src_logger/* default.debug */.Z.debug("Item Spells parse complete");
    let inventory = getInventory(ddb, character, itemSpells);
    src_logger/* default.debug */.Z.debug("Inventory parse complete");

    [actions, features] = removeActionFeatures(actions, features);

    let characterJSON = {
      character: character,
      features: features,
      classes: classes,
      inventory: inventory,
      spells: spells,
      actions: actions,
      itemSpells: itemSpells,
    };

    special(characterJSON);

    return characterJSON;
  } catch (error) {
    src_logger/* default.error */.Z.error(error);
    src_logger/* default.error */.Z.error("Error during parse:", error.message);
    throw (error);
  }
}

// EXTERNAL MODULE: ./src/muncher/dae.js
var dae = __webpack_require__(728);
// EXTERNAL MODULE: ./src/icons/index.js
var icons = __webpack_require__(547);
// EXTERNAL MODULE: ./vendor/lowdash/isequal.js
var isequal = __webpack_require__(846);
;// CONCATENATED MODULE: ./src/character/update.js









var itemIndex;

async function getItemCompendium() {
  const compendiumLabel = (0,muncher_import/* getCompendiumLabel */.Eb)("item");
  const compendium = await game.packs.get(compendiumLabel);
  return compendium;
}

async function getUpdateItemIndex() {
  if (itemIndex) return itemIndex;
  const compendium = await getItemCompendium();

  const indexFields = [
    "name",
    "type",
    "flags.ddbimporter.definitionId",
    "flags.ddbimporter.definitionEntityTypeId",
  ];
  // eslint-disable-next-line require-atomic-updates
  itemIndex = await compendium.getIndex({ fields: indexFields });

  return itemIndex;
}

async function getCompendiumItemInfo(item) {
  const index = await getUpdateItemIndex();
  const match = await (0,muncher_import/* looseItemNameMatch */.uc)(item, index, true, false, true);
  return match;
}

async function updateCharacterCall(actor, path, bodyContent) {
  const characterId = actor.data.flags.ddbimporter.dndbeyond.characterId;
  const cobaltCookie = getCobalt(actor.id);
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const campaignId = (0,utils/* getCampaignId */.F9)();
  const proxyCampaignId = campaignId === "" ? null : campaignId;
  const coreBody = { cobalt: cobaltCookie, betaKey: betaKey, characterId: characterId, campaignId: proxyCampaignId };
  const body = { ...coreBody, ...bodyContent };

  src_logger/* default.debug */.Z.debug("Update body:", bodyContent);

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/update/${path}`, {
      method: "POST",
      cache: "no-cache",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (!data.success) {
          src_logger/* default.warn */.Z.warn("Update failed:", data.message);
          resolve(data);
        }
        src_logger/* default.debug */.Z.debug(`${path} updated`);
        return data;
      })
      .then((data) => resolve(data))
      .catch((error) => {
        src_logger/* default.error */.Z.error(`Setting ${path} failed`);
        src_logger/* default.error */.Z.error(error);
        src_logger/* default.error */.Z.error(error.stack);
        reject(error);
      });
  });
}

async function spellSlotsPact(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get("ddb-importer", "sync-policy-spells-slots")) resolve();
    if (
      actor.data.data.spells.pact.max > 0 &&
      ddbData.character.character.data.spells.pact.value !== actor.data.data.spells.pact.value
    ) {
      const used = actor.data.data.spells.pact.max - actor.data.data.spells.pact.value;
      let spellSlotPackData = {
        spellslots: {},
        pact: true,
      };
      spellSlotPackData.spellslots[`level${actor.data.data.spells.pact.level}`] = used;
      const spellPactSlots = updateCharacterCall(actor, "spell/slots", spellSlotPackData);
      resolve(spellPactSlots);
    }
    resolve();
  });
}

async function spellSlots(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get("ddb-importer", "sync-policy-spells-slots")) resolve();

    let spellSlotData = { spellslots: {}, update: false };
    for (let i = 1; i <= 9; i++) {
      let spellData = actor.data.data.spells[`spell${i}`];
      if (spellData.max > 0 && ddbData.character.character.data.spells[`spell${i}`].value !== spellData.value) {
        const used = spellData.max - spellData.value;
        spellSlotData.spellslots[`level${i}`] = used;
        spellSlotData["update"] = true;
      }
    }
    if (spellSlotData["update"]) {
      resolve(updateCharacterCall(actor, "spells/slots", spellSlotData));
    }

    resolve();
  });
}

async function currency(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get("ddb-importer", "sync-policy-currency")) resolve();

    const value = {
      pp: Number.isInteger(actor.data.data.currency.pp) ? actor.data.data.currency.pp : 0,
      gp: Number.isInteger(actor.data.data.currency.gp) ? actor.data.data.currency.gp : 0,
      ep: Number.isInteger(actor.data.data.currency.ep) ? actor.data.data.currency.ep : 0,
      sp: Number.isInteger(actor.data.data.currency.sp) ? actor.data.data.currency.sp : 0,
      cp: Number.isInteger(actor.data.data.currency.cp) ? actor.data.data.currency.cp : 0,
    };

    const same = (0,isequal/* isEqual */.X)(ddbData.character.character.data.currency, value);

    if (!same) {
      resolve(updateCharacterCall(actor, "currency", value));
    }

    resolve();
  });
}

async function xp(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get("ddb-importer", "sync-policy-xp")) resolve();
    const same = ddbData.character.character.data.details.xp.value === actor.data.data.details.xp.value;

    if (!same) {
      resolve(updateCharacterCall(actor, "xp", { currentXp: actor.data.data.details.xp.value }));
    }

    resolve();
  });
}

async function hitPoints(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get("ddb-importer", "sync-policy-hitpoints")) resolve();
    const localTemp = actor.data.data.attributes.hp.temp ? actor.data.data.attributes.hp.temp : 0;
    const same =
      ddbData.character.character.data.attributes.hp.value === actor.data.data.attributes.hp.value &&
      ddbData.character.character.data.attributes.hp.temp === localTemp;

    if (!same) {
      const hitPointData = {
        removedHitPoints: actor.data.data.attributes.hp.max - actor.data.data.attributes.hp.value,
        temporaryHitPoints: localTemp,
      };
      resolve(updateCharacterCall(actor, "hitpoints", hitPointData));
    }

    resolve();
  });
}

async function inspiration(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get("ddb-importer", "sync-policy-inspiration")) resolve();
    const same = ddbData.character.character.data.attributes.inspiration === actor.data.data.attributes.inspiration;

    if (!same) {
      const inspiration = updateCharacterCall(actor, "inspiration", {
        inspiration: actor.data.data.attributes.inspiration,
      });
      resolve(inspiration);
    }

    resolve();
  });
}

async function exhaustion(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get("ddb-importer", "sync-policy-condition")) resolve();
    const same = ddbData.character.character.data.attributes.exhaustion === actor.data.data.attributes.exhaustion;

    if (!same) {
      let exhaustionData = {
        conditionId: 4,
        addCondition: false,
      };
      if (actor.data.data.attributes.exhaustion !== 0) {
        exhaustionData["level"] = actor.data.data.attributes.exhaustion;
        exhaustionData["totalHP"] = actor.data.data.attributes.hp.max;
        exhaustionData["addCondition"] = true;
      }
      resolve(updateCharacterCall(actor, "condition", exhaustionData));
    }

    resolve();
  });
}

async function deathSaves(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get("ddb-importer", "sync-policy-deathsaves")) resolve();
    const same = (0,isequal/* isEqual */.X)(ddbData.character.character.data.attributes.death, actor.data.data.attributes.death);

    if (!same) {
      const deathSaveData = {
        failCount: actor.data.data.attributes.death.failure,
        successCount: actor.data.data.attributes.death.success,
      };
      resolve(updateCharacterCall(actor, "deathsaves", deathSaveData));
    }

    resolve();
  });
}

async function hitDice(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get("ddb-importer", "sync-policy-hitdice")) resolve();

    const ddbClasses = ddbData.character.classes;

    const klasses = actor.data.items.filter(
      (item) => item.type === "class" && item.data.flags.ddbimporter.id && item.data.flags.ddbimporter.definitionId
    );

    let hitDiceData = {
      classHitDiceUsed: {},
      resetMaxHpModifier: false,
    };

    klasses.forEach((klass) => {
      const classMatch = ddbClasses.find((ddbClass) => ddbClass.flags.ddbimporter.id === klass.data.flags.ddbimporter.id);
      if (classMatch && classMatch.data.hitDiceUsed !== klass.data.data.hitDiceUsed) {
        hitDiceData.classHitDiceUsed[klass.data.flags.ddbimporter.id] = klass.data.data.hitDiceUsed;
      }
    });

    const same = (0,isequal/* isEqual */.X)({}, hitDiceData.classHitDiceUsed);
    if (!same) {
      resolve(updateCharacterCall(actor, "hitdice", { shortRest: hitDiceData }));
    }

    resolve();
  });
}

async function updateSpellsPrepared(actor, spellPreparedData) {
  return new Promise((resolve) => {
    resolve(updateCharacterCall(actor, "spell/prepare", spellPreparedData));
  });
}

async function spellsPrepared(actor, ddbData) {
  if (!game.settings.get("ddb-importer", "sync-policy-spells-prepared")) return [];
  const ddbSpells = ddbData.character.spells;

  const preparedSpells = actor.data.items.filter((item) => {
    const spellMatch = ddbSpells.find((s) =>
      s.name === item.name &&
      item.data.data.preparation?.mode === "prepared" &&
      item.data.flags.ddbimporter?.dndbeyond?.characterClassId &&
      item.data.flags.ddbimporter?.dndbeyond?.characterClassId === s.flags.ddbimporter?.dndbeyond?.characterClassId
    );
    if (!spellMatch) return false;
    const select = item.type === "spell" &&
      item.data.data.preparation?.mode === "prepared" &&
      item.data.data.preparation.prepared !== spellMatch.data.preparation?.prepared;
    return spellMatch && select;
  }).map((spell) => {
    let spellPreparedData = {
        spellInfo: {
          spellId: spell.data.flags.ddbimporter.definitionId,
          characterClassId: spell.data.flags.ddbimporter.dndbeyond.characterClassId,
          entityTypeId: spell.data.flags.ddbimporter.entityTypeId,
          id: spell.data.flags.ddbimporter.id,
          prepared: false,
        }
    };
    if (spell.data.data.preparation.prepared) spellPreparedData.spellInfo.prepared = true;
    return spellPreparedData;
  });

  let promises = [];
  preparedSpells.forEach((spellPreparedData) => {
    // console.warn(spellPreparedData);
    // promises.push(spellPreparedData);
    promises.push(updateSpellsPrepared(actor, spellPreparedData));
  });

  return Promise.all(promises);

}


async function generateItemsToAdd(itemsToAdd) {
  const results = {
    items: [],
    toAdd: [],
    custom: [],
  };

  for (let i = 0; i < itemsToAdd.length; i++) {
    let item = itemsToAdd[i];
    if (item.flags.ddbimporter?.definitionId && item.flags.ddbimporter?.definitionEntityTypeId) {
      results.toAdd.push({
        entityId: parseInt(item.flags.ddbimporter.definitionId),
        entityTypeId: parseInt(item.flags.ddbimporter.definitionEntityTypeId),
        quantity: parseInt(item.data.quantity),
      });
    } else {
      // eslint-disable-next-line no-await-in-loop
      const ddbCompendiumMatch = await getCompendiumItemInfo(item);
      src_logger/* default.debug */.Z.debug(`Found item`, ddbCompendiumMatch);
      if (ddbCompendiumMatch &&
        ddbCompendiumMatch.flags?.ddbimporter?.definitionId &&
        ddbCompendiumMatch.flags?.ddbimporter?.definitionEntityTypeId
      ) {
        src_logger/* default.debug */.Z.debug(`Adding ${item.name} from DDB compendium match:`, ddbCompendiumMatch);
        setProperty(item, "flags.ddbimporter.definitionId", ddbCompendiumMatch.flags.ddbimporter.definitionId);
        setProperty(item, "flags.ddbimporter.definitionEntityTypeId", ddbCompendiumMatch.flags.ddbimporter.definitionEntityTypeId);
        setProperty(item, "name", ddbCompendiumMatch.name);
        setProperty(item, "type", ddbCompendiumMatch.type);
        results.toAdd.push({
          entityId: parseInt(ddbCompendiumMatch.flags.ddbimporter.definitionId),
          entityTypeId: parseInt(ddbCompendiumMatch.flags.ddbimporter.definitionEntityTypeId),
          quantity: parseInt(item.data.quantity),
        });
      } else {
        results.custom.push(item);
      }
    }
    results.items.push(item);
  }
  return new Promise((resolve) => {
    resolve(results);
  });
}

async function addEquipment(actor, ddbData) {
  const syncItemReady = actor.data.flags.ddbimporter?.syncItemReady;
  if (syncItemReady && !game.settings.get("ddb-importer", "sync-policy-equipment")) return [];
  const ddbItems = ddbData.character.inventory;

  const itemsToAdd = actor.data.items.filter((item) =>
    !item.data.flags.ddbimporter?.action &&
    item.data.data.quantity !== 0 &&
    dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(item.type) &&
    !item.data.flags.ddbimporter?.custom &&
    (!item.data.flags.ddbimporter?.id ||
    !ddbItems.some((s) => s.flags.ddbimporter?.id === item.data.flags.ddbimporter?.id && s.type === item.type))
  ).map((item) => item.toObject());

  const generatedItemsToAddData = await generateItemsToAdd(itemsToAdd);

  src_logger/* default.debug */.Z.debug(`Generated items data`, generatedItemsToAddData);

  const addItemData = {
    equipment: generatedItemsToAddData.toAdd,
  };

  if (addItemData.equipment.length > 0) {
    const itemResults = await updateCharacterCall(actor, "equipment/add", addItemData);
    try {
      const itemUpdates = itemResults.data.addItems
        .filter((addedItem) => itemsToAdd.some((i) =>
          i.flags.ddbimporter &&
          i.flags.ddbimporter.definitionId === addedItem.definition.id &&
          i.flags.ddbimporter.definitionEntityTypeId === addedItem.definition.entityTypeId
        ))
        .map((addedItem) => {
          let updatedItem = itemsToAdd.find((i) =>
            i.flags.ddbimporter &&
            i.flags.ddbimporter.definitionId === addedItem.definition.id &&
            i.flags.ddbimporter.definitionEntityTypeId === addedItem.definition.entityTypeId
          );
          setProperty(updatedItem, "flags.ddbimporter.id", addedItem.id);
          return updatedItem;
        });

      src_logger/* default.debug */.Z.debug("Character item updates:", itemUpdates);

      try {
        await actor.updateEmbeddedDocuments("Item", itemUpdates);
      } catch (err) {
        src_logger/* default.error */.Z.error(`Unable to update character with equipment, got the error:`, err);
        src_logger/* default.error */.Z.error(`Update payload:`, itemUpdates);
      }

    } catch (err) {
      src_logger/* default.error */.Z.error(`Unable to filter updated equipment, got the error:`, err);
      src_logger/* default.error */.Z.error(`itemsToAdd`, itemsToAdd);
      src_logger/* default.error */.Z.error(`equipmentToAdd`, generatedItemsToAddData);
      src_logger/* default.error */.Z.error(`itemResults`, itemResults);
    }

    return itemResults;
  } else {
    return [];
  }
}

// updates names of items and actions
async function updateCustomNames(actor, ddbData) {
  const syncItemReady = actor.data.flags.ddbimporter?.syncItemReady;
  if (syncItemReady && !game.settings.get("ddb-importer", "sync-policy-equipment")) return [];
  const ddbItems = ddbData.character.inventory;

  const itemsToName = actor.data.items.filter((item) =>
    item.data.data.quantity != 0 &&
    (dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(item.type) || item.data.flags.ddbimporter?.action) &&
    item.data.flags.ddbimporter?.id &&
    // item.data.flags.ddbimporter?.entityTypeId &&
    ddbItems.some((s) => s.flags.ddbimporter?.id === item.data.flags.ddbimporter.id && s.type === item.type && s.name !== item.name)
  ).map((item) => item.toObject());

  let promises = [];

  itemsToName.forEach((item) => {
    const customData = {
      customValues: {
        characterId: parseInt(actor.data.flags.ddbimporter.dndbeyond.characterId),
        contextId: null,
        contextTypeId: null,
        notes: null,
        typeId: 8,
        value: item.name,
        valueId: `${item.flags.ddbimporter.id}`,
        valueTypeId: `${item.flags.ddbimporter.entityTypeId}`,
      }
    };
    promises.push(updateCharacterCall(actor, "equipment/custom", customData));
  });

  return Promise.all(promises);
}

async function removeEquipment(actor, ddbData) {
  const syncItemReady = actor.data.flags.ddbimporter?.syncItemReady;
  if (syncItemReady && !game.settings.get("ddb-importer", "sync-policy-equipment")) return [];
  const ddbItems = ddbData.character.inventory;

  const itemsToRemove = ddbItems.filter((item) =>
    (!actor.data.items.some((s) => (item.flags.ddbimporter?.id === s.data.flags.ddbimporter?.id && s.type === item.type) && !s.data.flags.ddbimporter?.action) ||
    actor.data.items.some((s) => (item.flags.ddbimporter?.id === s.data.flags.ddbimporter?.id && s.type === item.type) && !s.data.flags.ddbimporter?.action && s.data.data.quantity == 0)) &&
    dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(item.type) &&
    item.flags.ddbimporter?.id
  );

  let promises = [];

  itemsToRemove.forEach((item) => {
    promises.push(updateCharacterCall(actor, "equipment/remove", { itemId: parseInt(item.flags.ddbimporter.id) }));
  });

  return Promise.all(promises);
}

async function updateEquipmentStatus(actor, ddbData, addEquipmentResults) {
  const syncItemReady = actor.data.flags.ddbimporter?.syncItemReady;
  if (syncItemReady && !game.settings.get("ddb-importer", "sync-policy-equipment")) return [];
  // reload the actor following potential updates to equipment
  let ddbItems = ddbData.ddb.character.inventory;
  if (addEquipmentResults?.data) {
    actor = game.actors.get(actor.id);
    ddbItems = ddbItems.concat(addEquipmentResults.data.addItems);
  }

  const itemsToEquip = actor.data.items.filter((item) =>
    !item.data.flags.ddbimporter?.action && item.data.flags.ddbimporter?.id &&
    ddbItems.some((dItem) =>
      item.data.flags.ddbimporter.id === dItem.id &&
      dItem.id === item.data.flags.ddbimporter?.id &&
      item.data.data.equipped !== dItem.equipped
    )
  );
  const itemsToAttune = actor.data.items.filter((item) =>
    !item.data.flags.ddbimporter?.action && item.data.flags.ddbimporter?.id &&
    ddbItems.some((dItem) =>
      item.data.flags.ddbimporter.id === dItem.id &&
      dItem.id === item.data.flags.ddbimporter?.id &&
      ((item.data.data.attunement === 2) !== dItem.isAttuned)
    )
  );
  const itemsToCharge = actor.data.items.filter((item) =>
    !item.data.flags.ddbimporter?.action && item.data.flags.ddbimporter?.id &&
    ddbItems.some((dItem) =>
      item.data.flags.ddbimporter.id === dItem.id &&
      dItem.id === item.data.flags.ddbimporter?.id &&
      item.data.data.uses?.max && dItem.limitedUse?.numberUsed &&
      ((parseInt(item.data.data.uses.max) - parseInt(item.data.data.uses.value)) !== dItem.limitedUse.numberUsed)
    )
  );
  const itemsToQuantity = actor.data.items.filter((item) =>
    !item.data.flags.ddbimporter?.action && item.data.flags.ddbimporter?.id &&
    !item.data.data.quantity == 0 &&
    ddbItems.some((dItem) =>
      item.data.flags.ddbimporter.id === dItem.id &&
      dItem.id === item.data.flags.ddbimporter?.id &&
      item.data.data.quantity !== dItem.quantity
    )
  );
  const itemsToName = actor.data.items.filter((item) =>
    item.data.flags.ddbimporter?.id &&
    // item.data.flags.ddbimporter?.entityTypeId &&
    item.data.data.quantity !== 0 &&
    ddbItems.some((dItem) =>
      // item.data.flags.ddbimporter.id === dItem.id &&
      item.data.flags.ddbimporter.originalName === dItem.definition.name &&
      item.data.flags.ddbimporter.originalName !== item.data.name &&
      dItem.id === item.data.flags.ddbimporter?.id &&
      item.data.name !== dItem.definition.name
    )
  );

  let promises = [];

  itemsToEquip.forEach((item) => {
    const itemData = { itemId: item.data.flags.ddbimporter.id, value: item.data.data.equipped };
    promises.push(updateCharacterCall(actor, "equipment/equipped", itemData));
  });
  itemsToAttune.forEach((item) => {
    const itemData = { itemId: item.data.flags.ddbimporter.id, value: (item.data.data.attunement === 2) };
    promises.push(updateCharacterCall(actor, "equipment/attuned", itemData));
  });
  itemsToCharge.forEach((item) => {
    const itemData = {
      itemId: item.data.flags.ddbimporter.id,
      charges: parseInt(item.data.data.uses.max) - parseInt(item.data.data.uses.value),
    };
    promises.push(updateCharacterCall(actor, "equipment/charges", itemData));
  });
  itemsToQuantity.forEach((item) => {
    const itemData = {
      itemId: item.data.flags.ddbimporter.id,
      quantity: parseInt(item.data.data.quantity),
    };
    promises.push(updateCharacterCall(actor, "equipment/quantity", itemData));
  });
  itemsToName.forEach((item) => {
    const entityTypeId = ddbItems.find((dItem) => dItem.id === item.data.flags.ddbimporter.id).entityTypeId;
    const customData = {
      customValues: {
        characterId: parseInt(actor.data.flags.ddbimporter.dndbeyond.characterId),
        contextId: null,
        contextTypeId: null,
        notes: null,
        typeId: 8,
        value: item.name,
        valueId: `${item.data.flags.ddbimporter.id}`,
        valueTypeId: `${entityTypeId}`,
      }
    };
    promises.push(updateCharacterCall(actor, "equipment/custom", customData));
  });

  return Promise.all(promises);
}

async function actionUpdate(actor, ddbData) {
  const syncActionReady = actor.data.flags.ddbimporter?.syncActionReady;
  if (syncActionReady && !game.settings.get("ddb-importer", "sync-policy-action-use")) return [];

  let ddbActions = ddbData.character.actions;

  const actionsToCharge = actor.data.items.filter((item) =>
    (item.data.flags.ddbimporter?.action || item.type === "feat") &&
    item.data.flags.ddbimporter?.id && item.data.flags.ddbimporter?.entityTypeId &&
    ddbActions.some((dItem) =>
      item.data.flags.ddbimporter.id === dItem.flags.ddbimporter.id &&
      item.data.flags.ddbimporter.entityTypeId === dItem.flags.ddbimporter.entityTypeId &&
      item.name === dItem.name && item.type === dItem.type &&
      item.data.data.uses?.value &&
      item.data.data.uses.value !== dItem.data.uses.value
    )
  );

  let promises = [];

  actionsToCharge.forEach((action) => {
    const actionData = {
      actionId: action.data.flags.ddbimporter.id,
      entityTypeId: action.data.flags.ddbimporter.entityTypeId,
      uses: parseInt(action.data.data.uses.max) - parseInt(action.data.data.uses.value)
    };
    promises.push(updateCharacterCall(actor, "action/use", actionData));
  });

  return Promise.all(promises);
}

async function updateDDBCharacter(actor) {
  const cobaltCheck = await checkCobalt(actor.id);

  if (cobaltCheck.success) {
    src_logger/* default.debug */.Z.debug(`Cobalt checked`);
  } else {
    src_logger/* default.error */.Z.error(`Cobalt cookie expired, please reset`);
    src_logger/* default.error */.Z.error(cobaltCheck.message);
    throw cobaltCheck.message;
  }

  const characterId = actor.data.flags.ddbimporter.dndbeyond.characterId;
  const syncId = actor.data.flags["ddb-importer"]?.syncId ? actor.data.flags["ddb-importer"].syncId + 1 : 0;
  let ddbData = await getCharacterData(characterId, syncId, actor.id);

  src_logger/* default.debug */.Z.debug("Current actor:", actor.data);
  src_logger/* default.debug */.Z.debug("DDB Parsed data:", ddbData);

  let singlePromises = []
    .concat(
      currency(actor, ddbData),
      hitPoints(actor, ddbData),
      hitDice(actor, ddbData),
      spellSlots(actor, ddbData),
      spellSlotsPact(actor, ddbData),
      inspiration(actor, ddbData),
      exhaustion(actor, ddbData),
      deathSaves(actor, ddbData),
      xp(actor, ddbData),
    ).flat();

  const singleResults = await Promise.all(singlePromises);
  const spellsPreparedResults = await spellsPrepared(actor, ddbData);
  const actionUpdateResults = await actionUpdate(actor, ddbData);
  const nameUpdateResults = await updateCustomNames(actor, ddbData);
  const addEquipmentResults = await addEquipment(actor, ddbData);
  const removeEquipmentResults = await removeEquipment(actor, ddbData);

  const updateEquipmentStatusResults = await updateEquipmentStatus(actor, ddbData, addEquipmentResults);

  // if a known/choice spellcaster
  // and new spell/ spells removed
  // for each spell add or remove, e.g.
  // const spellsData = {
  //   characterClassId: 52134801,
  //   spellId: 2019,
  //   id: 136157,
  //   entityTypeId: 435869154,
  //   remove: true,
  // };
  // const spellSlots = updateCharacterCall(actor, "spells", spellsData);
  // promises.push(spellSlots);

  actor.setFlag("ddb-importer", "syncId", syncId);

  // we can now process item attunements and uses (not yet done)

  const results = singleResults.concat(
    nameUpdateResults,
    addEquipmentResults,
    spellsPreparedResults,
    removeEquipmentResults,
    updateEquipmentStatusResults,
    actionUpdateResults
  ).filter((result) => result !== undefined);

  src_logger/* default.debug */.Z.debug("Update results", results);

  return results;
}

// EXTERNAL MODULE: ./src/character/extras.js
var extras = __webpack_require__(320);
;// CONCATENATED MODULE: ./src/parser/effects/abilityOverrides.js
// import utils from "../../utils.js";
// import logger from "../../logger.js";



function buildBaseOverrideEffect(label) {
  let effect = {
    changes: [],
    duration: {
      seconds: null,
      startTime: null,
      rounds: null,
      turns: null,
      startRound: null,
      startTurn: null,
    },
    origin: "Ability.Override",
    label,
    tint: "",
    disabled: false,
    transfer: true,
    selectedKey: [],
    icon: "icons/svg/anchor.svg",
    flags: {
      dae: { transfer: true },
      ddbimporter: { disabled: false, itemId: null, entityTypeId: null }
    },
  };
  return effect;
}


function abilityOverrideEffects(overrides) {
  let effects = buildBaseOverrideEffect("Ability Overrides");

  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
    if (overrides[ability.value] === 0) return;
    effects.changes.push((0,effects_effects/* generateOverrideChange */.Pk)(overrides[ability.value], 50, `data.abilities.${ability.value}.value`));
  });

  return effects;
}

;// CONCATENATED MODULE: ./src/character/import.js
















const FILTER_SECTIONS = ["classes", "features", "actions", "inventory", "spells"];

const DISABLE_FOUNDRY_UPGRADE = {
  applyFeatures: false,
  addFeatures: false,
  promptAddFeatures: false,
};


// reference to the D&D Beyond popup
const import_POPUPS = {
  json: null,
  web: null,
};
const import_renderPopup = (type, url) => {
  if (import_POPUPS[type] && !import_POPUPS[type].close) {
    import_POPUPS[type].focus();
    import_POPUPS[type].location.href = url;
  } else {
    const ratio = window.innerWidth / window.innerHeight;
    const width = Math.round(window.innerWidth * 0.5);
    const height = Math.round(window.innerWidth * 0.5 * ratio);
    import_POPUPS[type] = window.open(
      url,
      "ddb_sheet_popup",
      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`
    );
  }
  return true;
};

/**
 * Retrieves the character ID from a given URL, which can be one of the following:
 * - regular character sheet
 * - public sharing link
 * - direct link to the endpoint already
 * @param {string} url A given URL pointing to a character. Contains the character ID
 * @returns {string} characterId or null
 */
const getCharacterId = (url) => {
  let matches;
  const CONFIGS = [
    () => {
      const PATTERN = /.*dndbeyond\.com\/profile\/[\w-_]+\/characters\/(\d+)/;
      matches = url.match(PATTERN);
      if (matches) {
        return matches[1];
      }
      return null;
    },
    () => {
      const PATTERN = /ddb.ac\/characters\/(\d+)\/[\w-_]+/;
      matches = url.match(PATTERN);
      if (matches) {
        return matches[1];
      }
      return null;
    },
    () => {
      const PATTERN = /dndbeyond.com\/characters\/(\d+)/;
      matches = url.match(PATTERN);
      if (matches) {
        return matches[1];
      }
      return null;
    },
    () => {
      const PATTERN = /character-service.dndbeyond.com\/character\/v\d+\/character\/(\d+)/;
      matches = url.match(PATTERN);
      if (matches) {
        return matches[1];
      }
      return null;
    },
  ];

  return CONFIGS.map((fn) => fn(url)).reduce((prev, cur) => (!prev && cur ? cur : prev), null);
};

/**
 * Creates the Character Endpoint URL from a given character ID
 * @param {string} characterId The character ID
 * @returns {string|null} The API endpoint
 */
const getCharacterAPIEndpoint = (characterId) => {
  return characterId !== null ? `https://character-service.dndbeyond.com/character/v5/character/${characterId}` : null;
};

const getCharacterUpdatePolicyTypes = (invert = false) => {
  let itemTypes = [];

  if (invert) {
    if (!game.settings.get("ddb-importer", "character-update-policy-class")) itemTypes.push("class");
    if (!game.settings.get("ddb-importer", "character-update-policy-feat")) itemTypes.push("feat");
    if (!game.settings.get("ddb-importer", "character-update-policy-weapon")) itemTypes.push("weapon");
    if (!game.settings.get("ddb-importer", "character-update-policy-equipment"))
      itemTypes = itemTypes.concat(dictionary/* default.types.equipment */.Z.types.equipment);
    if (!game.settings.get("ddb-importer", "character-update-policy-spell")) itemTypes.push("spell");
  } else {
    if (game.settings.get("ddb-importer", "character-update-policy-class")) itemTypes.push("class");
    if (game.settings.get("ddb-importer", "character-update-policy-feat")) itemTypes.push("feat");
    if (game.settings.get("ddb-importer", "character-update-policy-weapon")) itemTypes.push("weapon");
    if (game.settings.get("ddb-importer", "character-update-policy-equipment"))
      itemTypes = itemTypes.concat(dictionary/* default.types.equipment */.Z.types.equipment);
    if (game.settings.get("ddb-importer", "character-update-policy-spell")) itemTypes.push("spell");
  }
  return itemTypes;
};

/**
 * Returns a combined array of all items to process, filtered by the user's selection on what to skip and what to include
 * @param {object} result object containing all character items sectioned as individual properties
 * @param {array[string]} sections an array of object properties which should be filtered
 */
const filterItemsByUserSelection = (result, sections, invert = false) => {
  let items = [];
  const validItemTypes = getCharacterUpdatePolicyTypes(invert);

  for (const section of sections) {
    items = items.concat(result[section]).filter((item) => validItemTypes.includes(item.type));
  }
  return items;
};

const filterActorItemsByUserSelection = (actor, invert = false) => {
  const validItemTypes = getCharacterUpdatePolicyTypes(invert);

  const items = actor.items.filter((item) => validItemTypes.includes(item.type));

  return items;
};

/**
 * Loads and parses character in the proxy
 * @param {*} characterId
 */

async function getCharacterData(characterId, syncId, localCobaltPostFix = "") {
  const cobaltCookie = getCobalt(localCobaltPostFix);
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const campaignId = (0,utils/* getCampaignId */.F9)();
  const proxyCampaignId = campaignId === "" ? null : campaignId;
  let body = { cobalt: cobaltCookie, betaKey: betaKey, characterId: characterId, campaignId: proxyCampaignId };
  if (syncId) {
    body["updateId"] = syncId;
  }

  try {
    const response = await fetch(`${parsingApi}/proxy/v5/character`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      redirect: "follow", // manual, *follow, error
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    });
    const data = await response.json();
    if (!data.success) return data;

    // load some required content
    await (0,templateStrings/* loadSRDRules */.x)();

    // construct the expected { character: {...} } object
    let ddb = {};
    if (data.ddb.character === undefined) {
      ddb = {
        character: data.ddb,
        classOptions: data.ddb.classOptions,
        originOptions: data.ddb.originOptions,
        infusions: data.ddb.infusions,
      };
    } else {
      // fallback to old proxy style
      ddb = data.ddb;
    }

    src_logger/* default.debug */.Z.debug("DDB Data to parse:", JSON.parse(JSON.stringify(ddb)));
    try {
      const character = parseJson(ddb);
      const shouldChangeName = game.settings.get("ddb-importer", "character-update-policy-name");
      if (!shouldChangeName) {
        character.character.name = undefined;
        character.character.token.name = undefined;
      }
      data["character"] = character;
      return data;
    } catch (error) {
      const debugJson = game.settings.get("ddb-importer", "debug-json");
      if (debugJson) {
        (0,utils/* download */.LR)(JSON.stringify(data), `${characterId}-raw.json`, "application/json");
      }
      throw error;
    }
  } catch (error) {
    src_logger/* default.error */.Z.error("JSON Fetch and Parse Error");
    src_logger/* default.error */.Z.error(error);
    src_logger/* default.error */.Z.error(error.stack);
    throw error;
  }
}

class CharacterImport extends FormApplication {
  constructor(options, actor) {
    super(options);
    this.actor = game.actors.get(actor._id);
    this.migrateMetadata();
    this.actorOriginal = JSON.parse(JSON.stringify(this.actor));
    this.result = {};
  }

  migrateMetadata() {
    if (this.actor.data.flags?.ddbimporter?.dndbeyond) {
      const url = this.actor.data.flags.ddbimporter.dndbeyond.url || this.actor.data.flags.ddbimporter.dndbeyond.roUrl;

      if (url && !this.actor.data.flags.ddbimporter.characterId) {
        const characterId = getCharacterId(url);
        if (characterId) {
          const apiEndpointUrl = getCharacterAPIEndpoint(characterId);
          this.actor.data.flags.ddbimporter.dndbeyond.characterId = characterId;
          this.actor.data.flags.ddbimporter.dndbeyond.apiEndpointUrl = apiEndpointUrl;
          this.actor.data.flags.ddbimporter.dndbeyond.url = url;
        } else {
          // clear the url, because it's malformed anyway
          this.actor.data.flags.ddbimporter.dndbeyond.url = null;
        }
      }
    }
  }

  /**
   * Define default options for the PartySummary application
   */
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.title = game.i18n.localize("ddb-importer.module-name");
    options.template = "modules/ddb-importer/handlebars/character.hbs";
    options.width = 900;
    options.height = "auto";
    options.classes = ["ddbimporter", "sheet"];
    options.tabs = [{ navSelector: ".tabs", contentSelector: "form", initial: "import" }];

    return options;
  }

  static showCurrentTask(html, title, message = null, isError = false) {
    let element = $(html).find(".task-name");
    element.html(`<h2 ${isError ? " style='color:red'" : ""}>${title}</h2>${message ? `<p>${message}</p>` : ""}`);
    $(html).parent().parent().css("height", "auto");
  }

  /**
   * Loops through a characters items and updates flags
   * @param {*} items
   */
  async copySupportedCharacterItemFlags(items) {
    items.forEach((item) => {
      const originalItem = this.actorOriginal.items.find(
        (originalItem) => item.name === originalItem.name && item.type === originalItem.type
      );
      if (originalItem) {
        (0,muncher_import/* copySupportedItemFlags */.uf)(originalItem, item);
      }
    });
  }

  copyExistingJournalNotes() {
    if (!this.actorOriginal) return;
    const journalFields = [
      "notes1name",
      "notes2name",
      "notes3name",
      "notes4name",
      "notes1",
      "notes2",
      "notes3",
      "notes4",
      "notes",
    ];
    journalFields.forEach((field) => {
      if (this.actorOriginal.data.details[field]) {
        this.actor.data.data.details[field] = this.actorOriginal.data.details[field];
      }
    });
  }

  async copyCharacterItemEffects(items) {
    return new Promise((resolve) => {
      resolve(
        items.map((item) => {
          const originalItem = this.actorOriginal.items.find(
            (originalItem) => item.name === originalItem.name && item.type === originalItem.type
          );
          if (originalItem) {
            if (!item.effects) item.effects = [];
            if (originalItem.effects) {
              src_logger/* default.info */.Z.info(`Copying Effects for ${originalItem.name}`);
              item.effects = originalItem.effects.map((m) => {
                delete m._id;
                return m;
              });
            }
          }
          return item;
        })
      );
    });
  }

  /**
   * Removes items
   * @param {*} items
   * @param {*} itemsToRemove
   */
  static async removeItems(items, itemsToRemove) {
    return new Promise((resolve) => {
      resolve(
        items.filter(
          (item) =>
            !itemsToRemove.some((originalItem) => {
              const originalNameFlag = ((originalItem.flags || {}).ddbimporter || {}).originalItemName;
              const originalNameMatch = originalNameFlag
                ? originalItem.flags.ddbimporter.originalItemName === item.name
                : false;
              const nameMatch = item.name === originalItem.name || originalNameMatch;
              return nameMatch && item.type === originalItem.type;
            })
        )
      );
    });
  }

  /**
   * Deletes items from the inventory bases on which sections a user wants to update
   * Possible sections:
   * - class
   * - feat
   * - weapon
   * - equipment
   * - inventory: consumable, loot, tool and backpack
   * - spell
   */
  async clearItemsByUserSelection(excludedList = []) {
    const includedItems = getCharacterUpdatePolicyTypes();

    // collect all items belonging to one of those inventory item categories
    const ownedItems = this.actor.getEmbeddedCollection("Item");
    const toRemove = ownedItems
      .filter(
        (item) => includedItems.includes(item.type) && !excludedList.some((excluded) => excluded._id === item.id)
      )
      .filter((item) => !item.data.flags.ddbimporter?.ignoreItemImport)
      .map((item) => item.id);

    // console.warn(JSON.parse(JSON.stringify(this.actor)));
    src_logger/* default.debug */.Z.debug("Removing the following character items", toRemove);
    if (toRemove.length > 0) {
      await this.actor.deleteEmbeddedDocuments("Item", toRemove);
    }
    return toRemove;
  }

  async updateImage(html, data) {
    // updating the image?
    let imagePath = this.actor.img;
    const decorations = data.character.decorations;
    const userHasPermission = !(game.settings.get("ddb-importer", "restrict-to-trusted") && !game.user.isTrusted);
    if (
      userHasPermission &&
      decorations?.avatarUrl &&
      decorations.avatarUrl !== "" &&
      (imagePath.indexOf("mystery-man") !== -1 || game.settings.get("ddb-importer", "character-update-policy-image"))
    ) {
      CharacterImport.showCurrentTask(html, "Uploading avatar image");
      let filename = data.character.name
        .replace(/[^a-zA-Z]/g, "-")
        .replace(/-+/g, "-")
        .trim();

      const uploadDirectory = game.settings.get("ddb-importer", "image-upload-directory").replace(/^\/|\/$/g, "");
      imagePath = await src_utils/* default.uploadImage */.Z.uploadImage(decorations.avatarUrl, uploadDirectory, filename);
      this.result.character.img = imagePath;
      if (decorations?.frameAvatarUrl && decorations.frameAvatarUrl !== "") {
        const framePath = await src_utils/* default.uploadImage */.Z.uploadImage(decorations.frameAvatarUrl, uploadDirectory, `frame-${filename}`);
        this.result.character.flags.ddbimporter["framePath"] = framePath;
      }
    }
  }

  async showErrorMessage(html, error) {
    src_logger/* default.info */.Z.info("%c #### PLEASE PASTE TO DISCORD #####", "color: #ff0000");
    src_logger/* default.info */.Z.info("%c #### ", "color: #ff0000");
    src_logger/* default.info */.Z.info("%c #### --------------- COPY BELOW --------------- #####", "color: #ff0000");
    if (
      this.actor.data.flags.ddbimporter &&
      this.actor.data.flags.ddbimporter.dndbeyond &&
      this.actor.data.flags.ddbimporter.dndbeyond.url
    ) {
      const characterId = this.actor.data.flags.ddbimporter.dndbeyond.url.split("/").pop();
      if (characterId) {
        const jsonUrl = "https://character-service.dndbeyond.com/character/v5/character/" + characterId;
        src_logger/* default.info */.Z.info("%c **Character JSON          :** " + jsonUrl, "color: #ff0000");
      }
    }
    src_logger/* default.info */.Z.info(`%c **Foundry version         :** ${game.data.version}`, "color: #ff0000");
    src_logger/* default.info */.Z.info(`%c **DND5e version           :** ${game.system.data.version}`, "color: #ff0000");
    const moduleVersion = game.modules.get("ddb-importer").data.version;
    src_logger/* default.info */.Z.info(`%c **ddb-importer version    :** ${moduleVersion}`, "color: #ff0000");
    src_logger/* default.info */.Z.info(error);
    src_logger/* default.info */.Z.info("%c #### --------------- COPY ABOVE --------------- #####", "color: #ff0000");
    CharacterImport.showCurrentTask(
      html,
      "I guess you are special!",
      `We had trouble understanding this character. But you can help us to improve!</p>
      <p>Please</p>
      <ul>
        <li>open the console with F12</li>
        <li>search for a block of text starting with <b>#### PLEASE PASTE TO ...</b></li>
        <li>Copy the designated lines and submit it to the Discord channel <a href=">#bugs</a></li></ul> Thanks!`,
      true
    );
  }

  /* -------------------------------------------- */

  async getData() {

    // loads settings for actor
    const importSettings = getCharacterImportSettings();

    const characterId = this.actor.data.flags?.ddbimporter?.dndbeyond?.characterId;
    const syncEnabled = characterId && importSettings.tiers.all;

    const trustedUsersOnly = game.settings.get("ddb-importer", "restrict-to-trusted");
    const allowAllSync = game.settings.get("ddb-importer", "allow-all-sync");
    const syncOnly = trustedUsersOnly && allowAllSync && !game.user.isTrusted;

    const localCobalt = isLocalCobalt(this.actor.id);
    const cobaltCookie = getCobalt(this.actor.id);
    const cobaltSet = localCobalt && cobaltCookie && cobaltCookie != "";
    const itemCompendium = await getItemCompendium();

    const itemsMunched = syncEnabled
      ? await itemCompendium.index.size !== 0
      : false;

    const actorSettings = {
      actor: this.actor,
      localCobalt: localCobalt,
      cobaltSet: cobaltSet,
      syncEnabled: syncEnabled && itemsMunched,
      importAllowed: !syncOnly,
      itemsMunched: itemsMunched,
    };

    return mergeObject(importSettings, actorSettings);
  }

  /* -------------------------------------------- */

  activateListeners(html) {
    super.activateListeners(html);
    // watch the change of the import-policy-selector checkboxes
    $(html)
      .find(
        [
          '.import-policy input[type="checkbox"]',
          '.advanced-import-config input[type="checkbox"]',
          '.effect-policy input[type="checkbox"]',
          '.effect-import-config input[type="checkbox"]',
          '.extras-import-config input[type="checkbox"]',
          '.import-config input[type="checkbox"]',
        ].join(",")
      )
      .on("change", (event) => {
        updateActorSettings(html, event);

      });

    $(html)
      .find("#default-effects")
      .on("click", async (event) => {
        event.preventDefault();
        setRecommendedCharacterActiveEffectSettings(html);

      });

    $(html)
      .find('.sync-policy input[type="checkbox"]')
      .on("change", (event) => {
        game.settings.set(
          "ddb-importer",
          "sync-policy-" + event.currentTarget.dataset.section,
          event.currentTarget.checked
        );
      });

    $(html)
      .find("#dndbeyond-character-import-start")
      .on("click", async (event) => {
        // retrieve the character data from the proxy
        event.preventDefault();

        try {
          $(html).find("#dndbeyond-character-import-start").prop("disabled", true);
          CharacterImport.showCurrentTask(html, "Getting Character data");
          const characterId = this.actor.data.flags.ddbimporter.dndbeyond.characterId;
          const characterData = await getCharacterData(characterId, null, this.actor.id);
          src_logger/* default.debug */.Z.debug("import.js getCharacterData result", characterData);
          const debugJson = game.settings.get("ddb-importer", "debug-json");
          if (debugJson) {
            (0,utils/* download */.LR)(JSON.stringify(characterData), `${characterId}.json`, "application/json");
          }
          if (characterData.success) {
            // begin parsing the character data
            await this.parseCharacterData(html, characterData);
            CharacterImport.showCurrentTask(html, "Loading Character data", "Done.", false);
            this.close();
          } else {
            CharacterImport.showCurrentTask(html, characterData.message, null, true);
            return false;
          }
        } catch (error) {
          switch (error) {
            case "Forbidden":
              CharacterImport.showCurrentTask(html, "Error retrieving Character: " + error, error, true);
              break;
            default:
              src_logger/* default.error */.Z.error(error);
              src_logger/* default.error */.Z.error(error.stack);
              CharacterImport.showCurrentTask(html, "Error parsing Character: " + error, error, true);
              break;
          }
          return false;
        }

        $(html).find("#dndbeyond-character-import-start").prop("disabled", false);
        return true;
      });

    $(html)
      .find("#dndbeyond-character-update")
      .on("click", async () => {
        try {
          $(html).find("#dndbeyond-character-update").prop("disabled", true);
          await updateDDBCharacter(this.actor).then((result) => {
            const updateNotes = result
              .flat()
              .filter((r) => r !== undefined)
              .map((r) => r.message)
              .join(" ");
            src_logger/* default.debug */.Z.debug(updateNotes);
            CharacterImport.showCurrentTask(html, "Update complete", updateNotes);
            $(html).find("#dndbeyond-character-update").prop("disabled", false);
          });
        } catch (error) {
          src_logger/* default.error */.Z.error(error);
          src_logger/* default.error */.Z.error(error.stack);
          CharacterImport.showCurrentTask(html, "Error updating character", error, true);
        }
      });

    $(html)
      .find("#delete-local-cobalt")
      .on("click", async () => {
        try {
          deleteLocalCobalt(this.actor.id);
          $(html).find("#delete-local-cobalt").prop("disabled", true);
        } catch (error) {
          src_logger/* default.error */.Z.error(error);
          src_logger/* default.error */.Z.error(error.stack);
          CharacterImport.showCurrentTask(html, "Error deleting local cookie", error, true);
        }
      });

    $(html)
      .find("#set-local-cobalt")
      .on("click", async () => {
        try {
          new DDBCookie({}, this.actor, true).render(true);
          $(html).find("#delete-local-cobalt").prop("disabled", false);
        } catch (error) {
          src_logger/* default.error */.Z.error(error);
          src_logger/* default.error */.Z.error(error.stack);
          CharacterImport.showCurrentTask(html, "Error updating character", error, true);
        }
      });

    $(html)
      .find("#dndbeyond-character-extras-start")
      .on("click", async () => {
        try {
          $(html).find("#dndbeyond-character-extras-start").prop("disabled", true);
          CharacterImport.showCurrentTask(html, "Fetching character data");
          const characterId = this.actor.data.flags.ddbimporter.dndbeyond.characterId;
          const characterData = await getCharacterData(characterId, null, this.actor.id);
          src_logger/* default.debug */.Z.debug("import.js getCharacterData result", characterData);
          const debugJson = game.settings.get("ddb-importer", "debug-json");
          if (debugJson) {
            (0,utils/* download */.LR)(JSON.stringify(characterData), `${characterId}.json`, "application/json");
          }
          if (characterData.success) {
            await (0,extras/* characterExtras */.d)(html, characterData, this.actor);
            CharacterImport.showCurrentTask(html, "Loading Extras", "Done.", false);
            $(html).find("#dndbeyond-character-extras-start").prop("disabled", true);
            this.close();
          } else {
            CharacterImport.showCurrentTask(html, characterData.message, null, true);
            return false;
          }
        } catch (error) {
          switch (error) {
            case "Forbidden":
              CharacterImport.showCurrentTask(html, "Error retrieving Character: " + error, error, true);
              break;
            default:
              src_logger/* default.error */.Z.error(error);
              src_logger/* default.error */.Z.error(error.stack);
              CharacterImport.showCurrentTask(html, "Error parsing Character: " + error, error, true);
              break;
          }
          return false;
        }
        return true;
      });

    $(html)
      .find("input[name=dndbeyond-url]")
      .on("input", async (event) => {
        let URL = event.target.value;
        const characterId = getCharacterId(URL);

        if (characterId) {
          const apiEndpointUrl = getCharacterAPIEndpoint(characterId);
          $(html)
            .find(".dndbeyond-url-status i")
            .replaceWith('<i class="fas fa-check-circle" style="color: green"></i>');
          $(html).find("span.dndbeyond-character-id").text(characterId);
          $(html).find("#dndbeyond-character-import-start").prop("disabled", false);
          $(html).find("#open-dndbeyond-url").prop("disabled", false);

          CharacterImport.showCurrentTask(html, "Saving reference");
          await this.actor.update({
            flags: {
              ddbimporter: {
                dndbeyond: {
                  url: URL,
                  apiEndpointUrl: apiEndpointUrl,
                  characterId: characterId,
                },
              },
            },
          });
          CharacterImport.showCurrentTask(html, "Status");
        } else {
          CharacterImport.showCurrentTask(
            html,
            "URL format incorrect",
            "That seems not to be the URL we expected...",
            true
          );
          $(html)
            .find(".dndbeyond-url-status i")
            .replaceWith('<i class="fas fa-exclamation-triangle" style="color:red"></i>');
        }
      });

    $(html)
      .find("#open-dndbeyond-url")
      .on("click", () => {
        try {
          const characterId = this.actor.data.flags.ddbimporter.dndbeyond.characterId;
          const apiEndpointUrl = getCharacterAPIEndpoint(characterId);
          import_renderPopup("json", apiEndpointUrl);
        } catch (error) {
          CharacterImport.showCurrentTask(html, "Error opening JSON URL", error, true);
        }
      });
  }

  async enrichCharacterItems(html, items) {
    const useInbuiltIcons = game.settings.get("ddb-importer", "character-update-policy-use-inbuilt-icons");
    const useSRDCompendiumItems = game.settings.get("ddb-importer", "character-update-policy-use-srd");
    const useSRDCompendiumIcons = game.settings.get("ddb-importer", "character-update-policy-use-srd-icons");
    const ddbSpellIcons = game.settings.get("ddb-importer", "character-update-policy-use-ddb-spell-icons");
    const ddbItemIcons = game.settings.get("ddb-importer", "character-update-policy-use-ddb-item-icons");
    const ddbGenericItemIcons = game.settings.get("ddb-importer", "character-update-policy-use-ddb-generic-item-icons");
    const activeEffectCopy = game.settings.get("ddb-importer", "character-update-policy-active-effect-copy");
    const daeEffectCopy = game.settings.get("ddb-importer", "character-update-policy-dae-effect-copy");
    const daeSRDInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("Dynamic-Effects-SRD");
    const daeMidiInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("midi-srd");
    const daeInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("dae");
    const addItemEffects = game.settings.get("ddb-importer", "character-update-policy-add-item-effects");
    const addItemACEffects = game.settings.get("ddb-importer", "character-update-policy-generate-ac-armor-effects");
    const addCharacterEffects = game.settings.get("ddb-importer", "character-update-policy-add-character-effects");

    // if we still have items to add, add them
    if (items.length > 0) {
      CharacterImport.showCurrentTask(html, "Copying existing data flags");
      await this.copySupportedCharacterItemFlags(items);

      if (ddbItemIcons) {
        CharacterImport.showCurrentTask(html, "Fetching DDB Inventory Images");
        items = await (0,muncher_import/* getDDBEquipmentIcons */.BO)(items, true);
      }

      if (useInbuiltIcons) {
        CharacterImport.showCurrentTask(html, "Adding SRD Icons");
        items = await (0,icons/* copyInbuiltIcons */.b)(items);
      }

      if (useSRDCompendiumIcons && !useSRDCompendiumItems) {
        CharacterImport.showCurrentTask(html, "Adding SRD Icons");
        items = await (0,muncher_import/* copySRDIcons */.u4)(items);
      }

      if (ddbSpellIcons) {
        CharacterImport.showCurrentTask(html, "Fetching DDB Spell School Images");
        items = await (0,muncher_import/* getDDBSpellSchoolIcons */.pV)(items, true);
      }

      if (ddbGenericItemIcons) {
        CharacterImport.showCurrentTask(html, "Fetching DDB Generic Item Images");
        items = await (0,muncher_import/* getDDBGenericItemIcons */.m$)(items, true);
      }

      if (activeEffectCopy) {
        CharacterImport.showCurrentTask(html, "Copying Item Active Effects");
        items = await this.copyCharacterItemEffects(items);
      }

      if (daeEffectCopy && daeInstalled && (daeSRDInstalled || daeMidiInstalled)) {
        CharacterImport.showCurrentTask(html, "Importing DAE Effects");
        items = await (0,dae/* addItemsDAESRD */.$n)(items);
      }

      if (daeInstalled && (addItemEffects || addItemACEffects || addCharacterEffects)) {
        items = (0,muncher_import/* addItemEffectIcons */.oU)(items);
      }
    }

    items = items.map((item) => {
      if (!item.effects) item.effects = [];
      return item;
    });

    return Promise.all(items);
  }

  async createCharacterItems(items, keepIds) {
    const options = JSON.parse(JSON.stringify(DISABLE_FOUNDRY_UPGRADE));
    if (keepIds) options["keepId"] = true;

    // we have to break these out into class and non-class because of
    // https://gitlab.com/foundrynet/foundryvtt/-/issues/5312
    const klassItems = items.filter((item) => item.type === "class");
    const nonKlassItems = items.filter((item) => item.type !== "class");

    src_logger/* default.debug */.Z.debug(`Adding the following class items, keep Ids? ${keepIds}`, JSON.parse(JSON.stringify(klassItems)));
    await this.actor.createEmbeddedDocuments("Item", klassItems, options);

    src_logger/* default.debug */.Z.debug(`Adding the following non-class items, keep Ids? ${keepIds}`, JSON.parse(JSON.stringify(nonKlassItems)));
    await this.actor.createEmbeddedDocuments("Item", nonKlassItems, options);
  }

  async importCharacterItems(html, items, keepIds = false) {
    if (items.length > 0) {
      CharacterImport.showCurrentTask(html, "Adding items to character");

      const newItems = items.filter((i) => !i._id || i._id === null || i._id === undefined);
      const updateItems = items.filter((i) => i._id && i._id !== null && i._id !== undefined);

      await this.createCharacterItems(newItems, false);
      await this.createCharacterItems(updateItems, keepIds);
    }
  }

  // returns items not updated
  async mergeExistingItems(html, items) {
    if (this.actorOriginal.flags.ddbimporter) {
      const ownedItems = this.actor.getEmbeddedCollection("Item");

      let nonMatchedItems = [];
      let matchedItems = [];

      await items.forEach((item) => {
        let matchedItem = ownedItems.find(
          (owned) =>
            item.name === owned.data.name &&
            item.type === owned.data.type &&
            item.flags?.ddbimporter?.id === owned.data.flags?.ddbimporter?.id
        );
        if (matchedItem) {
          if (!matchedItem.data.flags.ddbimporter?.ignoreItemImport) {
            item["_id"] = matchedItem["id"];
            if (matchedItem.data.flags.ddbimporter?.ignoreIcon) item.flags.ddbimporter.matchedImg = matchedItem.data.img;
            if (matchedItem.data.flags.ddbimporter?.retainResourceConsumption) item.data.consume = matchedItem.data.data.consume;

            matchedItems.push(item);
          }
        } else {
          nonMatchedItems.push(item);
        }
      });

      // enrich matched items
      let enrichedItems = await this.enrichCharacterItems(html, matchedItems);

      // ensure excluded icons are retained
      enrichedItems = enrichedItems.map((item) => {
        if (item.flags.ddbimporter?.matchedImg) item.img = item.flags.ddbimporter.matchedImg;
        return item;
      });

      src_logger/* default.debug */.Z.debug("Finished updating items");
      return nonMatchedItems.concat(enrichedItems);
    } else {
      return items;
    }
  }

  async processCharacterItems(html) {
    const magicItemsInstalled = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("magicitems");
    // items for actor
    let items = [];

    // process spells for magic items
    if (magicItemsInstalled && this.result.itemSpells && Array.isArray(this.result.itemSpells)) {
      CharacterImport.showCurrentTask(html, "Preparing magicitem spells");
      await (0,muncher_import/* addMagicItemSpells */.ah)(this.result);
    }

    src_logger/* default.debug */.Z.debug("Calculating items to create and update...");
    CharacterImport.showCurrentTask(html, "Calculating items to create and update...");
    items = filterItemsByUserSelection(this.result, FILTER_SECTIONS);

    src_logger/* default.debug */.Z.debug("Checking existing items for details...");
    CharacterImport.showCurrentTask(html, "Checking existing items for details...");

    items = await this.mergeExistingItems(html, items);

    src_logger/* default.debug */.Z.debug("Removing found items...");
    CharacterImport.showCurrentTask(html, "Clearing items for recreation...");
    await this.clearItemsByUserSelection();


    // If there is no magicitems module fall back to importing the magic
    // item spells as normal spells fo the character
    if (!magicItemsInstalled) {
      items.push(
        this.result.itemSpells.filter((item) => {
          const active = item.flags.ddbimporter.dndbeyond && item.flags.ddbimporter.dndbeyond.active === true;
          if (!active) src_logger/* default.warn */.Z.warn(`Missing active flag on item spell ${item.name}`);
          return active;
        })
      );
      items = items.flat();
    }

    let compendiumItems = [];
    let srdCompendiumItems = [];
    let overrideCompendiumItems = [];
    const useExistingCompendiumItems = game.settings.get("ddb-importer", "character-update-policy-use-existing");
    const useSRDCompendiumItems = game.settings.get("ddb-importer", "character-update-policy-use-srd");
    const useOverrideCompendiumItems = game.settings.get("ddb-importer", "character-update-policy-use-override");

    /**
     * First choice is override compendium
     */
    if (useOverrideCompendiumItems) {
      src_logger/* default.info */.Z.info("Removing matching Override compendium items");
      const compendiumOverrideItems = await (0,muncher_import/* getCompendiumItems */.pI)(items, "custom");
      overrideCompendiumItems = compendiumOverrideItems;
      // remove existing items from those to be imported
      items = await CharacterImport.removeItems(items, overrideCompendiumItems);
    }
    /**
     * If SRD is selected, we prefer this
     */
    if (useSRDCompendiumItems) {
      src_logger/* default.info */.Z.info("Removing compendium items");
      const compendiumFeatureItems = await (0,muncher_import/* getSRDCompendiumItems */.wW)(items, "features");
      const compendiumInventoryItems = await (0,muncher_import/* getSRDCompendiumItems */.wW)(items, "inventory");
      const compendiumSpellItems = await (0,muncher_import/* getSRDCompendiumItems */.wW)(items, "spells");

      srdCompendiumItems = compendiumItems.concat(
        compendiumInventoryItems,
        compendiumSpellItems,
        compendiumFeatureItems
      );
      // remove existing items from those to be imported
      items = await CharacterImport.removeItems(items, srdCompendiumItems);
    }

    if (useExistingCompendiumItems) {
      src_logger/* default.info */.Z.info("Removing compendium items");
      const compendiumFeatureItems = await (0,muncher_import/* getCompendiumItems */.pI)(items, "features");
      const compendiumInventoryItems = await (0,muncher_import/* getCompendiumItems */.pI)(items, "inventory");
      const compendiumSpellItems = await (0,muncher_import/* getCompendiumItems */.pI)(items, "spells");

      compendiumItems = compendiumItems.concat(compendiumInventoryItems, compendiumSpellItems, compendiumFeatureItems);
      // remove existing items from those to be imported
      items = await CharacterImport.removeItems(items, compendiumItems);
    }

    // import remaining items to character
    if (items.length > 0) {
      CharacterImport.showCurrentTask(html, "Adding DDB generated items");
      src_logger/* default.debug */.Z.debug(`Adding DDB generated items...`, items);
      items = await this.enrichCharacterItems(html, items);
      await this.importCharacterItems(html, items, true);
    }

    // now import any compendium items that we matched
    if (useExistingCompendiumItems) {
      CharacterImport.showCurrentTask(html, "Adding DDB compendium items");
      src_logger/* default.info */.Z.info("Adding DDB compendium items:", compendiumItems);
      await this.createCharacterItems(compendiumItems, false);
      // await this.actor.createEmbeddedDocuments("Item", compendiumItems, DISABLE_FOUNDRY_UPGRADE);
    }

    if (useSRDCompendiumItems) {
      CharacterImport.showCurrentTask(html, "Adding SRD compendium items");
      src_logger/* default.info */.Z.info("Adding SRD compendium items:", srdCompendiumItems);
      await this.createCharacterItems(srdCompendiumItems, false);
      // await this.actor.createEmbeddedDocuments("Item", srdCompendiumItems, DISABLE_FOUNDRY_UPGRADE);
    }

    if (useOverrideCompendiumItems) {
      CharacterImport.showCurrentTask(html, "Adding Override compendium items");
      src_logger/* default.info */.Z.info("Adding Override compendium items:", overrideCompendiumItems);
      await this.createCharacterItems(overrideCompendiumItems, false);
      // await this.actor.createEmbeddedDocuments("Item", overrideCompendiumItems, DISABLE_FOUNDRY_UPGRADE);
    }

    src_logger/* default.debug */.Z.debug("Finished importing items");
  }

  async removeActiveEffects(activeEffectCopy) {
    // remove current active effects
    const excludedItems = filterActorItemsByUserSelection(this.actorOriginal, true);
    const ignoredItemIds = this.actorOriginal.items
      .filter(
        (item) =>
          item.effects &&
          item.effects.length > 0 &&
          (item.flags.ddbimporter?.ignoreItemImport || excludedItems.some((ei) => ei._id === item._id))
      )
      .map((item) => item._id);

    const itemEffects = this.actor.effects.filter(
      (ae) => ae.data.origin?.includes(".Item.") && !ignoredItemIds.includes(ae.data.origin?.split(".").slice(-1)[0])
    );
    const ignoredEffects = this.actor.effects.filter(
      (ae) =>
        // is this an ignored item
        ignoredItemIds.includes(ae.data.origin?.split(".").slice(-1)[0]) ||
        // is this a core status effect (CUB)
        ae.data.flags?.core?.statusId
    );
    const charEffects = this.actor.effects.filter(
      (ae) => !ae.data.origin?.includes(".Item.") && !ae.data.flags.ddbimporter?.characterEffect
    );
    const ddbGeneratedCharEffects = this.actor.effects.filter(
      (ae) => !ae.data.origin?.includes(".Item.") && ae.data.flags.ddbimporter?.characterEffect
    );

    // console.warn(JSON.parse(JSON.stringify(this.actor)));
    // console.log(itemEffects.map((ae) => ae.id));

    // remove existing active item effects
    await this.actor.deleteEmbeddedDocuments(
      "ActiveEffect",
      itemEffects.map((ae) => ae.id)
    );
    // console.warn(JSON.parse(JSON.stringify(this.actor)));
    // console.log(ddbGeneratedCharEffects.map((ae) => ae.id));
    // clear down ddb generated character effects such as skill bonuses
    await this.actor.deleteEmbeddedDocuments(
      "ActiveEffect",
      ddbGeneratedCharEffects.map((ae) => ae.id)
    );

    if (game.settings.get("ddb-importer", "character-update-policy-generate-ac-override-effects")) {
      const acEffects = this.result.character.flags.ddbimporter.acEffects.map((ae) => {
        ae.origin = `Actor.${this.actor.id}`;
        return ae;
      });
      this.result.character.effects = this.result.character.effects.concat(acEffects);
    }

    const autoAC = src_utils/* default.versionCompare */.Z.versionCompare(game.data.system.data.version, "1.4.0") >= 0;
    if (!autoAC && game.settings.get("ddb-importer", "character-update-policy-generate-base-ac")) {
      // console.warn(this.result.character.data.attributes.ac);
      // console.warn(this.result.character.flags.ddbimporter.baseAC);
      this.result.character.data.attributes.ac.value = this.result.character.flags.ddbimporter.baseAC;
    }

    // are we trying to retain existing effects?
    if (activeEffectCopy) {
      // add retained character effects to result
      this.result.character.effects = this.result.character.effects.concat(charEffects, ignoredEffects);
    } else {
      // if not retaining effects remove character effects
      // console.warn(JSON.parse(JSON.stringify(this.actor)));
      // console.log(charEffects.map((ae) => ae.id));

      await this.actor.deleteEmbeddedDocuments(
        "ActiveEffect",
        charEffects.map((ae) => ae.id)
      );
      this.result.character.effects = this.result.character.effects.concat(ignoredEffects);
    }
    // console.warn(JSON.parse(JSON.stringify(this.actor)));

  }

  fixUpCharacterEffects(character) {
    let abilityOverrides = abilityOverrideEffects(character.flags.ddbimporter.dndbeyond.abilityOverrides);
    if (abilityOverrides.changes.length > 0) {
      character.effects = character.effects.concat(abilityOverrides);
    }

    character.effects.forEach((effect) => {
      const origins = [
        "Ability.Override",
        "AC",
        `Actor.${this.actor.data.flags.ddbimporter.dndbeyond.characterId}`,
      ];
      if (origins.includes(effect.origin)) {
        effect.origin = `Actor.${this.actor.id}`;
      }
    });
  }

  async parseCharacterData(html, data) {
    this.result = data.character;

    src_logger/* default.debug */.Z.debug("Current Actor:", this.actorOriginal);

    // console.warn(JSON.parse(JSON.stringify(this.actor)));
    // handle active effects
    const activeEffectCopy = game.settings.get("ddb-importer", "character-update-policy-active-effect-copy");
    CharacterImport.showCurrentTask(html, "Calculating Active Effect Changes");
    this.fixUpCharacterEffects(this.result.character);
    await this.removeActiveEffects(activeEffectCopy);

    // console.warn(JSON.parse(JSON.stringify(this.actor)));
    // console.warn(JSON.parse(JSON.stringify(this.result.character)));
    // console.warn(JSON.parse(JSON.stringify(this.result)));

    // update image
    await this.updateImage(html, data.ddb);

    // manage updates of basic character data more intelligently
    // revert some data if update not wanted
    if (!game.settings.get("ddb-importer", "character-update-policy-hp")) {
      this.result.character.data.attributes.hp = this.actorOriginal.data.attributes.hp;
    }
    if (!game.settings.get("ddb-importer", "character-update-policy-hit-die")) {
      this.result.character.data.attributes.hd = this.actorOriginal.data.attributes.hd;
      this.result.classes = this.result.classes.map((klass) => {
        const originalKlass = this.actorOriginal.items.find((original) => original.name === klass.name && original.type === "class");
        if (originalKlass) {
          klass.data.hitDiceUsed = originalKlass.data.hitDiceUsed;
        }
        return klass;
      });
      // this.actorOriginal.items
      //   .filter((i) => i.type === "class")
      //   .forEach((klass) => {
      //     const klassIndex = this.result.classes.findIndex((i) => i.name === klass.name);
      //     if (klassIndex) {
      //       this.result.classes[klassIndex].data.hitDiceUsed = klass.data.hitDiceUsed;
      //     }
      //   });
    }
    if (!game.settings.get("ddb-importer", "character-update-policy-currency")) {
      this.result.character.data.currency = this.actorOriginal.data.currency;
    }
    if (!game.settings.get("ddb-importer", "character-update-policy-bio")) {
      const bioUpdates = ["alignment", "appearance", "background", "biography", "bond", "flaw", "idea", "trait"];
      bioUpdates.forEach((option) => {
        this.result.character.data.details[option] = this.actorOriginal.data.details[option];
      });
    }

    // flag as having items ids
    this.result.character.flags.ddbimporter["syncItemReady"] = true;
    this.result.character.flags.ddbimporter["syncActionReady"] = true;
    // remove unneeded flags (used for character parsing)
    this.result.character.flags.ddbimporter.dndbeyond["templateStrings"] = null;
    this.result.character.flags.ddbimporter.dndbeyond["characterValues"] = null;
    this.result.character.flags.ddbimporter.dndbeyond["proficiencies"] = null;
    this.result.character.flags.ddbimporter.dndbeyond["proficienciesIncludingEffects"] = null;
    this.result.character.flags.ddbimporter.dndbeyond["effectAbilities"] = null;
    this.result.character.flags.ddbimporter.dndbeyond["abilityOverrides"] = null;

    // basic import
    CharacterImport.showCurrentTask(html, "Updating core character information");
    src_logger/* default.debug */.Z.debug("Character data importing: ", this.result.character);
    await this.actor.update(this.result.character);

    // console.warn(JSON.parse(JSON.stringify(this.actor)));
    // copy existing journal notes
    this.copyExistingJournalNotes();

    // items import
    await this.processCharacterItems(html);

    // console.warn(JSON.parse(JSON.stringify(this.actor)));

    // copy items whole from DAE
    const daeCopy = game.settings.get("ddb-importer", "character-update-policy-dae-copy");
    const daeInstalled =
      src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("dae") && (src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("Dynamic-Effects-SRD") || src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("midi-srd"));
    if (daeCopy && daeInstalled) {
      CharacterImport.showCurrentTask(html, "Importing DAE SRD");
      await (0,dae/* migrateActorDAESRD */.KS)(this.actor);
    }

    if (activeEffectCopy) {
      // find effects with a matching name that existed on previous actor
      // and that have a different active state and activate them
      const targetEffects = this.actor.data.effects.filter((ae) => {
        const previousEffectDiff = this.actorOriginal.effects.find(
          (oae) => oae.label === ae.label && oae.disabled !== ae.disabled
        );
        if (previousEffectDiff) return true;
        return false;
      });
      targetEffects.forEach((ae) => {
        this.actor.updateEmbeddedDocument("ActiveEffect", { _id: ae._id, disabled: !ae.disabled });
      });
    }

    // this.actor.prepareDerivedData();
    // this.actor.prepareEmbeddedEntities();
    // this.actor.applyActiveEffects();
    this.actor.render();
  }
}


async function importCharacterById(characterId, html) {
  try {
    if (!html) html = src_utils/* default.htmlToDoc */.Z.htmlToDoc("");
    let actor = await Actor.create({
      name: "New Actor",
      type: "character",
      flags: {
        ddbimporter: {
          dndbeyond: {
            characterId: characterId,
            url: `https://www.dndbeyond.com/characters/${characterId}`,
          }
        }
      }
    });

    const characterData = await getCharacterData(characterId, null, actor.id);
    const debugJson = game.settings.get("ddb-importer", "debug-json");
    if (debugJson) {
      (0,utils/* download */.LR)(JSON.stringify(characterData), `${characterId}.json`, "application/json");
    }
    if (characterData.success) {
      const importer = new CharacterImport(CharacterImport.defaultOptions, actor);
      await importer.parseCharacterData(html, characterData);
      return actor;
    } else {
      src_logger/* default.error */.Z.error("ERROR:", characterData.message);
      return undefined;
    }
  } catch (error) {
    switch (error) {
      case "Forbidden":
        src_logger/* default.error */.Z.error("Error retrieving Character: ", error);
        break;
      default:
        src_logger/* default.error */.Z.error("Error parsing Character: ", error);
        src_logger/* default.error */.Z.error(error.stack);
        break;
    }
    return undefined;
  }
}


async function importCharacter(actor, html) {
  try {
    if (!html) html = src_utils/* default.htmlToDoc */.Z.htmlToDoc("");
    const actorData = actor.toObject();
    const characterId = actorData.flags.ddbimporter.dndbeyond.characterId;
    const characterData = await getCharacterData(characterId, null, actorData._id);
    src_logger/* default.debug */.Z.debug("import.js importCharacter getCharacterData result", characterData);
    const debugJson = game.settings.get("ddb-importer", "debug-json");
    if (debugJson) {
      (0,utils/* download */.LR)(JSON.stringify(characterData), `${characterId}.json`, "application/json");
    }
    if (characterData.success) {
      // begin parsing the character data
      const importer = new CharacterImport(CharacterImport.defaultOptions, actorData);
      await importer.parseCharacterData(html, characterData);
      CharacterImport.showCurrentTask(html, "Loading Character data", "Done.", false);
      src_logger/* default.info */.Z.info("Loading Character data");
      return true;
    } else {
      src_logger/* default.error */.Z.error("Error Loading Character data", characterData.message);
      return false;
    }
  } catch (error) {
    switch (error) {
      case "Forbidden":
        src_logger/* default.error */.Z.error("Error retrieving Character: ", error);
        break;
      default:
        src_logger/* default.error */.Z.error("Error parsing Character: ", error);
        src_logger/* default.error */.Z.error(error.stack);
        break;
    }
    return false;
  }
}

;// CONCATENATED MODULE: ./src/muncher/encounters.js
// Main module class











const DIFFICULTY_LEVELS = [
  { id: null, name: "No challenge", color: "grey" },
  { id: 1, name: "Easy", color: "green" },
  { id: 2, name: "Medium", color: "brown" },
  { id: 3, name: "Hard", color: "orange" },
  { id: 4, name: "Deadly", color: "red" },
];

const SCENE_IMG = [
  { name: "Bar", img: "modules/ddb-importer/img/encounters/bar.webp" },
  { name: "Cobbles", img: "modules/ddb-importer/img/encounters/cobbles.webp" },
  { name: "Dungeon", img: "modules/ddb-importer/img/encounters/dungeon.png" },
  { name: "Grass", img: "modules/ddb-importer/img/encounters/grass.webp" },
  { name: "Snow", img: "modules/ddb-importer/img/encounters/snow.webp" },
  { name: "Stone", img: "modules/ddb-importer/img/encounters/stone.webp" },
  { name: "Void", img: "modules/ddb-importer/img/encounters/void.webp" },
];

async function getEncounterData() {
  const cobaltCookie = getCobalt();
  const betaKey = game.settings.get("ddb-importer", "beta-key");
  const parsingApi = game.settings.get("ddb-importer", "api-endpoint");
  const debugJson = game.settings.get("ddb-importer", "debug-json");

  const body = {
    cobalt: cobaltCookie,
    betaKey: betaKey,
  };

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/encounters`, {
      method: "POST",
      mode: "cors",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (!data.success) {
          (0,utils/* munchNote */.ep)(`API Failure: ${data.message}`);
          reject(data.message);
        }
        if (debugJson) {
          (0,utils/* download */.LR)(JSON.stringify(data), `encounters-raw.json`, "application/json");
        }
        return data;
      })
      .then((data) => {
        (0,utils/* munchNote */.ep)(`Retrieved ${data.data.length} encounters, starting parse...`, true, false);
        src_logger/* default.info */.Z.info(`Retrieved ${data.data.length} encounters`);
        resolve(data.data);
      })
      .catch((error) => reject(error));
  });
}

async function parseEncounters() {
  const encounters = await getEncounterData();
  src_logger/* default.debug */.Z.debug("Fetched encounters", encounters);
  (0,utils/* munchNote */.ep)(`Fetched Available DDB Encounters`);
  CONFIG.DDBI.ENCOUNTERS = encounters;
  (0,utils/* munchNote */.ep)("");
  return CONFIG.DDBI.ENCOUNTERS;
}

async function filterEncounters(campaignId) {
  const campaigns = await getAvailableCampaigns();
  const campaignIds = campaigns.map((c) => c.id);
  const allEncounters = CONFIG.DDBI.ENCOUNTERS ? CONFIG.DDBI.ENCOUNTERS : await parseEncounters();

  src_logger/* default.debug */.Z.debug(`${allEncounters.length} encounters`, allEncounters);
  src_logger/* default.debug */.Z.debug("CampaignIds", campaignIds);
  if (!campaignId || campaignId === "" || !campaignIds.includes(parseInt(campaignId))) return allEncounters;
  src_logger/* default.debug */.Z.debug(`CampaignId to find ${campaignId}`);
  const filteredEncounters = allEncounters.filter((encounter) => encounter.campaign.id == campaignId);
  src_logger/* default.debug */.Z.debug(`${filteredEncounters.length} filtered encounters`, filteredEncounters);
  return filteredEncounters;
}

class DDBEncounterMunch extends Application {
  constructor(options = {}) {
    super(options);
    this.encounter = {};
    this.img = "";
    this.journal = undefined;
    this.combat = undefined;
    this.tokens = [];
  }

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.baseApplication = "DDBEncounterMuncher";
    options.id = "ddb-importer-encounters";
    options.template = "modules/ddb-importer/handlebars/encounters.hbs";
    options.resizable = false;
    options.height = "auto";
    options.width = 800;
    options.title = "MrPrimate's DDB Encounter Muncher";
    options.classes = ["ddb-muncher", "sheet"];
    options.tabs = [{ navSelector: ".tabs", contentSelector: "div", initial: "settings" }];
    return options;
  }

  async parseEncounter(id) {
    src_logger/* default.debug */.Z.debug(`Looking for Encounter "${id}"`);
    if (!CONFIG.DDBI.ENCOUNTERS) return this.encounter;
    const monsterPack = await (0,importMonster/* checkMonsterCompendium */.eX)();

    await monsterPack.getIndex({ fields: ["name", "flags.ddbimporter.id"] });

    // console.warn(CONFIG.DDBI.ENCOUNTERS);
    const encounter = CONFIG.DDBI.ENCOUNTERS.find((e) => e.id == id.trim());
    // console.warn(encounter);

    // if (!encounter) return this.encounter;

    let goodMonsterIds = [];
    let missingMonsterIds = [];
    src_logger/* default.debug */.Z.debug("Parsing encounter", encounter);
    encounter.monsters.forEach((monster) => {
      const id = monster.id;
      const monsterInPack = monsterPack.index.find((f) => f.flags?.ddbimporter?.id == id);
      if (monsterInPack) {
        goodMonsterIds.push({ ddbId: id, name: monsterInPack.name, id: monsterInPack._id, quantity: monster.quantity });
      } else {
        missingMonsterIds.push({ ddbId: id, quantity: monster.quantity });
      }
    });

    let goodCharacterData = [];
    let missingCharacterData = [];
    encounter.players
      .filter((character) => !character.hidden)
      .forEach((character) => {
        const characterInGame = game.actors.find(
          (actor) =>
            actor.data.flags?.ddbimporter?.dndbeyond?.characterId &&
            actor.data.flags.ddbimporter.dndbeyond.characterId == character.id
        );
        if (characterInGame) {
          goodCharacterData.push({ id: characterInGame.id, name: characterInGame.name, ddbId: character.id });
        } else {
          missingCharacterData.push({ ddbId: character.id, name: character.name });
        }
      });

    const difficulty = DIFFICULTY_LEVELS.find((level) => level.id == encounter.difficulty);

    this.encounter = {
      id,
      name: encounter.name,
      inProgress: encounter.inProgress,
      turnNum: encounter.turnNum,
      roundNum: encounter.roundNum,
      difficulty,
      description: encounter.description,
      rewards: encounter.rewards,
      summary: encounter.flavorText,
      campaign: encounter.campaign,
      monsters: encounter.monsters,
      characters: encounter.players,
      goodMonsterIds,
      missingMonsterIds,
      goodCharacterData,
      missingCharacterData,
      missingMonsters: missingMonsterIds.length !== 0,
      missingCharacters: missingCharacterData.length !== 0,
    };

    src_logger/* default.debug */.Z.debug("Current encounter", this.encounter);

    return this.encounter;
  }

  resetEncounter(html) {
    const nameHtml = html.find("#ddb-encounter-name");
    const summaryHtml = html.find("#ddb-encounter-summary");
    const charactersHtml = html.find("#ddb-encounter-characters");
    const monstersHtml = html.find("#ddb-encounter-monsters");
    const difficultyHtml = html.find("#ddb-encounter-difficulty");
    const rewardsHtml = html.find("#ddb-encounter-rewards");
    const progressHtml = html.find("#ddb-encounter-progress");

    nameHtml[0].innerHTML = `<p id="ddb-encounter-name"><i class='fas fa-question'></i> <b>Encounter:</b></p>`;
    summaryHtml[0].innerHTML = `<p id="ddb-encounter-summary"><i class='fas fa-question'></i> <b>Summary:</b></p>`;
    charactersHtml[0].innerHTML = `<p id="ddb-encounter-characters"><i class='fas fa-question'></i> <b>Characters:</b></p>`;
    monstersHtml[0].innerHTML = `<p id="ddb-encounter-monsters"><i class='fas fa-question'></i> <b>Monsters:</b></p>`;
    difficultyHtml[0].innerHTML = `<p id="ddb-encounter-difficulty"><i class='fas fa-question'></i> <b>Difficulty:</b></p>`;
    rewardsHtml[0].innerHTML = `<p id="ddb-encounter-rewards"><i class='fas fa-question'></i> <b>Rewards:</b></p>`;
    progressHtml[0].innerHTML = `<p id="ddb-encounter-progress"><i class='fas fa-question'></i> <b>In Progress:</b></p>`;

    $("#ddb-importer-encounters").css("height", "auto");
    $("#encounter-button").prop("disabled", true);
    $("#encounter-button").prop("innerText", "Import Encounter");
    $("#encounter-import-policy-use-ddb-save").prop("disabled", true);
    this.encounter = {};
    this.journal = undefined;
    this.combat = undefined;
    this.tokens = [];
  }

  async importMonsters() {
    const importMonsters = game.settings.get("ddb-importer", "encounter-import-policy-missing-monsters");

    if (importMonsters && this.encounter.missingMonsters && this.encounter.missingMonsterIds.length > 0) {
      src_logger/* default.debug */.Z.debug("Importing missing monsters from DDB");
      await parseCritters(this.encounter.missingMonsterIds.map((monster) => monster.ddbId));
      src_logger/* default.debug */.Z.debug("Finised Importing missing monsters from DDB");
    }

    const monsterPack = await (0,importMonster/* checkMonsterCompendium */.eX)();
    await monsterPack.getIndex({ fields: ["name", "flags.ddbimporter.id"] });
    const compendiumName = await game.settings.get("ddb-importer", "entity-monster-compendium");

    let monstersToAddToWorld = [];
    this.encounter.monsterData = [];
    this.encounter.worldMonsters = [];
    let journalMonsterInfo = new Map();
    this.encounter.monsters.forEach((monster) => {
      const id = monster.id;
      const monsterInPack = monsterPack.index.find((f) => f.flags?.ddbimporter?.id == id);
      if (monsterInPack) {
        let monsterData = {
          ddbId: id,
          name: monsterInPack.name,
          id: monsterInPack._id,
          quantity: monster.quantity,
          journalLink: `@Compendium[${compendiumName}.${monsterInPack.name}]{${monsterInPack.name}}`,
        };
        if (journalMonsterInfo.has(monsterData.ddbId)) {
          monsterData = journalMonsterInfo.get(monsterData.ddbId);
          monsterData.quantity += monster.quantity;
        }
        journalMonsterInfo.set(monsterData.ddbId, monsterData);

        for (let i = 0; i < monster.quantity; i++) {
          let addData = deepClone(monsterData);
          addData.quantity = 1;
          addData.uniqueId = monster.uniqueId;
          addData.initiative = monster.initiative;
          addData.currentHitPoints = monster.currentHitPoints;
          addData.maximumHitPoints = monster.maximumHitPoints;
          addData.temporaryHitPoints = monster.temporaryHitPoints;
          addData.ddbName = monster.name ? monster.name : monsterInPack.name;
          monstersToAddToWorld.push(addData);
        }
      }
    });
    this.encounter.monsterData = Object.values(journalMonsterInfo);

    const encounterMonsterFolder = await src_utils/* default.getFolder */.Z.getFolder(
      "npc",
      this.encounter.name,
      "D&D Beyond Encounters",
      "#6f0006",
      "#98020a",
      false
    );

    src_logger/* default.debug */.Z.debug("Trying to import monsters from compendium", monstersToAddToWorld);
    await Helpers.asyncForEach(monstersToAddToWorld, async (actor) => {
      let worldActor = game.actors.find(
        (a) => a.data.folder == encounterMonsterFolder.id && a.data.flags?.ddbimporter?.id == actor.ddbId
      );
      if (!worldActor) {
        src_logger/* default.info */.Z.info(
          `Importing monster ${actor.name} with DDB ID ${actor.ddbId} from ${monsterPack.metadata.name} with id ${actor.id}`
        );
        try {
          worldActor = await game.actors.importFromCompendium(monsterPack, actor.id, {
            folder: encounterMonsterFolder.id,
          });
        } catch (err) {
          src_logger/* default.error */.Z.error(err);
          src_logger/* default.warn */.Z.warn(`Unable to import actor ${actor.name} with id ${actor.id} from DDB Compendium`);
          src_logger/* default.debug */.Z.debug(
            `Failed on: game.actors.importFromCompendium(monsterCompendium, "${actor.id}", { folder: "${encounterMonsterFolder.id}" });`
          );
        }
      }
      this.encounter.worldMonsters.push(mergeObject(actor, { id: worldActor.id }));
    });

    return new Promise((resolve) => {
      resolve(this.encounter.worldMonsters);
    });
  }

  async importCharacters(html) {
    const importCharacters = game.settings.get("ddb-importer", "encounter-import-policy-missing-characters");
    if (importCharacters && this.encounter.missingCharacters) {
      await Helpers.asyncForEach(this.encounter.missingCharacterData, async (character) => {
        await importCharacterById(character.ddbId, html);
      });
    }
  }

  async createJournalEntry() {
    src_logger/* default.debug */.Z.debug(`Creating journal entry`);
    const journal = {
      name: this.encounter.name,
      flags: {
        ddbimporter: {
          encounterId: this.encounter.id,
        },
      },
    };

    const importJournal = game.settings.get("ddb-importer", "encounter-import-policy-create-journal");
    if (importJournal) {
      const journalFolder = await src_utils/* default.getFolder */.Z.getFolder(
        "journal",
        this.encounter.name,
        "D&D Beyond Encounters",
        "#6f0006",
        "#98020a",
        false
      );
      journal.folder = journalFolder.id;
      journal.content = `<h1>${this.encounter.name}</h1>`;
      if (this.encounter.summary && this.encounter.summary != "") {
        journal.content += `<h2>Summary</h2>${this.encounter.summary}`;
      }
      if (this.encounter.monsterData && this.encounter.monsterData.length > 0) {
        journal.content += `<h2>Monsters</h2><ul>`;
        this.encounter.monsterData.forEach((monster) => {
          journal.content += `<li><p>${monster.journalLink} x${monster.quantity}</p></li>`;
        });
        journal.content += `</ul>`;
      }
      if (this.encounter.difficulty && this.encounter.difficulty != "") {
        journal.content += `<h2>Difficulty: <span style="color: ${this.encounter.difficulty.color}">${this.encounter.difficulty.name}</span></h3>`;
      }
      if (this.encounter.description && this.encounter.description != "") {
        journal.content += `<h2>Description</h2>${this.encounter.description}`;
      }
      if (this.encounter.rewards && this.encounter.rewards != "") {
        journal.content += `<h2>Rewards</h2>${this.encounter.rewards}`;
      }

      let worldJournal = game.journal.find(
        (a) => a.data.folder == journalFolder.id && a.data.flags?.ddbimporter?.encounterId == this.encounter.id
      );
      if (!worldJournal) {
        src_logger/* default.info */.Z.info(`Importing journal ${journal.name}`);
        try {
          worldJournal = await JournalEntry.create(journal);
        } catch (err) {
          src_logger/* default.error */.Z.error(err);
          src_logger/* default.warn */.Z.warn(`Unable to create journal ${journal.name}`);
        }
      } else {
        src_logger/* default.info */.Z.info(`Updating journal ${journal.name}`);
        journal._id = worldJournal.id;
        await worldJournal.update(journal);
      }
      this.journal = worldJournal;
    }

    return new Promise((resolve) => {
      resolve(journal);
    });
  }

  async createScene() {
    let sceneData = {
      name: this.encounter.name,
      flags: {
        ddbimporter: {
          encounterId: this.encounter.id,
        },
      },
      width: 1000,
      height: 1000,
      grid: 100,
      padding: 0.25,
      initial: {
        x: 500,
        y: 500,
        scale: 0.57,
      },
      img: this.img,
      tokenVision: false,
      fogExploration: false,
    };

    const importScene = game.settings.get("ddb-importer", "encounter-import-policy-create-scene");
    if (importScene) {
      let tokenData = [];
      src_logger/* default.debug */.Z.debug(`Creating scene for encounter ${this.encounter.name}`);
      const useDDBSave =
        this.encounter.inProgress && game.settings.get("ddb-importer", "encounter-import-policy-use-ddb-save");
      const xSquares = sceneData.width / sceneData.grid;
      const ySquares = sceneData.height / sceneData.grid;
      const midSquareOffset = sceneData.grid / 2;
      const widthPaddingOffset = sceneData.width * sceneData.padding;
      const heightPaddingOffset = sceneData.height * sceneData.padding;
      const xPCOffset = sceneData.grid * (xSquares - 1);
      const xStartPixelMonster = widthPaddingOffset + midSquareOffset;
      const xStartPixelPC = xStartPixelMonster + xPCOffset;
      const yStartPixel = heightPaddingOffset + midSquareOffset;
      let characterCount = 0;
      this.encounter.characters
        .filter((character) => !character.hidden)
        .forEach(async (character) => {
          src_logger/* default.info */.Z.info(`Generating token ${character.name} for ${this.encounter.name}`);
          const characterInGame = game.actors.find(
            (actor) =>
              actor.data.flags?.ddbimporter?.dndbeyond?.characterId &&
              actor.data.flags.ddbimporter.dndbeyond.characterId == character.id
          );
          if (characterInGame) {
            const linkedToken = JSON.parse(JSON.stringify(await characterInGame.getTokenData()));
            if (useDDBSave) {
              setProperty(linkedToken, "flags.ddbimporter.dndbeyond.initiative", character.initiative);
            }
            linkedToken.x = xStartPixelPC;
            const yOffsetChange = characterCount * sceneData.grid;
            linkedToken.y = yStartPixel + yOffsetChange;
            tokenData.push(linkedToken);
            characterCount++;
          }
        });

      let monsterDepth = 0;
      let monsterRows = 0;
      let rowMonsterWidth = 1;
      this.encounter.worldMonsters.forEach(async (worldMonster) => {
        src_logger/* default.info */.Z.info(`Generating token ${worldMonster.ddbName} (${worldMonster.name}) for ${this.encounter.name}`);
        const monster = game.actors.get(worldMonster.id);
        const linkedToken = JSON.parse(JSON.stringify(await monster.getTokenData()));
        if (monsterDepth + linkedToken.height > ySquares) {
          monsterDepth = 0;
          monsterRows += rowMonsterWidth;
          rowMonsterWidth = 1;
        }

        setProperty(linkedToken, "name", worldMonster.ddbName);
        setProperty(linkedToken, "actorData.name", worldMonster.ddbName);
        setProperty(linkedToken, "flags.ddbimporter.dndbeyond.uniqueId", worldMonster.uniqueId);
        setProperty(linkedToken, "actorData.flags.ddbimporter.dndbeyond.uniqueId", worldMonster.uniqueId);
        const xOffsetChange = sceneData.grid * monsterRows;
        const yOffsetChange = monsterDepth * sceneData.grid;
        linkedToken.x = xStartPixelMonster + xOffsetChange;
        linkedToken.y = yStartPixel + yOffsetChange;
        if (useDDBSave) {
          setProperty(linkedToken, "flags.ddbimporter.dndbeyond.initiative", worldMonster.initiative);
          // if no hp changes have been made on a monster on ddb it says 0 here
          if (worldMonster.maximumHitPoints !== 0) {
            setProperty(linkedToken, "actorData.data.attributes.hp.max", worldMonster.maximumHitPoints);
            setProperty(
              linkedToken,
              "actorData.data.attributes.hp.value",
              worldMonster.currentHitPoints + worldMonster.temporaryHitPoints
            );
          }
        }

        tokenData.push(linkedToken);
        monsterDepth += linkedToken.height;
        if (linkedToken.width > rowMonsterWidth) rowMonsterWidth = linkedToken.width;
      });

      if (this.journal?.id) sceneData.journal = this.journal.id;

      const sceneFolder = await src_utils/* default.getFolder */.Z.getFolder(
        "scene",
        this.encounter.name,
        "D&D Beyond Encounters",
        "#6f0006",
        "#98020a",
        false
      );
      // eslint-disable-next-line require-atomic-updates
      sceneData.folder = sceneFolder.id;

      let worldScene = game.scenes.find(
        (a) => a.data.folder == sceneFolder.id && a.data.flags?.ddbimporter?.encounterId == this.encounter.id
      );
      if (!worldScene) {
        src_logger/* default.info */.Z.info(`Importing scene ${sceneData.name}`);
        try {
          // eslint-disable-next-line require-atomic-updates
          worldScene = await Scene.create(sceneData);
        } catch (err) {
          src_logger/* default.error */.Z.error(err);
          src_logger/* default.warn */.Z.warn(`Unable to create scene ${sceneData.name}`);
        }
      } else {
        src_logger/* default.info */.Z.info(`Updating scene ${sceneData.name}`);
        sceneData._id = worldScene.id;
        await Combat.deleteDocuments(game.combats.filter((c) => c.scene.id == worldScene.id).map((c) => c.id));
        await worldScene.deleteEmbeddedDocuments("Token", [], { deleteAll: true });
        await Scene.update(mergeObject(worldScene.data.toObject(), sceneData));
      }

      const thumbData = await worldScene.createThumbnail();
      const thumbScene = worldScene.data.toObject();
      thumbScene["thumb"] = thumbData.thumb;

      // eslint-disable-next-line require-atomic-updates
      worldScene = await worldScene.update(thumbScene, { keepId: true });

      await worldScene.createEmbeddedDocuments("Token", tokenData);

      this.scene = worldScene;
    }

    return new Promise((resolve) => {
      resolve(this.scene);
    });
  }

  async createCombatEncounter() {
    const importCombat = game.settings.get("ddb-importer", "encounter-import-policy-create-scene");

    if (!importCombat) return undefined;
    src_logger/* default.debug */.Z.debug(`Creating combat for encounter ${this.encounter.name}`);

    const useDDBSave =
      this.encounter.inProgress && game.settings.get("ddb-importer", "encounter-import-policy-use-ddb-save");

    await this.scene.view();
    this.combat = await Combat.create({ scene: this.scene.id });
    await this.combat.activate();

    let toCreate = [];
    const tokens = canvas.tokens.placeables;
    if (tokens.length) {
      tokens.forEach((t) => {
        let combatant = { tokenId: t.id, actorId: t.data.actorId, hidden: t.data.hidden };
        if (useDDBSave && t.data.flags.ddbimporter?.dndbeyond?.initiative)
          combatant.initiative = t.data.flags.ddbimporter.dndbeyond.initiative;
        if (!t.inCombat) toCreate.push(combatant);
      });
      const combatants = await this.combat.createEmbeddedDocuments("Combatant", toCreate);

      const rollMonsterInitiative = game.settings.get(
        "ddb-importer",
        "encounter-import-policy-roll-monster-initiative"
      );
      combatants
        .filter((c) => rollMonsterInitiative && c.actor.type === "npc" && c.initiative === null)
        .forEach(async (c) => {
          if (c.initiative === null) await this.combat.rollInitiative(c.id);
        });
    }

    return this.combat;
  }

  activateListeners(html) {
    super.activateListeners(html);

    $(html)
      .find(
        ['.munching-generic-config input[type="checkbox"]', '.munching-monster-config input[type="checkbox"]'].join(",")
      )
      .on("change", (event) => {
        updateMuncherSettings(html, event);
      });

    $(html)
      .find(
        [
          '.import-policy input[type="checkbox"]',
          '.advanced-import-config input[type="checkbox"]',
          '.effect-policy input[type="checkbox"]',
          '.effect-import-config input[type="checkbox"]',
          '.extras-import-config input[type="checkbox"]',
          '.import-config input[type="checkbox"]',
        ].join(",")
      )
      .on("change", (event) => {
        updateActorSettings(html, event);
      });

    $(html)
      .find("#default-effects")
      .on("click", async (event) => {
        event.preventDefault();
        setRecommendedCharacterActiveEffectSettings(html);
      });

    $(html)
      .find('.sync-policy input[type="checkbox"]')
      .on("change", (event) => {
        game.settings.set(
          "ddb-importer",
          "sync-policy-" + event.currentTarget.dataset.section,
          event.currentTarget.checked
        );
      });

    $(html)
      .find('.encounter-config input[type="checkbox"]')
      .on("change", (event) => {
        game.settings.set(
          "ddb-importer",
          "encounter-import-policy-" + event.currentTarget.dataset.section,
          event.currentTarget.checked
        );
      });

    // img change
    html.find("#encounter-scene-img-select").on("change", async () => {
      const imgSelect = html.find("#encounter-scene-img-select");
      this.img = imgSelect[0].selectedOptions[0] ? imgSelect[0].selectedOptions[0].value : "";
    });

    // filter campaigns
    html.find("#encounter-campaign-select").on("change", async () => {
      const campaignSelection = html.find("#encounter-campaign-select");
      // get selected campaign from html selection
      const campaignId = campaignSelection[0].selectedOptions[0]
        ? campaignSelection[0].selectedOptions[0].value
        : undefined;
      const encounters = await filterEncounters(campaignId);
      const campaignSelected = campaignId && campaignId !== "";
      let encounterList = `<option value="">Select encounter:</option>`;
      encounters.forEach((encounter) => {
        encounterList += `<option value="${encounter.id}">${encounter.name}${
          campaignSelected ? "" : ` (${encounter.campaign.name})`
        }</option>\n`;
      });
      const list = html.find("#encounter-select");
      list[0].innerHTML = encounterList;
      this.resetEncounter(html);
    });

    // encounter change
    html.find("#encounter-select").on("change", async () => {
      this.resetEncounter(html);
      const encounterSelection = html.find("#encounter-select");
      const encounterId = encounterSelection[0].selectedOptions[0]
        ? encounterSelection[0].selectedOptions[0].value
        : undefined;

      const encounter = await this.parseEncounter(encounterId);
      // console.warn(encounter);

      const nameHtml = html.find("#ddb-encounter-name");
      const summaryHtml = html.find("#ddb-encounter-summary");
      const charactersHtml = html.find("#ddb-encounter-characters");
      const monstersHtml = html.find("#ddb-encounter-monsters");
      const difficultyHtml = html.find("#ddb-encounter-difficulty");
      const rewardsHtml = html.find("#ddb-encounter-rewards");
      const progressHtml = html.find("#ddb-encounter-progress");

      const missingCharacters = encounter.missingCharacters
        ? `fa-times-circle' style='color: red`
        : `fa-check-circle' style='color: green`;
      const missingMonsters = encounter.missingMonsters
        ? `fa-times-circle' style='color: red`
        : `fa-check-circle' style='color: green`;

      const goodCharacters = encounter.goodCharacterData.map((character) => `${character.name}`).join(", ");
      const goodMonsters = encounter.goodMonsterIds.map((monster) => `${monster.name}`).join(", ");
      const neededCharactersHTML = encounter.missingCharacters
        ? ` <span style="color: red"> Missing ${
            encounter.missingCharacterData.length
          }: ${encounter.missingCharacterData.map((character) => character.name).join(", ")}</span>`
        : "";
      const neededMonstersHTML = encounter.missingMonsters
        ? ` <span style="color: red"> Missing ${
            encounter.missingMonsterIds.length
          }. DDB Id's: ${encounter.missingMonsterIds.map((monster) => monster.ddbId).join(", ")}</span>`
        : "";

      nameHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Encounter:</b> ${encounter.name}`;
      if (encounter.summary && encounter.summary.trim() !== "") {
        summaryHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Summary:</b> ${encounter.summary}`;
      }
      if (encounter.goodCharacterData.length > 0 || encounter.missingCharacterData.length > 0) {
        charactersHtml[0].innerHTML = `<i class='fas ${missingCharacters}'></i> <b>Characters:</b> ${goodCharacters}${neededCharactersHTML}`;
      }
      if (encounter.goodMonsterIds.length > 0 || encounter.missingMonsterIds.length > 0) {
        monstersHtml[0].innerHTML = `<i class='fas ${missingMonsters}'></i> <b>Monsters:</b> ${goodMonsters}${neededMonstersHTML}`;
      }
      difficultyHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Difficulty:</b> <span style="color: ${encounter.difficulty.color}">${encounter.difficulty.name}</span>`;
      if (encounter.rewards && encounter.rewards.trim() !== "") {
        rewardsHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Rewards:</b> ${encounter.rewards}`;
      }

      progressHtml[0].innerHTML = encounter.inProgress
        ? `<i class='fas fa-times-circle' style='color: red'></i> <b>In Progress:</b> <span style="color: red"> Encounter in progress on <a href="https://www.dndbeyond.com/combat-tracker/${this.encounter.id}">D&D Beyond!</a></span>`
        : `<i class='fas fa-check-circle' style='color: green'></i> <b>In Progress:</b> No`;

      $("#encounter-import-policy-use-ddb-save").prop("disabled", !encounter.inProgress);
      $("#ddb-importer-encounters").css("height", "auto");
      $("#encounter-button").prop("disabled", false);
    });

    // import encounter
    html.find("#encounter-button").click(async (event) => {
      event.preventDefault();
      $("#encounter-button").prop("disabled", true);
      $("#encounter-button").prop("innerText", "Munching...");

      await this.importMonsters();
      await this.importCharacters(html);
      await this.createJournalEntry();
      await this.createScene();
      await this.createCombatEncounter();

      // to do:
      // adjust monsters hp?
      // add initiative if combat in progress?
      // - extra import?
      // - attempt to find magic items and add them to the world?

      $("#encounter-button").prop("innerText", "Encounter Munched");
      const campaignFluff =
        this.encounter.campaign?.name && this.encounter.campaign.name.trim() !== "" ? ` of ${this.encounter.name}` : "";
      ui.notifications.warn(`Prepare to battle heroes${campaignFluff}, your doom awaits in ${this.encounter.name}!`);
    });
  }

  // eslint-disable-next-line class-methods-use-this
  async getData() {
    const tier = game.settings.get("ddb-importer", "patreon-tier");
    const tiers = (0,utils/* getPatreonTiers */.A1)(tier);
    const availableCampaigns = await getAvailableCampaigns();
    const availableEncounters = await filterEncounters();

    const characterSettings = getCharacterImportSettings();
    const muncherSettings = getMuncherSettings(false);

    const importSettings = mergeObject(characterSettings, muncherSettings);

    const encounterConfig = [
      {
        name: "missing-characters",
        isChecked: game.settings.get("ddb-importer", "encounter-import-policy-missing-characters"),
        enabled: true,
        description: "Import missing characters?",
      },
      {
        name: "missing-monsters",
        isChecked: game.settings.get("ddb-importer", "encounter-import-policy-missing-monsters"),
        enabled: true,
        description: "Import missing monsters?",
      },
      {
        name: "create-journal",
        isChecked: game.settings.get("ddb-importer", "encounter-import-policy-create-journal"),
        enabled: true,
        description: "Create encounter journal entry?",
      },
      {
        name: "use-ddb-save",
        isChecked: game.settings.get("ddb-importer", "encounter-import-policy-use-ddb-save"),
        enabled: false,
        description: "Use save information from Encounter (HP for monsters and initiative for all)?",
      },
      {
        name: "create-scene",
        isChecked: game.settings.get("ddb-importer", "encounter-import-policy-create-scene"),
        enabled: true,
        description: "Create/update a scene to use, and add available characters and NPC's?",
      },
    ];

    const encounterSettings = {
      tiers,
      availableCampaigns,
      availableEncounters,
      encounterConfig,
      sceneImg: SCENE_IMG,
    };

    const data = mergeObject(importSettings, encounterSettings);
    src_logger/* default.debug */.Z.debug("Encounter muncher form data", data);

    return data;
  }
}

;// CONCATENATED MODULE: ./src/hooks/init/window.js
// for exports












function resetSecrets() {
  game.settings.set("ddb-importer", "cobalt-cookie-local", false);
  game.settings.set("ddb-importer", "cobalt-cookie", "");
  game.settings.set("ddb-importer", "campaign-id", "");
}

function resetProxy() {
  game.settings.set("ddb-importer", "api-endpoint", "https://proxy.ddb.mrprimate.co.uk");
  game.settings.set("ddb-importer", "custom-proxy", false);
}

// eslint-disable-next-line no-unused-vars
function migrateAllCompendiums(value, key, map) {
  if (!value.locked) game.dnd5e.migrations.migrateCompendium(value);
  game.dnd5e.migrations.migrateCompendium(value);
}

function migrateCompendiums() {
  game.packs.forEach(migrateAllCompendiums);
}

function registerWindow() {
  window.DDBImporter = {
    parseCritters: parseCritters,
    parseMonsters: monster/* parseMonsters */.U,
    parseSpells: parseSpells,
    parseItems: parseItems,
    parseEncounters: parseEncounters,
    generateAdventureConfig: generateAdventureConfig,
    migrateCompendiums,
    resetProxy,
    resetSecrets,
    updateDDBCharacter: updateDDBCharacter,
    getPatreonTier: utils/* getPatreonTier */.X,
    getPatreonTiers: utils/* getPatreonTiers */.A1,
    setPatreonTier: utils/* setPatreonTier */.Q1,
    checkPatreon: utils/* checkPatreon */.$j,
    checkCobalt: checkCobalt,
    DDBEncounterMunch: DDBEncounterMunch,
    migrateExistingCompendiumToCompendiumFolders: compendiumFolders/* migrateExistingCompendium */.W3,
    createCompendiumFolderStructure: compendiumFolders/* createCompendiumFolderStructure */.FT,
    importCharacter: importCharacter,
    importCharacterById: importCharacterById,
  };
}

;// CONCATENATED MODULE: ./src/hooks/ready/registerSheets.js




const API_ENDPOINT = "https://character-service.dndbeyond.com/character/v5/character/";
// reference to the D&D Beyond popup
const registerSheets_POPUPS = {
  json: null,
  web: null,
};
const registerSheets_renderPopup = (type, url) => {
  if (registerSheets_POPUPS[type] && !registerSheets_POPUPS[type].close) {
    registerSheets_POPUPS[type].focus();
    registerSheets_POPUPS[type].location.href = url;
  } else {
    const ratio = window.innerWidth / window.innerHeight;
    const width = Math.round(window.innerWidth * 0.5);
    const height = Math.round(window.innerWidth * 0.5 * ratio);
    registerSheets_POPUPS[type] = window.open(
      url,
      "ddb_sheet_popup",
      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`
    );
  }
  return true;
};

/* harmony default export */ function registerSheets() {
  /**
   * Character sheets
   */
  const pcSheetNames = Object.values(CONFIG.Actor.sheetClasses.character)
    .map((sheetClass) => sheetClass.cls)
    .map((sheet) => sheet.name);

  const trustedUsersOnly = game.settings.get("ddb-importer", "restrict-to-trusted");
  const allowAllSync = game.settings.get("ddb-importer", "allow-all-sync");
  const characterLink = game.settings.get("ddb-importer", "character-link-title");
  const monsterLink = game.settings.get("ddb-importer", "monster-link-title");
  const whiteTitle = (game.settings.get("ddb-importer", "link-title-colour-white")) ? " white" : "";

  pcSheetNames.forEach((sheetName) => {
    Hooks.on("render" + sheetName, (app, html, data) => {
      // only for GMs or the owner of this character
      if (!data.owner || !data.actor || (!allowAllSync && trustedUsersOnly && !game.user.isTrusted)) return;

      let url = null;
      if (app.document.data.flags.ddbimporter?.dndbeyond?.url) {
        url = app.document.data.flags.ddbimporter.dndbeyond.url;
      }

      let jsonURL = null;
      if (app.document.data.flags.ddbimporter?.dndbeyond?.json) {
        jsonURL = app.document.data.flags.ddbimporter.dndbeyond.json;
      }

      let button;

      if (characterLink) {
        button = $(`<a class="ddb-open-url" title="DDB Importer"><i class="fab fa-d-and-d-beyond${whiteTitle}"></i></a>`);
      } else {
        // don't add the button multiple times
        if ($(html).find("#ddbImporterButton").length > 0) return;
        button = $('<button type="button" id="ddbImporterButton" class="inactive"><i class="fab fa-d-and-d-beyond"></button>');
        if (app.document.data.flags.ddbimporter?.dndbeyond?.url) button.removeClass("inactive");
      }

      button.click((event) => {
        if (event.shiftKey) {
          event.preventDefault();
          return registerSheets_renderPopup("web", url);
        }

        if (event.altKey && jsonURL) {
          event.preventDefault();
          return registerSheets_renderPopup("json", jsonURL);
        }
        if (event.altKey && !jsonURL) {
          // get the character ID
          const characterId = url.split("/").pop();
          if (characterId) {
            event.preventDefault();
            return registerSheets_renderPopup("json", API_ENDPOINT + characterId);
          }
        }

        if ((!event.shiftKey && !event.ctrlKey && !event.altKey) || url === null) {
          const setupComplete = isSetupComplete(false);

          if (setupComplete) {
            let characterImport = new CharacterImport(CharacterImport.defaultOptions, data.actor);
            characterImport.render(true);
          } else {
            new DDBSetup().render(true);
          }

          return true;
        }

        return false;
      });

      if (characterLink) {
        html.closest('.app').find('.ddb-open-url').remove();
        let titleElement = html.closest('.app').find('.window-title');
        if (!app._minimized) button.insertAfter(titleElement);
      } else {
        let wrap = $('<div class="ddbCharacterName"></div>');
        $(html).find("input[name='name']").wrap(wrap);
        $(html).find("input[name='name']").parent().prepend(button);
      }
    });
  });


  /**
   * NPC sheets
   */
  const npcSheetNames = Object.values(CONFIG.Actor.sheetClasses.npc)
    .map((sheetClass) => sheetClass.cls)
    .map((sheet) => sheet.name);

  npcSheetNames.forEach((sheetName) => {
    Hooks.on("render" + sheetName, (app, html, data) => {
      // only for GMs or the owner of this npc
      if (!data.owner || !data.actor) return;
      if (!app.document.data.flags?.monsterMunch?.url) return;
      let url = app.document.data.flags.monsterMunch.url;

      let button;

      if (monsterLink) {
        button = $(`<a class="ddb-open-url" title="D&D Beyond"><i class="fab fa-d-and-d-beyond${whiteTitle}"></i></a>`);
      } else {
        button = $('<button type="button" id="ddbImporterButton"><i class="fab fa-d-and-d-beyond"></button>');
      }

      // eslint-disable-next-line no-unused-vars
      button.click((event) => {
        src_logger/* default.debug */.Z.debug(`Clicked for url ${url}`);
        registerSheets_renderPopup("web", url);
      });

      if (monsterLink) {
        html.closest('.app').find('.ddb-open-url').remove();
        let titleElement = html.closest('.app').find('.window-title');
        if (!app._minimized) button.insertAfter(titleElement);
      } else {
        let wrap = $('<div class="ddbCharacterName"></div>');
        $(html).find("input[name='name']").wrap(wrap);
        $(html).find("input[name='name']").parent().prepend(button);
      }
    });
  });
}

;// CONCATENATED MODULE: ./src/hooks/ready/checkCompendiums.js


let sanitize = (text) => {
  if (text && typeof text === "string") {
    return text.replace(/\s/g, '-').toLowerCase();
  }
  return text;
};

let createIfNotExists = async (settingName, compendiumType, compendiumLabel) => {
  const compendiumName = game.settings.get("ddb-importer", settingName);
  const compendium = await game.packs.get(compendiumName);
  if (compendium) {
    src_logger/* default.info */.Z.info(`Compendium '${compendiumName}' found, will not create compendium.`);
    return false;
  } else {
    src_logger/* default.info */.Z.info(`Compendium for ${compendiumLabel}, was not found, creating it now.`);
    const sanitizedLabel = sanitize(compendiumLabel);
    // create a compendium for the user
    await CompendiumCollection.createCompendium({
      entity: compendiumType,
      label: `DDB ${compendiumLabel}`,
      name: `ddb-${game.world.data.name}-${sanitizedLabel}`,
      package: "world",
    });
    await game.settings.set("ddb-importer", settingName, `world.ddb-${game.world.data.name}-${sanitizedLabel}`);
    return true;
  }
};


/* harmony default export */ async function checkCompendiums() {
  const autoCreate = game.settings.get("ddb-importer", "auto-create-compendium");

  if (autoCreate) {
    let results = await Promise.all([
      createIfNotExists("entity-spell-compendium", "Item", "Spells"),
      createIfNotExists("entity-item-compendium", "Item", "Items"),
      createIfNotExists("entity-feature-compendium", "Item", "Class Features"),
      createIfNotExists("entity-class-compendium", "Item", "Classes"),
      createIfNotExists("entity-trait-compendium", "Item", "Racial Traits"),
      createIfNotExists("entity-feat-compendium", "Item", "Feats"),
      createIfNotExists("entity-race-compendium", "Item", "Races"),
      createIfNotExists("entity-monster-compendium", "Actor", "Monsters"),
      createIfNotExists("entity-override-compendium", "Item", "Override"),
      createIfNotExists("entity-table-compendium", "RollTable", "Tables"),
    ]);

    const reload = results.some((result) => result.value);

    if (reload) {
      src_logger/* default.warn */.Z.warn("RELOADING!");
      // location.reload();
    }
  }

}

;// CONCATENATED MODULE: ./src/hooks/ready/registerGameSettings.js




CONFIG.DDBI = {
  module: "DDB Muncher",
  schemaVersion: "1.1",
  ADVENTURE: {},
};

/* harmony default export */ function registerGameSettings() {

  game.settings.registerMenu("ddb-importer", 'setupMenu', {
    name: "ddb-importer.setup.name",
    label: "ddb-importer.setup.name",
    hint: "ddb-importer.setup.hint",
    icon: 'fas fa-wrench',
    type: DDBSetup,
    restricted: true
  });

  game.settings.registerMenu("ddb-importer", 'compendiumMenu', {
    name: "ddb-importer.compendium-setup.name",
    label: "ddb-importer.compendium-setup.name",
    hint: "ddb-importer.setup.hint",
    icon: 'fas fa-wrench',
    type: DDBCompendiumSetup,
    restricted: true
  });

  game.settings.register("ddb-importer", "image-upload-directory", {
    name: "ddb-importer.image-upload-directory.name",
    hint: "ddb-importer.image-upload-directory.hint",
    scope: "world",
    config: false,
    type: DirectoryPicker/* DirectoryPicker.Directory */.B.Directory,
    default: "[data] ddb-images/characters",
  });

  game.settings.register("ddb-importer", "other-image-upload-directory", {
    name: "ddb-importer.image-upload-directory.name",
    hint: "ddb-importer.image-upload-directory.hint",
    scope: "world",
    config: false,
    type: DirectoryPicker/* DirectoryPicker.Directory */.B.Directory,
    default: "[data] ddb-images/other",
  });

  if (game.user.isGM) {
    const characterUploads = game.settings.get("ddb-importer", "image-upload-directory");
    const otherUploads = game.settings.get("ddb-importer", "other-image-upload-directory");
    if (characterUploads !== "[data] ddb-images/characters" && otherUploads === "[data] ddb-images/other") {
      game.settings.set("ddb-importer", "other-image-upload-directory", characterUploads);
    } else {
      DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(otherUploads));
    }
    DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(characterUploads));
  }

  game.settings.register("ddb-importer", "frame-image-upload-directory", {
    name: "ddb-importer.frame-upload-directory.name",
    hint: "ddb-importer.frame-upload-directory.hint",
    scope: "world",
    config: false,
    type: DirectoryPicker/* DirectoryPicker.Directory */.B.Directory,
    default: "[data] ddb-images/frames",
  });

  if (game.user.isGM) {
    const frameUploads = game.settings.get("ddb-importer", "frame-image-upload-directory");
    DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(frameUploads));
  }

  game.settings.register("ddb-importer", "settings-call-muncher", {
    scope: "world",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "update-check", {
    scope: "world",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "allow-scene-download", {
    name: "ddb-importer.allow-scene-download.name",
    hint: "ddb-importer.allow-scene-download.hint",
    scope: "world",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "allow-note-generation", {
    name: "ddb-importer.allow-note-generation.name",
    hint: "ddb-importer.allow-note-generation.hint",
    scope: "world",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "auto-create-compendium", {
    name: "ddb-importer.auto-create-compendium.name",
    hint: "ddb-importer.auto-create-compendium.hint",
    scope: "world",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "use-full-source", {
    name: "ddb-importer.use-full-source.name",
    hint: "ddb-importer.use-full-source.hint",
    scope: "world",
    config: true,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "use-damage-hints", {
    name: "ddb-importer.use-damage-hints.name",
    hint: "ddb-importer.use-damage-hints.hint",
    scope: "world",
    config: true,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "add-damage-restrictions-to-hints", {
    name: "ddb-importer.add-damage-restrictions-to-hints.name",
    hint: "ddb-importer.add-damage-restrictions-to-hints.hint",
    scope: "world",
    config: true,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "monster-has-vision", {
    name: "ddb-importer.monster-has-vision.name",
    hint: "ddb-importer.monster-has-vision.hint",
    scope: "world",
    config: true,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "restrict-to-trusted", {
    name: "ddb-importer.restrict-to-trusted.name",
    hint: "ddb-importer.restrict-to-trusted.hint",
    scope: "world",
    config: true,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "allow-all-sync", {
    name: "ddb-importer.allow-all-sync.name",
    hint: "ddb-importer.allow-all-sync.hint",
    scope: "world",
    config: true,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "monster-link-title", {
    name: "ddb-importer.monster-link-title.name",
    hint: "ddb-importer.monster-link-title.hint",
    scope: "world",
    config: true,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-link-title", {
    name: "ddb-importer.character-link-title.name",
    hint: "ddb-importer.character-link-title.hint",
    scope: "world",
    config: true,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "link-title-colour-white", {
    name: "ddb-importer.link-title-colour-white.name",
    hint: "ddb-importer.link-title-colour-white.hint",
    scope: "world",
    config: true,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "show-munch-top", {
    name: "ddb-importer.show-munch-top.name",
    hint: "ddb-importer.show-munch-top.hint",
    scope: "world",
    config: true,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "entity-item-compendium", {
    name: "ddb-importer.entity-item-compendium.name",
    hint: "ddb-importer.entity-item-compendium.hint",
    scope: "world",
    config: false,
    type: String,
  });

  game.settings.register("ddb-importer", "entity-feature-compendium", {
    name: "ddb-importer.entity-feature-compendium.name",
    hint: "ddb-importer.entity-feature-compendium.hint",
    scope: "world",
    config: false,
    type: String,
  });

  game.settings.register("ddb-importer", "entity-class-compendium", {
    name: "ddb-importer.entity-class-compendium.name",
    hint: "ddb-importer.entity-class-compendium.hint",
    scope: "world",
    config: false,
    type: String,
  });

  game.settings.register("ddb-importer", "entity-race-compendium", {
    name: "ddb-importer.entity-race-compendium.name",
    hint: "ddb-importer.entity-race-compendium.hint",
    scope: "world",
    config: false,
    type: String,
  });

  game.settings.register("ddb-importer", "entity-trait-compendium", {
    name: "ddb-importer.entity-trait-compendium.name",
    hint: "ddb-importer.entity-trait-compendium.hint",
    scope: "world",
    config: false,
    type: String,
  });

  game.settings.register("ddb-importer", "entity-feat-compendium", {
    name: "ddb-importer.entity-feat-compendium.name",
    hint: "ddb-importer.entity-feat-compendium.hint",
    scope: "world",
    config: false,
    type: String,
  });

  game.settings.register("ddb-importer", "entity-spell-compendium", {
    name: "ddb-importer.entity-spell-compendium.name",
    hint: "ddb-importer.entity-spell-compendium.hint",
    scope: "world",
    config: false,
    type: String,
  });

  game.settings.register("ddb-importer", "entity-override-compendium", {
    name: "ddb-importer.entity-custom-compendium.name",
    hint: "ddb-importer.entity-custom-compendium.hint",
    scope: "world",
    config: false,
    type: String,
  });

  game.settings.register("ddb-importer", "entity-table-compendium", {
    name: "ddb-importer.entity-table-compendium.name",
    hint: "ddb-importer.entity-table-compendium.hint",
    scope: "world",
    config: false,
    type: String,
  });

  game.settings.register("ddb-importer", "entity-monster-compendium", {
    name: "ddb-importer.entity-monster-compendium.name",
    hint: "ddb-importer.entity-monster-compendium.hint",
    scope: "world",
    config: false,
    type: String,
  });

  game.settings.register("ddb-importer", "adventure-import-path", {
    name: "ddb-importer.adventure-import-path.name",
    hint: "ddb-importer.adventure-import-path.hint",
    scope: "world",
    config: true,
    default: "[data] adventures/import",
    type: DirectoryPicker/* DirectoryPicker.Directory */.B.Directory
  });

  game.settings.register("ddb-importer", "adventure-upload-path", {
    name: "ddb-importer.adventure-upload-path.name",
    hint: "ddb-importer.adventure-upload-path.hint",
    scope: "world",
    config: true,
    default: "[data] ddb-images/adventures",
    type: DirectoryPicker/* DirectoryPicker.Directory */.B.Directory
  });

  const adventureUploads = game.settings.get("ddb-importer", "adventure-upload-path");

  if (game.user.isGM) {
    const oldDirPath = `[data] worlds/${game.world.id}/adventures`;
    const oldDir = DirectoryPicker/* DirectoryPicker.parse */.B.parse(oldDirPath);

    if (adventureUploads === "[data] ddb-images/adventures") {
      DirectoryPicker/* DirectoryPicker.browse */.B.browse(oldDir.activeSource, oldDir.current, { bucket: oldDir.bucket }).then((uploadFileList) => {
        if (uploadFileList.dirs.length !== 0 || uploadFileList.files.length !== 0) {
          src_logger/* default.warn */.Z.warn("Updating adventure uploads to historic default");
          game.settings.set("ddb-importer", "adventure-upload-path", oldDirPath);
        }
      }).catch((e) => {
        if (
          e.startsWith("The requested file storage undefined does not exist!") ||
          e.includes("does not exist or is not accessible in this storage location")
        ) {
          src_logger/* default.debug */.Z.debug("Adventure directory check successful");
        }
      });
    }

    DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(adventureUploads));
  }

  const baseAdventureMiscPath = adventureUploads.startsWith("[data]")
    ? `${adventureUploads}/misc`
    : "[data] ddb-images/adventures/misc";

  game.settings.register("ddb-importer", "adventure-misc-path", {
    name: "ddb-importer.adventure-misc-path.name",
    hint: "ddb-importer.adventure-misc-path.hint",
    scope: "world",
    config: true,
    default: baseAdventureMiscPath,
    type: DirectoryPicker/* DirectoryPicker.Directory */.B.Directory
  });

  if (game.user.isGM) {
    const iconUploads = game.settings.get("ddb-importer", "adventure-misc-path");
    DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(iconUploads));
  }

  game.settings.register("ddb-importer", "log-level", {
    name: "ddb-importer.log-level.name",
    hint: "ddb-importer.log-level.hint",
    scope: "world",
    config: true,
    type: String,
    choices: {
      DEBUG: "DEBUG",
      INFO: "INFO",
      WARN: "WARN",
      ERR: "ERROR ",
      OFF: "OFF",
    },
    default: "INFO",
  });

  game.settings.register("ddb-importer", "api-endpoint", {
    name: "ddb-importer.api-endpoint.name",
    hint: "ddb-importer.api-endpoint.hint",
    scope: "world",
    config: false,
    type: String,
    default: "https://proxy.ddb.mrprimate.co.uk",
  });

  const ddbProxy = game.settings.get("ddb-importer", "api-endpoint");
  if (ddbProxy === "https://ddb.mrprimate.co.uk") {
    game.settings.set("ddb-importer", "api-endpoint", "https://proxy.ddb.mrprimate.co.uk");
  }

  game.settings.register("ddb-importer", "cors-endpoint", {
    name: "ddb-importer.cors-endpoint.name",
    hint: "ddb-importer.cors-endpoint.hint",
    scope: "world",
    config: false,
    type: String,
    default: "https://images.ddb.mrprimate.co.uk/",
  });

  const corsEndpoint = game.settings.get("ddb-importer", "cors-endpoint");
  if (corsEndpoint === "https://london.drop.mrprimate.co.uk/") {
    game.settings.set("ddb-importer", "cors-endpoint", "https://images.ddb.mrprimate.co.uk/");
  }

  game.settings.register("ddb-importer", "cors-encode", {
    name: "ddb-importer.cors-encode.name",
    hint: "ddb-importer.cors-encode.hint",
    scope: "world",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "beta-key", {
    name: "ddb-importer.beta-key.name",
    hint: "ddb-importer.beta-key.hint",
    scope: "world",
    config: false,
    type: String,
    default: "",
  });

  game.settings.register("ddb-importer", "patreon-user", {
    scope: "world",
    config: false,
    type: String,
    default: null,
  });

  game.settings.register("ddb-importer", "debug-json", {
    name: "ddb-importer.debug-json.name",
    hint: "ddb-importer.debug-json.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  /** Character update settings, stored per user and non-configurable in the settings screen */
  game.settings.register("ddb-importer", "character-update-policy-add-character-effects", {
    name: "ddb-importer.character-update-policy-add-character-effects.name",
    hint: "ddb-importer.character-update-policy-add-character-effects.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  //
  // Character effect generation options
  //
  // ITEM
  // N/A
  // RACE
  game.settings.register("ddb-importer", "character-update-policy-effect-race-damages", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-race-speed", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-race-senses", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-race-hp", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-race-spell-bonus", {
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });


  // CLASS
  game.settings.register("ddb-importer", "character-update-policy-effect-class-damages", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-class-speed", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-class-senses", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-class-hp", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-class-spell-bonus", {
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });


  // FEAT
  game.settings.register("ddb-importer", "character-update-policy-effect-feat-proficiencies", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-feat-languages", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-feat-damages", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-feat-speed", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-feat-senses", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-feat-hp", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-feat-spell-bonus", {
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-feat-ability-bonus", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  // BACKGROUND
  game.settings.register("ddb-importer", "character-update-policy-effect-background-proficiencies", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-background-languages", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-background-damages", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-background-speed", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-background-senses", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-background-hp", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-background-spell-bonus", {
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-effect-background-ability-bonus", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  //
  //
  game.settings.register("ddb-importer", "character-update-policy-add-item-effects", {
    name: "ddb-importer.character-update-policy-add-item-effects.name",
    hint: "ddb-importer.character-update-policy-add-item-effects.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-generate-ac-armor-effects", {
    name: "ddb-importer.character-update-policy-generate-ac-armor-effects.name",
    hint: "ddb-importer.character-update-policy-generate-ac-armor-effects.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-generate-ac-feature-effects", {
    name: "ddb-importer.character-update-policy-generate-ac-feature-effects.name",
    hint: "ddb-importer.character-update-policy-generate-ac-feature-effects.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-generate-ac-override-effects", {
    name: "ddb-importer.character-update-policy-generate-ac-override-effects.name",
    hint: "ddb-importer.character-update-policy-generate-ac-override-effects.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-generate-base-ac", {
    name: "ddb-importer.character-update-policy-generate-base-ac.name",
    hint: "ddb-importer.character-update-policy-generate-base-ac.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-use-existing", {
    name: "ddb-importer.character-update-policy-use-existing.name",
    hint: "ddb-importer.character-update-policy-use-existing.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-use-override", {
    name: "ddb-importer.character-update-policy-use-custom.name",
    hint: "ddb-importer.character-update-policy-use-custom.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-use-srd", {
    name: "ddb-importer.character-update-policy-use-srd.name",
    hint: "ddb-importer.character-update-policy-use-srd.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  // Character update policy

  game.settings.register("ddb-importer", "character-update-policy-name", {
    name: "ddb-importer.character-update-policy-name.name",
    hint: "ddb-importer.character-update-policy-name.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-hp", {
    name: "ddb-importer.character-update-policy-name.hp",
    hint: "ddb-importer.character-update-policy-name.hp",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-hit-die", {
    name: "ddb-importer.character-update-policy-name.hit-die",
    hint: "ddb-importer.character-update-policy-name.hit-die",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-class", {
    name: "ddb-importer.character-update-policy-class.name",
    hint: "ddb-importer.character-update-policy-class.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });


  game.settings.register("ddb-importer", "character-update-policy-feat", {
    name: "ddb-importer.character-update-policy-feat.name",
    hint: "ddb-importer.character-update-policy-feat.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-weapon", {
    name: "ddb-importer.character-update-policy-weapon.name",
    hint: "ddb-importer.character-update-policy-weapon.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-equipment", {
    name: "ddb-importer.character-update-policy-equipment.name",
    hint: "ddb-importer.character-update-policy-equipment.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-bio", {
    name: "ddb-importer.character-update-policy-bio.name",
    hint: "ddb-importer.character-update-policy-bio.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-import-extras", {
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register(
    "ddb-importer",
    "character-update-policy-inventory", // = consumable, tool & loot
    {
      name: "ddb-importer.character-update-policy-inventory.name",
      hint: "ddb-importer.character-update-policy-inventory.hint",
      scope: "player",
      config: false,
      type: Boolean,
      default: true,
    }
  );

  game.settings.register("ddb-importer", "character-update-policy-currency", {
    name: "ddb-importer.character-update-policy-currency.name",
    hint: "ddb-importer.character-update-policy-currency.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-spell", {
    name: "ddb-importer.character-update-policy-spell.name",
    hint: "ddb-importer.character-update-policy-spell.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-image", {
    name: "ddb-importer.character-update-policy-image.name",
    hint: "ddb-importer.character-update-policy-image.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-use-ddb-spell-icons", {
    name: "ddb-importer.character-update-policy-use-ddb-spell-icons.name",
    hint: "ddb-importer.character-update-policy-use-ddb-spell-icons.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-use-ddb-generic-item-icons", {
    name: "ddb-importer.character-update-policy-use-ddb-generic-item-icons.name",
    hint: "ddb-importer.character-update-policy-use-ddb-generic-item-icons.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-use-ddb-item-icons", {
    name: "ddb-importer.character-update-policy-use-ddb-item-icons.name",
    hint: "ddb-importer.character-update-policy-use-ddb-item-icons.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-use-inbuilt-icons", {
    name: "ddb-importer.character-update-policy-use-inbuilt-icons.name",
    hint: "ddb-importer.character-update-policy-use-inbuilt-icons.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-use-srd-icons", {
    name: "ddb-importer.character-update-policy-use-srd-icons.name",
    hint: "ddb-importer.character-update-policy-use-srd-icons.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-use-full-description", {
    name: "ddb-importer.character-update-policy-full-description.name",
    hint: "ddb-importer.character-update-policy-full-description.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "character-update-policy-use-action-and-feature", {
    name: "ddb-importer.character-update-policy-use-action-and-feature.name",
    hint: "ddb-importer.character-update-policy-use-action-and-feature.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-dae-copy", {
    name: "ddb-importer.character-update-policy-dae-copy.name",
    hint: "ddb-importer.character-update-policy-dae-copy.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-dae-effect-copy", {
    name: "ddb-importer.character-update-policy-dae-effect-copy.name",
    hint: "ddb-importer.character-update-policy-dae-effect-copy.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-active-effect-copy", {
    name: "ddb-importer.character-update-policy-active-effect-copy.name",
    hint: "ddb-importer.character-update-policy-active-effect-copy.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "character-update-policy-active-effect-character-copy", {
    name: "ddb-importer.character-update-policy-active-effect-character-copy.name",
    hint: "ddb-importer.character-update-policy-active-effect-character-copy.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  /** Munching update settings, stored per user and non-configurable in the settings screen */
  game.settings.register("ddb-importer", "munching-policy-update-existing", {
    name: "ddb-importer.munching-policy-update-existing.name",
    hint: "ddb-importer.munching-policy-update-existing.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-use-srd", {
    name: "ddb-importer.munching-policy-use-srd.name",
    hint: "ddb-importer.munching-policy-use-srd.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  // build compendium folders?
  game.settings.register("ddb-importer", "munching-policy-use-compendium-folders", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-selection-compendium-folders-monster", {
    name: "ddb-importer.munching-selection-compendium-folders-monster.name",
    hint: "ddb-importer.munching-selection-compendium-folders-monster.hint",
    scope: "world",
    config: true,
    type: String,
    choices: {
      TYPE: "Creature type, e.g. Undead",
      CR: "Challenge Rating",
      ALPHA: "Alphabetical",
    },
    default: "TYPE",
  });

  game.settings.register("ddb-importer", "munching-selection-compendium-folders-spell", {
    name: "ddb-importer.munching-selection-compendium-folders-spell.name",
    hint: "ddb-importer.munching-selection-compendium-folders-spell.hint",
    scope: "world",
    config: true,
    type: String,
    choices: {
      SCHOOL: "School of Magic",
      LEVEL: "Level",
    },
    default: "SCHOOL",
  });

  game.settings.register("ddb-importer", "munching-selection-compendium-folders-item", {
    name: "ddb-importer.munching-selection-compendium-folders-item.name",
    hint: "ddb-importer.munching-selection-compendium-folders-item.hint",
    scope: "world",
    config: true,
    type: String,
    choices: {
      TYPE: "Item Type",
      RARITY: "Rarity",
    },
    default: "TYPE",
  });

  game.settings.register("ddb-importer", "munching-policy-use-srd-icons", {
    name: "ddb-importer.munching-policy-use-srd-icons.name",
    hint: "ddb-importer.munching-policy-use-srd-icons.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-use-inbuilt-icons", {
    name: "ddb-importer.munching-policy-use-inbuilt-icons.name",
    hint: "ddb-importer.munching-policy-use-inbuilt-icons.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "munching-policy-use-ddb-item-icons", {
    name: "ddb-importer.munching-policy-use-ddb-item-icons.name",
    hint: "ddb-importer.munching-policy-use-ddb-item-icons.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "munching-policy-use-ddb-spell-icons", {
    name: "ddb-importer.munching-policy-use-ddb-spell-icons.name",
    hint: "ddb-importer.munching-policy-use-ddb-spell-icons.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "munching-policy-use-ddb-generic-item-icons", {
    name: "ddb-importer.munching-policy-use-ddb-generic-item-icons.name",
    hint: "ddb-importer.munching-policy-use-ddb-generic-item-icons.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "munching-policy-use-full-token-image", {
    name: "ddb-importer.munching-policy-use-full-token-image.name",
    hint: "ddb-importer.munching-policy-use-full-token-image.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-use-token-avatar-image", {
    name: "ddb-importer.munching-policy-use-token-avatar-image.name",
    hint: "ddb-importer.munching-policy-use-token-avatar-image.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-remote-images", {
    name: "ddb-importer.munching-policy-remote-images.name",
    hint: "ddb-importer.munching-policy-remote-images.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "munching-policy-add-effects", {
    name: "ddb-importer.munching-policy-add-effects.name",
    hint: "ddb-importer.munching-policy-add-effects.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-add-ac-armor-effects", {
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-download-images", {
    name: "ddb-importer.munching-policy-download-images.name",
    hint: "ddb-importer.munching-policy-download-images.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-dae-copy", {
    name: "ddb-importer.munching-policy-dae-copy.name",
    hint: "ddb-importer.munching-policy-dae-copy.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-use-dae-effects", {
    name: "ddb-importer.munching-policy-use-dae-effects.name",
    hint: "ddb-importer.munching-policy-use-dae-effects.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-hide-description", {
    name: "ddb-importer.munching-policy-hide-description.name",
    hint: "ddb-importer.munching-policy-hide-description.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-monster-items", {
    name: "ddb-importer.munching-policy-monster-items.name",
    hint: "ddb-importer.munching-policy-monster-items.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-monster-homebrew", {
    name: "ddb-importer.munching-policy-monster-homebrew.name",
    hint: "ddb-importer.munching-policy-monster-homebrew.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-monster-homebrew-only", {
    name: "ddb-importer.munching-policy-monster-homebrew-only.name",
    hint: "ddb-importer.munching-policy-monster-homebrew-only.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-update-images", {
    name: "ddb-importer.munching-policy-update-images.name",
    hint: "ddb-importer.munching-policy-update-images.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "munching-policy-monster-exact-match", {
    name: "ddb-importer.munching-policy-monster-match.name",
    hint: "ddb-importer.munching-policy-monster-match.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "munching-policy-monster-sources", {
    name: "ddb-importer.munching-policy-monster-sources.name",
    hint: "ddb-importer.munching-policy-monster-sources.hint",
    scope: "player",
    config: false,
    type: Array,
    default: [],
  });

  // sets the current tutorial step the user has completed
  // game.settings.register("ddb-importer", "tutorial-step", {
  //   scope: "world",
  //   config: false,
  //   type: Number,
  //   default: 0,
  // });
  // sets the current tutorial step the user has completed
  // game.settings.register("ddb-importer", "tutorial-user", {
  //   scope: "world",
  //   config: false,
  //   type: String,
  //   default: "",
  // });
  // sets the current tutorial step the user has completed
  // game.settings.register("ddb-importer", "popup-version", {
  //   scope: "world",
  //   config: false,
  //   type: String,
  //   default: "1.0.0",
  // });
  // sets the user submission name for scene adjustments
  // game.settings.register("ddb-importer", "scene-submission-username", {
  //   scope: "user",
  //   config: false,
  //   type: String,
  //   default: "",
  // });
  game.settings.register("ddb-importer", "cobalt-cookie", {
    name: "ddb-importer.cobalt-cookie.name",
    hint: "ddb-importer.cobalt-cookie.hint",
    scope: "world",
    config: false,
    type: String,
    default: "",
  });

  game.settings.register("ddb-importer", "cobalt-cookie-local", {
    name: "ddb-importer.cobalt-cookie-local.name",
    hint: "ddb-importer.cobalt-cookie-local.hint",
    scope: "world",
    config: false,
    type: Boolean,
    default: true,
  });

  if (game.user.isGM && game.settings.get("ddb-importer", "cobalt-cookie-local") &&
    game.settings.get("ddb-importer", "cobalt-cookie") != "") {
    game.settings.set("ddb-importer", "cobalt-cookie-local", false);
  }

  game.settings.register("ddb-importer", "campaign-id", {
    name: "ddb-importer.campaign-id.name",
    hint: "ddb-importer.campaign-id.hint",
    scope: "world",
    config: false,
    type: String,
    default: "",
  });

  game.settings.register("ddb-importer", "sync-policy-currency", {
    name: "ddb-importer.sync-policy-currency.name",
    hint: "ddb-importer.sync-policy-currency.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "sync-policy-hitpoints", {
    name: "ddb-importer.sync-policy-hitpoints.name",
    hint: "ddb-importer.sync-policy-hitpoints.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "sync-policy-hitdice", {
    name: "ddb-importer.sync-policy-hitdice.name",
    hint: "ddb-importer.sync-policy-hitdice.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "sync-policy-action-use", {
    name: "ddb-importer.sync-policy-action-use.name",
    hint: "ddb-importer.sync-policy-action-use.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "sync-policy-inspiration", {
    name: "ddb-importer.sync-policy-inspiration.name",
    hint: "ddb-importer.sync-policy-inspiration.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "sync-policy-condition", {
    name: "ddb-importer.sync-policy-condition.name",
    hint: "ddb-importer.sync-policy-condition.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "sync-policy-deathsaves", {
    name: "ddb-importer.sync-policy-deathsaves.name",
    hint: "ddb-importer.sync-policy-deathsaves.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "sync-policy-spells-prepared", {
    name: "ddb-importer.sync-policy-spells-prepared.name",
    hint: "ddb-importer.sync-policy-spells-prepared.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "sync-policy-spells-slots", {
    name: "ddb-importer.sync-policy-spells-slots.name",
    hint: "ddb-importer.sync-policy-spells-slots.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "sync-policy-spells-sync", {
    name: "ddb-importer.sync-policy-spells-sync.name",
    hint: "ddb-importer.sync-policy-spells-sync.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "sync-policy-equipment", {
    name: "ddb-importer.sync-policy-equipment.name",
    hint: "ddb-importer.sync-policy-equipment.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "sync-policy-xp", {
    name: "ddb-importer.sync-policy-xp.name",
    hint: "ddb-importer.sync-policy-xp.hint",
    scope: "player",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "encounter-import-policy-create-scene", {
    scope: "world",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "encounter-import-policy-missing-characters", {
    scope: "world",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "encounter-import-policy-missing-monsters", {
    scope: "world",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "encounter-import-policy-create-journal", {
    scope: "world",
    config: false,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "encounter-import-policy-roll-monster-initiative", {
    scope: "world",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "encounter-import-policy-use-ddb-save", {
    scope: "world",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "adventure-muncher-full-config", {
    scope: "world",
    config: false,
    type: Boolean,
    default: false,
  });


}

;// CONCATENATED MODULE: ./src/lib/itemConfig.js
class DDBItemConfig extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.title = "DDB Owned Item Config";
    options.template = "modules/ddb-importer/handlebars/item-config.hbs";
    options.classes = ["ddbimporter", "sheet"];
    options.width = 500;
    return options;
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    // console.warn(this);
    // console.warn(this.object);
    let item = this.object.data;

    const icon = item.flags.ddbimporter?.ignoreIcon;
    const itemImport = item.flags.ddbimporter?.ignoreItemImport;
    const resource = item.flags.ddbimporter?.retainResourceConsumption;
    // const itemSync = item.flags.ddbimporter?.ignoreItemSync;

    const settings = [
      {
        name: "ignoreItemImport",
        isChecked: itemImport,
        description: "Ignore this item when importing the character (implies all other settings here).",
      },
      {
        name: "ignoreIcon",
        isChecked: icon,
        description: "Ignore icon updates.",
      },
      {
        name: "retainResourceConsumption",
        isChecked: resource,
        description: "Retain Resource Consumption linking.",
      },
      // {
      //   name: "ignoreItemSync",
      //   isChecked: itemSync,
      //   description: "Ignore this item when when syncing the character",
      // },
    ];

    const result = {
      name: item.name,
      img: item.img,
      character: this.object.actor.name,
      settings: settings,
    };

    return result;
  }

  get id() {
    const actor = this.object;
    let id = `ddb-actor-${actor.id}`;
    return id;
  }

  /** @override */
  // eslint-disable-next-line no-unused-vars
  async _updateObject(event, formData) {
    event.preventDefault();

    let item = {
      _id: this.object.data._id,
      flags: this.object.data.flags,
    };

    if (!item.flags.ddbimporter) item.flags.ddbimporter = {};
    item.flags.ddbimporter['ignoreIcon'] = formData['ignoreIcon'];
    item.flags.ddbimporter['ignoreItemImport'] = formData['ignoreItemImport'];
    item.flags.ddbimporter['retainResourceConsumption'] = formData['retainResourceConsumption'];
    // item.flags.ddbimporter['ignoreItemSync'] = formData['ignoreItemSync'];
    this.object.actor.updateEmbeddedDocuments("Item", [item]);

  }
}

;// CONCATENATED MODULE: ./src/hooks/ready/items.js


function initItemSheetHook(app, html) {
  if (!app.document.isOwned) return;
  // console.error(app.entity);
  // console.log(data);
  const title = `DDB Importer Item Config`;
  const whiteTitle = (game.settings.get("ddb-importer", "link-title-colour-white")) ? " white" : "";
  let button = $(`<a class="open-item-ddb-importer" title="${title}"><i class="fab fa-d-and-d-beyond${whiteTitle}"></i></a>`);
  button.click(() => {
    new DDBItemConfig(app.document, {}).render(true);
  });
  html.closest('.app').find('.open-item-ddb-importer').remove();
  let titleElement = html.closest('.app').find('.window-title');
  button.insertAfter(titleElement);
}

function itemSheets() {
  Hooks.on('renderItemSheet', initItemSheetHook);
}


;// CONCATENATED MODULE: ./src/hooks/ready/checkVersion.js



const MODULE_TITLE = "DDB Importer";
const MODULE_NAME = "ddb-importer";
const MODULE_AUTHOR = "MrPrimate";
const _GITHUB_API_LATEST = `https://api.github.com/repos/${MODULE_AUTHOR}/${MODULE_NAME}/releases/latest`;
const _GITHUB_MODULE_JSON_LATEST = `https://raw.githubusercontent.com/${MODULE_AUTHOR}/${MODULE_NAME}/master/module-template.json`;

// eslint-disable-next-line consistent-return
async function getLatestModuleVersion() {
  try {
      const { tag_name: latestVersion, prerelease } = await $.getJSON(_GITHUB_API_LATEST);
      return { latestVersion, prerelease };
  } catch (error) {
      src_logger/* default.error */.Z.error(error);
  }
}

// eslint-disable-next-line consistent-return
async function getLatestModuleMinimumCoreVersion() {
  try {
      const { minimumCoreVersion, compatibleCoreVersion } = await $.getJSON(_GITHUB_MODULE_JSON_LATEST);
      return { minimumCoreVersion, compatibleCoreVersion };
  } catch (error) {
    src_logger/* default.error */.Z.error(error);
  }
}

/* harmony default export */ const checkVersion = (async () => {
  // check version number only for GMs
  const check = game.settings.get("ddb-importer", "update-check");
  if (!check || !game.user.isGM) return;

  const moduleInfo = game.modules.get(MODULE_NAME).data;
  const installedVersion = moduleInfo.version;
  try {
    const { latestVersion, prerelease: preRelease } = await getLatestModuleVersion();
    const { minimumCoreVersion, compatibleCoreVersion } = await getLatestModuleMinimumCoreVersion();

    const newModuleVersion = src_utils/* default.versionCompare */.Z.versionCompare(latestVersion, installedVersion) === 1;
    const compatibleCore = src_utils/* default.versionCompare */.Z.versionCompare(game.data.version, compatibleCoreVersion) >= 0;
    const compatibleMinimumCore = src_utils/* default.versionCompare */.Z.versionCompare(game.data.version, minimumCoreVersion) >= 0;

    const needToUpdate = newModuleVersion && compatibleCore && compatibleMinimumCore;

    // console.log(utils.versionCompare("1.0.1", "1.0.1")); // 0
    // console.log(utils.versionCompare("1.0.0", "1.0.1")); // -1
    // console.log(utils.versionCompare("2.0.0", "1.0.1")); // 1

    if (preRelease) src_logger/* default.debug */.Z.debug(`Prerelease of ${MODULE_TITLE} detected`);

    if (needToUpdate) {
      let text = $(
        `<h2>${MODULE_TITLE} Update!</h2><p>A new <b>${MODULE_NAME}</b> version is available. Please update to <b>v${latestVersion}</b> if you are experiencing issues and before reporting a bug.</p>`
      );
      window.DDBImporter.notification.show(text, null);
    }
  } catch (error) {
    src_logger/* default.warn */.Z.warn(error);
    window.DDBImporter.notification.show(`Could not retrieve latest ${MODULE_NAME} version`);
  }
});

;// CONCATENATED MODULE: ./src/hooks/renderMuncher/settings.js
function earlySettings() {

  game.settings.register("ddb-importer", "show-munch-top", {
    name: "ddb-importer.show-munch-top.name",
    hint: "ddb-importer.show-munch-top.hint",
    scope: "world",
    config: true,
    type: Boolean,
    default: true,
  });

  game.settings.register("ddb-importer", "patreon-tier", {
    scope: "world",
    config: false,
    type: String,
    default: null,
  });

  game.settings.register("ddb-importer", "custom-proxy", {
    name: "ddb-importer.custom-proxy.name",
    hint: "ddb-importer.custom-proxy.hint",
    scope: "world",
    config: false,
    type: Boolean,
    default: false,
  });

  game.settings.register("ddb-importer", "encounter-muncher-enabled", {
    scope: "world",
    config: false,
    type: Boolean,
    default: true,
  });

  // for D&D 5e 1.4 ac migrtion
  game.settings.register("ddb-importer", "ac-migration-complete-v1-4", {
    scope: "world",
    config: false,
    type: Boolean,
    default: false,
  });

}

;// CONCATENATED MODULE: ./src/hooks/renderMuncher/addMuncher.js





function addMuncher (app, html) {
  if (app.options.id == "compendium" && game.user.isGM) {
    let button = $("<div class='header-actions action-buttons flexrow'><button class='ddb-muncher'><i class='fas fa-pastafarianism'></i> DDB Muncher</button></div>");

    button.click(async () => {
      ui.notifications.info("Checking your DDB details - this might take a few seconds!");
      const setupComplete = isSetupComplete();

      if (setupComplete) {
        const cobaltStatus = await checkCobalt();
        if (cobaltStatus.success) {
          let validKey = await isValidKey();
          if (validKey) {
            new DDBMuncher().render(true);
          }
        } else {
          new DDBCookie().render(true);
        }
      } else {
        game.settings.set("ddb-importer", "settings-call-muncher", true);
        new DDBSetup().render(true);
      }
    });

    const top = game.settings.get("ddb-importer", "show-munch-top");
    if (top) {
      $(html).find(".directory-header").append(button);
    } else {
      $(html).find(".directory-footer").append(button);
    }

  }
}

;// CONCATENATED MODULE: ./src/hooks/renderMuncher/addEncounterMuncher.js







function addEncounterMuncher (app, html) {
  const tier = game.settings.get("ddb-importer", "patreon-tier");
  const tiers = (0,utils/* getPatreonTiers */.A1)(tier);
  const enabled = game.settings.get("ddb-importer", "encounter-muncher-enabled");

  if (enabled && app.options.id == "scenes" && game.user.isGM && tiers.supporter) {
    let button = $("<div class='header-actions action-buttons flexrow'><button class='ddb-muncher' id='ddb-encounter-munch-open'><i class='fas fa-dungeon'></i> DDB Encounter Muncher</button></div>");

    const actualButton = button.find('#ddb-encounter-munch-open');
    button.click(async () => {
      actualButton.prop('disabled', true);
      ui.notifications.info("Fetching your DDB Encounter Information, this might take a few seconds!");
      try {
        const setupComplete = isSetupComplete();

        if (setupComplete) {
          const cobaltStatus = await checkCobalt();
          if (cobaltStatus.success) {
            let validKey = await isValidKey();
            if (validKey) {
              new DDBEncounterMunch().render(true);
            }
          } else {
            actualButton.prop('disabled', false);
            new DDBCookie().render(true);
          }
        } else {
          actualButton.prop('disabled', false);
          new DDBSetup().render(true);
        }
      } catch (e) {
        src_logger/* default.error */.Z.error(e);
        actualButton.prop('disabled', false);
      }
    });

    const top = game.settings.get("ddb-importer", "show-munch-top");
    if (top) {
      $(html).find(".directory-header").prepend(button);
    } else {
      $(html).find(".directory-footer").append(button);
    }

    Hooks.on("closeApplication", (app) => {
      if (app instanceof DDBEncounterMunch) {
        actualButton.prop('disabled', false);
      }
    });

  }
}

;// CONCATENATED MODULE: ./src/hooks/socket/onSocketMessage.js
function onShowImage (data) {
  const src = data.src;
  const type = data.type.toLowerCase();

  // check for an existing popout with that source
  let isDisplayed = false;
  $(`div.ddbimporter-image-popout ${type}`).each((index, element) => {
    if ($(element).attr("src") === src) isDisplayed = true;
  });
  if (isDisplayed) return;

  // create the image popup
  const popout = $(
    `<div class="ddbimporter-image-popout"><${type} src="${src}" ${
      type === "video" ? ' "preload="auto" autoplay="autoplay" loop="loop"' : ""
    }/></div>`
  );
  popout.on("click", () => {
    $(popout).hide(400, () => {
      $(popout).remove();
    });
  });
  $("body").prepend(popout);
  $(popout).show(400);
}

function onSocketMessage (sender, data) {
  switch (data.action) {
    case "showImage": {
      onShowImage(data);
    }
    // no default
  }
}

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/linkTables.js
function linkTables(type, html) {

  // if journal
  let content;
  let findString;
  switch (type) {
    case "journal":
      content = $(html).find(`div[data-edit="content"]`);
      findString = "a.entity-link[data-entity='RollTable']";
      break;
    case "item": {
      const tableCompendium = game.settings.get("ddb-importer", "entity-table-compendium");
      content = $(html).find(`div[data-edit="data.description.value"]`);
      findString = `a.entity-link[data-pack='${tableCompendium}']`;
      break;
    }
    // no default
  }


  // Add a direct roll button into DDB-imported rolltables
  $(content)
    .find(findString)
    .each(async (_, link) => {
      const data = $(link).data();
      const pack = game.packs.get(data.pack);

      const table = pack
        ? await pack.getDocument(data.id)
        : game.tables.get(data.id);

      if (table?.data?.flags?.ddb?.contentChunkId || pack) {
        const button = $(
          `<a title="Click: Roll | Shift-Click: Self Roll" class="ddbimporter roll"><i class="fas fa-dice-d20"></i>  Roll!</a>`
        );

        $(link).after(button);
        $(button).on("click", async (event) => {
          event.preventDefault();
          const rollMode = event.shiftKey ? "selfroll" : "roll";

          // fix: Table description is undefined
          if (!table.data.description) table.data.description = table.data.name;

          const draw = await table.roll();

          draw.results = draw.results.map((result) => {
            if (!result.img)
              result.img = "icons/svg/d20-highlight.svg";
            return result;
          });

          await table.toMessage(draw.results, {
            roll: draw.roll,
            messageOptions: {
              speaker: game.user.name,
              rollMode: rollMode,
            },
          });

        });
      }
    });
}

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/linkImages.js


function linkImages(html) {
  if (!game.user.isGM) return;
  // does this functionality exist from anther module?
  const funcExists = src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("vtta-dndbeyond") ||
    src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("vtta-ddb") ||
    src_utils/* default.isModuleInstalledAndActive */.Z.isModuleInstalledAndActive("token-hud-art-button");

  if (funcExists) return;

  // mark all images
  $(html)
    .find('div[data-edit="content"] img, div[data-edit="content"] video')
    .each((index, element) => {
      const showPlayersButton = $("<a class='ddbimporter-button'><i class='fas fa-eye'></i>&nbsp;Show Players</a>");

      $(element).wrap("<div class='ddbimporter-image-container'></div>");
      // show the button on mouseenter of the image
      $(element)
        .parent()
        .mouseenter(function addHover() {
          // eslint-disable-next-line no-invalid-this
          $(this).append(showPlayersButton);
          $(showPlayersButton).click((event) => {
            event.preventDefault();
            event.stopPropagation();
            game.socket.emit("module.ddb-importer", {
              sender: game.user.data._id,
              action: "showImage",
              src: $(element).attr("src"),
              type: element.nodeName,
            });
          });
        });
      $(element)
        .parent()
        .mouseleave(function removeHover() {
          // eslint-disable-next-line no-invalid-this
          $(this).find("a").remove();
        });
    });
}

;// CONCATENATED MODULE: ./src/lib/adventureFlags.js
class DDBAdventureFlags extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.title = "DDB Adventure Imported Flags";
    options.template = "modules/ddb-importer/handlebars/flag-details.hbs";
    options.classes = ["ddbimporter", "sheet"];
    options.width = 500;
    return options;
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    // console.warn(this);
    // console.warn(this.object);
    let item = this.object.data;

    let flags = [];

    for (const i in item.flags.ddb) {
      const v = (i === "userData") ? item.flags.ddb[i]["userDisplayName"] : item.flags.ddb[i];
      flags.push({
        key: i,
        value: v,
      });
    }

    const result = {
      name: item.name,
      flags: flags,
      link: item.link,
      ddbLink: `https://www.dndbeyond.com/${flags.bookCode}/${flags.slug}`,
    };

    return result;
  }

}

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/buildNotes.js
function copyToClipboard(text) {
  var dummy = document.createElement("textarea");
  document.body.appendChild(dummy);
  dummy.value = text;
  dummy.select();
  document.execCommand("copy");
  document.body.removeChild(dummy);
}

var clippy = {};
var tableInUse = false;

function getNoteButton(name, type) {
  return $(
    `<a id='ddb-note-${name}' class='ddb-button'><i class='fas fa-clipboard-check'></i>&nbsp;Copy ${type} ${name} </a>`
  );
}

function getTableButton() {
  return $(
    `<a id='ddb-table-name' class='ddb-button'><i class='fas fa-clipboard-check'></i>&nbsp;Copy table details </a>`
  );
}

function buildNotes(html, data) {
  if (!game.user.isGM) return;
  const allow = game.settings.get("ddb-importer", "allow-note-generation");
  if (!allow) return;

  // mark all headers
  $(html)
    .find("h1, h2, h3, h4, h5, figure, p")
    .each((index, element) => {
      $(element).wrap("<div class='ddbimporter-note-container'></div>");
      // show the button on mouseenter
      $(element)
        .parent()
        .mouseenter(function Hovering() {
          if (tableInUse) return;
          const tagName = $(element).prop("tagName");
          const showStartButton = $(this).append(getNoteButton("start", tagName));
          const showEndButton = $(this).append(getNoteButton("end", tagName));
          $(showStartButton).click((e) => {
            // const src = $(element).attr("src");
            // In 0.8.x for some reason I need to now wrap these in the target id check?
            if (e.target.id === "ddb-note-start") {
              clippy = {
                ddbId: data.data.flags.ddb.ddbId,
                cobaltId: data.data.flags.ddb.cobaltId,
                parentId: data.data.flags.ddb.parentId,
                splitTag: tagName.toLowerCase(),
                slug: data.data.flags.ddb.slug,
                tagIdFirst: $(element).prop("id"),
                contentChunkIdStart: $(element).attr("data-content-chunk-id"),
                tagIdLast: "",
                contentChunkIdStop: "EOF",
                sceneName: data.data.name,
              };
              copyToClipboard(JSON.stringify(clippy, null, 2));
            }
          });
          $(showEndButton).click((e) => {
            if (e.target.id === "ddb-note-end") {
              clippy.tagIdLast = $(element).prop("id");
              clippy.contentChunkIdStop = $(element).attr("data-content-chunk-id");
              copyToClipboard(JSON.stringify(clippy, null, 2));
            }
          });
        });
      $(element)
        .parent()
        .mouseleave(function Unhovering() {
          $(this).find("#ddb-note-start").remove();
          $(this).find("#ddb-note-end").remove();
        });
    });

  // mark all headers
  $(html)
    .find("table")
    .each((index, element) => {
      $(element).wrap("<div class='ddbimporter-table-container'></div>");
      // show the button on mouseenter
      $(element)
        .parent()
        .mouseenter(function Hovering() {
          tableInUse = true;
          const showButton = $(this).append(getTableButton());
          $(showButton).click((e) => {
            if (e.target.id === "ddb-table-name") {
              clippy = {
                ddbId: data.data.flags.ddb.ddbId,
                cobaltId: data.data.flags.ddb.cobaltId,
                parentId: data.data.flags.ddb.parentId,
                slug: data.data.flags.ddb.slug,
                tagIdFirst: $(element).prop("id"),
                contentChunkId: $(element).attr("data-content-chunk-id"),
                sceneName: data.data.name,
                tableName: "",
              };
              copyToClipboard(JSON.stringify(clippy, null, 2));
            }
          });
        });
      $(element)
        .parent()
        .mouseleave(function Unhovering() {
          $(this).find("#ddb-table-name").remove();
          tableInUse = false;
        });
    });
}

/* harmony default export */ const renderJournalSheet_buildNotes = (buildNotes);

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/adventure.js




const adventure_POPUPS = {
  json: null,
  web: null,
};
const adventure_renderPopup = (type, url) => {
  if (adventure_POPUPS[type] && !adventure_POPUPS[type].close) {
    adventure_POPUPS[type].focus();
    adventure_POPUPS[type].location.href = url;
  } else {
    const ratio = window.innerWidth / window.innerHeight;
    const width = Math.round(window.innerWidth * 0.5);
    const height = Math.round(window.innerWidth * 0.5 * ratio);
    adventure_POPUPS[type] = window.open(
      url,
      "ddb_sheet_popup",
      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`
    );
  }
  return true;
};

function adventureFlags(app, html, data) {
  if (!game.user.isGM || !app.document.data.flags.ddb) return;
  const existingLink = html.closest('.app').find('.open-adventure-ddb-importer');
  if (existingLink.length > 0) return;

  const title = `Go to DDB`;
  const whiteTitle = (game.settings.get("ddb-importer", "link-title-colour-white")) ? " white" : "";
  let button = $(`<a class="open-adventure-ddb-importer" title="${title}"><i class="fab fa-d-and-d-beyond${whiteTitle}"></i></a>`);
  button.click((event) => {
    if (event.shiftKey) {
      new DDBAdventureFlags(app.document, {}).render(true);
    } else {
      event.preventDefault();
      const flags = app.document.data.flags.ddb;
      const bookSource = ddbConfig/* DDB_CONFIG.sources.find */.U.sources.find((book) => flags.bookCode.toLowerCase() === book.name.toLowerCase());
      return adventure_renderPopup("web", `https://www.dndbeyond.com/${bookSource.sourceURL}/${flags.slug}`);
    }
    return true;
  });

  let titleElement = html.closest('.app').find('.window-title');
  button.insertAfter(titleElement);
  renderJournalSheet_buildNotes(html, data);
}


/* harmony default export */ const adventure = (adventureFlags);

;// CONCATENATED MODULE: ./src/lib/Notification.js
/**
 * Shows notifcations and hints to the user
 */
const MARGIN = 10;

const registerNotifications = () => {
  // register the notification global object

  if ($("#ddbimporter-notifications").length === 0) {
    $("body").append(`<div id="ddbimporter-notifications"></div>`);
  }
  if ($("#ddbimporter-hints").length === 0) {
    $("body").append(`<div id="ddbimporter-hints"></div>`);
  }

  window.DDBImporter.notification = {
    clear: () => {
      $("#ddbimporter-notifications div").fadeOut(200, () => {
        $("#ddbimporter-notifications").empty();
      });
    },
    show: (message, timeout = 4000) => {
      $("#ddbimporter-notifications").css("left", $("#players").css("left"));
      // prettier-ignore
      $("#ddbimporter-notifications").css("bottom", $("#players").height() + (2 * MARGIN));

      let note = $(`<div style="display: none"></div>`).append(message);
      $("#ddbimporter-notifications").append(note);
      $(note).fadeIn(200);

      if (timeout)
        setTimeout(() => {
          $(note).fadeOut(200, () => {
            $(note).remove();
          });
        }, timeout);
      else
        $(note).append('<p style="text-align: center; color: #7e7e7e; margin: 0px;"><small>Click to close</small>');

      $(note).on("click", () => {
        $(note).fadeOut(200, () => {
          $(note).remove();
        });
      });
    },
  };
  window.DDBImporter.hint = {
    clear: () => {
      $("#ddbimporter-hints div").hide(200, () => {
        $("#ddbimporter-hints").empty();
      });
    },
    show: (message, options = {}) => {
      return new Promise((resolve) => {
        $("#ddbimporter-hints").css("width", options.width ? options.width : 300);

        // construct the note
        let note = $(`<div style="display: none"></div>`);
        $(note).append(message);
        $(note).append('<div class="buttons"></div>');
        $("#ddbimporter-hints").append(note);
        $(note).fadeIn(200);

        if (!options.align) options.align = options.element ? "RIGHT" : "CENTER";

        let anchor = {
          width: 0,
          height: 0,
          top: Math.round(window.innerHeight / 2),
          left: Math.round(window.innerWidth / 2),
        };

        if (options.element) {
          anchor = Object.assign(
            { width: $(options.element).width(), height: $(options.element).height() },
            $(options.element).offset()
          );
        }
        const noteInfo = Object.assign(
          { width: $("#ddbimporter-hints").width(), height: $("#ddbimporter-hints").height() },
          $("#ddbimporter-hints").position()
        );

        switch (options.align) {
          case "RIGHT":
            $("#ddbimporter-hints").css("top", anchor.top);
            $("#ddbimporter-hints").css("left", anchor.left + anchor.width + MARGIN);
            break;
          case "LEFT":
            $("#ddbimporter-hints").css("top", anchor.top);
            $("#ddbimporter-hints").css("left", anchor.left - noteInfo.width - MARGIN);
            break;
          case "TOP":
            $("#ddbimporter-hints").css("top", anchor.top - noteInfo.height - MARGIN);
            $("#ddbimporter-hints").css("left", anchor.left);
            break;
          case "BOTTOM":
            $("#ddbimporter-hints").css("top", anchor.top + anchor.height + MARGIN);
            $("#ddbimporter-hints").css("left", anchor.left);
            break;

          default:
            // eslint-disable-next-line no-mixed-operators
            $("#ddbimporter-hints").css("top", anchor.top - Math.round(noteInfo.height / 2));
            // eslint-disable-next-line no-mixed-operators
            $("#ddbimporter-hints").css("left", anchor.left - Math.round(noteInfo.width / 2));
        }

        if (options.buttons) {
          for (let name of options.buttons) {
            let btn = $("<button>" + name + "</button>");
            $("div.buttons", note).append(btn);
            $(btn).on("click", () => {
              $(note).fadeOut(100, () => {
                $(note).remove();
                resolve(name);
              });
            });
          }
        }
        if (options.hide) {
          $(options.hide.selector).on(options.hide.event, () => {
            $(note).fadeOut(100, () => {
              $(note).remove();
              resolve(true);
            });
          });
        }
      });
    },
  };
};

/* harmony default export */ const Notification = (registerNotifications);

;// CONCATENATED MODULE: ./src/hooks.js


// init hooks



// ready hooks







// monster muncher




// socket messaging


// image hooks







// foundry is initializing
function init() {
  setupLogging();
  registerWindow();
  src_logger/* default.info */.Z.info("Init");
}

// foundry is ready
function onceReady() {
  // register the game settings
  registerGameSettings();

  // check for valid compendiums
  checkCompendiums();

  // notificaitons
  Notification();

  // delay the startup just a tiny little bit
  setTimeout(() => {
    // register the D&DBeyond Button on the character sheets
    registerSheets();
    itemSheets();
    checkVersion();
    (0,ddbConfig/* loadDDBConfig */.p)();

  }, 500);
}

function onReady() {
  game.socket.on("module.ddb-importer", (data) => {
    if (data.sender === game.user.data._id) {
      return;
    }

    const sender = game.users.get(data.sender);
    delete data.sender;
    onSocketMessage(sender, data);
  });
}

function renderSidebarTab(app, html) {
  earlySettings();
  addEncounterMuncher(app, html);
  addMuncher(app, html);
}

function renderItemSheet(sheet, html) {
  linkTables("item", html);
  linkImages(html);
}

function renderJournalSheet(sheet, html, data) {
  linkTables("journal", html);
  linkImages(html);
  adventure(sheet, html, data);
}

;// CONCATENATED MODULE: ./src/hooks/getSceneNavigationContext/extendSceneNavigationContext.js
// import utils from "../../utils.js";


/**
   * Extracts all notes that have been placed by ddb-importer
   * Creates the expected data structure for the database by
   * getting the real label from the appropriate Journal Entry
   * @param {Scene} scene The scene to extract the notes from
  */
const getNotes = (scene) => {
  // get all notes in the Journal related to this scene
  const relatedJournalEntries = game.journal.filter((journal) =>
    journal.data.flags.ddb?.bookCode && scene.data.flags.ddb?.bookCode &&
    journal.data.flags.ddb.bookCode === scene.data.flags.ddb.bookCode
  );

  // get all notes placed on the map
  const notes = scene.data.notes
    // the user might have placed a note, unless it is based on an imported Journal Entry, we will not carry
    // that one over
    .filter((note) => relatedJournalEntries.some((journal) => journal.id === note.data.entryId))
    .map((note) => {
      const journal = relatedJournalEntries.find((journal) => journal.id === note.data.entryId);
      const idx = parseInt(journal.data.flags.ddb.ddbId);
        // removed un-needed userdata
      const flags = journal.data.flags.ddb;
      if (flags?.userData) {
        if (flags.userData.status) delete (flags.userData.status);
        if (flags.userData.userId) delete (flags.userData.userId);
        if (flags.userData.twitchUserName) delete (flags.userData.twitchUserName);
        if (flags.userData.AvatarUrl) delete (flags.userData.AvatarUrl);
      }
      return {
        index: idx,
        label: journal.data.name,
        flags: {
          ddb: flags,
        },
        iconSize: note.data.iconSize,
        iconTint: note.data.iconTint,
        textColor: note.data.textColor,
        textAnchor: note.data.textAnchor,
        x: note.data.x,
        y: note.data.y,
      };
    })
    .reduce((notes, note) => {
      const idx = notes.find((n) => n.index === note.index);
      if (idx) {
        idx.positions.push({ x: note.x, y: note.y });
      } else {
        const n = {
          label: note.label,
          flags: note.flags,
          index: note.index,
          iconSize: note.iconSize,
          iconTint: note.iconTint,
          textColor: note.textColor,
          textAnchor: note.textAnchor,
          positions: [{ x: note.x, y: note.y }]
        };
        notes.push(n);
      }
      return notes;
    }, [])
    .sort((a, b) => {
      return a.index - b.index;
    })
    .map((note) => ({
      label: note.label,
      flags: note.flags,
      positions: note.positions,
      iconSize: note.iconSize,
      iconTint: note.iconTint,
      textColor: note.textColor,
      textAnchor: note.textAnchor,
    }));

  return notes;
};

/**
 * Prepares the scene data for download
 * @param {Scene} scene
 */
const collectSceneData = (scene) => {
  const notes = getNotes(scene);

  const data = {
    flags: scene.data.flags,
    name: scene.data.name,
    navName: scene.data.navName,
    // dimensions
    width: scene.data.width,
    height: scene.data.height,
    // grid
    grid: scene.data.grid,
    gridDistance: scene.data.gridDistance,
    gridType: scene.data.gridType,
    gridUnits: scene.data.gridUnits,
    shiftX: scene.data.shiftX,
    shiftY: scene.data.shiftY,
    padding: scene.data.padding,
    // initial
    initial: scene.data.initial,
    // customization
    backgroundColor: scene.data.backgroundColor,
    walls: scene.data.walls.map((wall) => {
      const w = wall.toObject();
      delete w._id;
      return w;
    }),
    //
    drawings: scene.data.drawings,
    weather: scene.data.weather,
    // lights
    darkness: scene.data.darkness,
    tokenVision: scene.data.tokenVision,
    globalLight: scene.data.globalLight,
    globalLightThreshold: scene.data.globalLightThreshold,
    lights: scene.data.lights.map((light) => {
      const l = light.toObject();
      delete l._id;
      return l;
    }),
  };

  if (!data.flags.ddb) data.flags.ddb = {};

  if (data.flags.ddb.tokens) delete data.flags.ddb.tokens;
  data.flags.ddb.tokens = scene.data.tokens
  .filter((token) => !token.actorLink)
  .map((token) => {
    let result = {
      _id: token.data._id,
      name: token.data.name,
      width: token.data.width,
      height: token.data.height,
      scale: token.data.scale,
      x: token.data.x,
      y: token.data.y,
      disposition: token.data.disposition,
      flags: token.data.flags,
      actorLink: false,
      bar1: { attribute: "attributes.hp" },
      effects: [],
      elevation: token.data.elevation,
      hidden: token.data.hidden,
      lightAlpha: token.data.lightAlpha,
      lightAngle: token.data.lightAngle,
      lightAnimation: token.data.lightAnimation,
      tint: token.data.tint,
      actorData: token.data.actorData,
    };

    // the token actor flags here help us match up actors using the DDB ID
    if (token.actor) {
      if (token.actor.data.flags.ddbimporter) {
        result.flags.ddbActorFlags = token.actor.data.flags.ddbimporter;
        result.flags.ddbActorFlags.name = token.actor.data.token?.name ? token.actor.data.token.name : token.actor.data.name;
      }
    }

    return result;
  });


  // removed un-needed userdata
  if (data.flags.ddb?.userData) {
    if (data.flags.ddb.userData.status) delete (data.flags.ddb.userData.status);
    if (data.flags.ddb.userData.userId) delete (data.flags.ddb.userData.userId);
    if (data.flags.ddb.userData.twitchUserName) delete (data.flags.ddb.userData.twitchUserName);
    if (data.flags.ddb.userData.AvatarUrl) delete (data.flags.ddb.userData.AvatarUrl);
  }

  data.flags.ddb.notes = notes;
  data.flags.ddbimporter = {
    version: game.modules.get("ddb-importer").data.version,
  };

  return data;
};

/* harmony default export */ const extendSceneNavigationContext = ((html, contextOptions) => {
  contextOptions.push({
    name: "ddb-importer.scenes.download",
    callback: (li) => {
      const sceneId = $(li).attr("data-scene-id") ? $(li).attr("data-scene-id") : $(li).attr("data-entity-id");
      const scene = game.scenes.get(sceneId);
      // console.warn(scene);
      const data = collectSceneData(scene);
      const bookCode = `${scene.data.flags.ddb.bookCode}-${scene.data.flags.ddb.ddbId}`;
      const cobaltId = scene.data.flags.ddb?.cobaltId ? `-${scene.data.flags.ddb.cobaltId}` : "";
      const parentId = scene.data.flags.ddb?.parentId ? `-${scene.data.flags.ddb.parentId}` : "";
      const contentChunkId = scene.data.flags.ddb?.contentChunkId ? `-${scene.data.flags.ddb.contentChunkId}` : "";
      const name = scene.data.name.replace(/[^a-z0-9_-]/gi, '').toLowerCase();
      const sceneRef = `${bookCode}${cobaltId}${parentId}${contentChunkId}-${name}`;
      // console.warn(data);
      return (0,utils/* download */.LR)(JSON.stringify(data, null, 4), `${sceneRef}-scene.json`, "application/json");
    },
    condition: (li) => {
      const sceneId = $(li).attr("data-scene-id") ? $(li).attr("data-scene-id") : $(li).attr("data-entity-id");
      const scene = game.scenes.get(sceneId);
      const sceneDownload = game.settings.get("ddb-importer", "allow-scene-download");
      const allowDownload = game.user.isGM && sceneDownload && scene.data.flags.ddb?.ddbId;
      return allowDownload;
    },
    icon: '<i class="fas fa-share-alt"></i>',
  });
});

;// CONCATENATED MODULE: ./src/index.js



// register hooks
Hooks.once("init", init);
Hooks.once("ready", onceReady);
Hooks.on("ready", onReady);
Hooks.on("renderSidebarTab", renderSidebarTab);
Hooks.on("renderJournalSheet", renderJournalSheet);
Hooks.on("renderItemSheet", renderItemSheet);
Hooks.on("getSceneNavigationContext", extendSceneNavigationContext);
Hooks.on("getSceneDirectoryEntryContext", extendSceneNavigationContext);

})();

/******/ })()
;